<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌云壮志幾多愁</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-28T05:58:09.139Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王望</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>词法分析——正则表达式直接转换为DFA</title>
    <link href="http://yoursite.com/2019/10/28/compiler_regular2dfa/"/>
    <id>http://yoursite.com/2019/10/28/compiler_regular2dfa/</id>
    <published>2019-10-28T05:41:34.677Z</published>
    <updated>2019-10-28T05:58:09.139Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，我们至少学会了将正则表达式构造成对应的NFA和DFA。但是用上篇文章中从正则表达式转换为对应DFA的方式效率低下，即我们要先将正则表达式转换为NFA，然后使用子集构造法将NFA转换为对应DFA。</p>
<p>在本篇文章中，我们将首先学习如何将正则表达式直接转换为DFA，并最小化DFA的状态数目。然后看看DFA模拟中时间和空间的权衡问题。</p>
<p>在正式进入正则表达式转换为DFA之前我们需要一些基本概念，没有这些基本概念可能不太好理解后面提到的内容。</p>
<h2 id="一、需要的基本概念"><a href="#一、需要的基本概念" class="headerlink" title="一、需要的基本概念"></a>一、需要的基本概念</h2><h4 id="重要状态"><a href="#重要状态" class="headerlink" title="重要状态"></a>重要状态</h4><p>NFA的重要状态直接对应于正则表达式中存放字母表中符号的位置，而 <strong>重要状态是指NFA的某一状态有一个标号为非空的离开转换</strong> 。比如我们在上一节中将正则表达式转换为对应NFA时引入了新状态，它们的离开转换都是空转换，因此它们并不是重要状态。</p>
<blockquote>
<p><strong>每个重要状态对应于正则表达式中某个运算分量</strong> 。</p>
</blockquote>
<p>因此我们在比较两个NFA状态集合时，判断它们是否一致的依据如下：<br>1）、具有相同的重要状态；<br>2）、要么都包含接受状态，要么都不包含接受状态；</p>
<h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p>注意这里的抽象语法树和上一节提到的语法分析树有一点不同，关于语法分析树可以回去看上一篇提到的语法分析树定义。但抽象语法树是必须要完全理解的。</p>
<blockquote>
<p><strong>抽象语法树中，每个内部结点代表一个运算符，该运算符结点的子结点代表这个运算符的运算分量</strong> !!!</p>
</blockquote>
<p>在抽象语法树中，内部结点代表的是程序的构造；而在语法分析树中，内部结点代表的是非终结符。有时候我们将语法分析树称为具体语法树；而抽象语法树简称为语法树。这是因为在文法的很多非终结符都代表程序的具体构造，还有各种辅助符号。而这些在抽象语法树中都是不需要的。</p>
<p>而前面提到的重要状态就是抽象语法树中运算符的运算分量。下面是正则表达式 <code>(a|b)*abb</code>对应的抽象语法树：</p>
<p><img src="/uploads/compiler_regular2nfa/1.png" alt="(a|b)*abb的抽象语法树"></p>
<p>1）、<strong>结束标记符#</strong>：前面我们提到了重要状态，但（NFA或者DFA）接受状态没有一个标号为非空的离开转换，因此接受状态为非重要状态。基于此，我们可以给正则表达式的右边连接一个结束标记符 <code>#</code> ，使得正则表达式的接受状态成为重要状态。那么我们也就不用特殊处理接受状态了。</p>
<p>2）、<strong>叶子节点位置</strong>：上面抽象语法树叶子结点下方都有一个有序的整数，我们称这个整数为对应叶子的结点的位置。<strong>非空的叶子结点才会赋予相应的整数</strong>，也就是说为空串的叶子结点我们不需要对其增加位置。</p>
<h2 id="二、nullable、firstpos、lastpos和followpos函数"><a href="#二、nullable、firstpos、lastpos和followpos函数" class="headerlink" title="二、nullable、firstpos、lastpos和followpos函数"></a>二、nullable、firstpos、lastpos和followpos函数</h2><p>我们要从一个正则表达式直接构造出DFA，除了前面我们已经构造了的抽象语法树之外，我们还需要计算nullable、firstpos、lastpos和followpos函数。</p>
<ul>
<li>1）、<strong><code>bool nullable(n)</code></strong>：其中n的取值为抽象语法树中任意结点（可以是叶子结点，也可以是是内部结点。即运算符和运算分量），其返回值的逻辑是当此结点的子表达式中包含有空串ε时返回true，否则为false；</li>
<li>2）、<strong><code>nodes firstpos(n)</code></strong>：子表达式的语言中某个串的第一个符号，该语言是以n为根的子表达式；</li>
<li>3）、<strong><code>nodes lastpos(n)</code></strong>：子表达式的语言中某个串的最后一个符号，同样的该语言也是以n为根的子表达式；</li>
<li>4）、<strong><code>nodes followpos(n)</code></strong>：这相对要复杂一点。比如在抽象语法树中存在两个结点分别为n和m，存在某个串s = a<sub>1</sub>…a<sub>i</sub>a<sub>i+1</sub>…a<sub>p</sub>，即以该正则表达式为模式的串。要满足followpos(n)==m，那么则需要a<sub>i</sub>和位置n匹配，a<sub>I+1</sub>和位置m匹配。比如当前有一个符号串<code>aabb</code>，想要构造该串对应于上图抽象语法树中各个节点顺序为1、3、4、5，因此我们就说follow(3)=4。通俗一点说就是要看抽象语法树指定结点的followpos，需要先找到对应结点在某个符号串中的位置，然后看该符号后一位符号即可。</li>
</ul>
<p>上面的nodes表示的结点集合。前面说的结点均指的是抽象语法树中的重要位置。</p>
<p>更详细点，当我们计算上面抽象语法树位置1的followpos，即followpos(1)。那么我们通过抽象语法树来看，位置1之后经过并运算和闭包运算可以得到的子串有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aa;/// 第一个a来自于位置1，第二个a来自于位置1。闭包运算循环了两次；</div><div class="line">ab;/// a来自于位置1，b来自于位置2。闭包运算循环了2次；</div><div class="line">aa;///第一个a来自于位置1，第二个a来自于位置3。闭包运算循环了1次；</div></pre></td></tr></table></figure>
<p>因此得到 followpos(1) = {1,2,3};</p>
<p>下表整理了计算nullable、firstpos、lastpos的计算规则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">结点n</th>
<th style="text-align:left">nullabl(n)</th>
<th style="text-align:left">firstpos(n)</th>
<th style="text-align:left">lastpos(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">标号为ε的叶子结点</td>
<td style="text-align:left">true</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">位置为i的叶子结点</td>
<td style="text-align:left">false</td>
<td style="text-align:left">{i}</td>
<td style="text-align:left">{i}</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>并</strong> 结点n=c1\</td>
<td style="text-align:left">c2</td>
<td style="text-align:left">nullable(c1) 逻辑或 nullable(c2)</td>
<td style="text-align:left">firstpos(c1) ∪ firstpos(c2)</td>
<td>lastpos(c1) ∪ lastpos(c2)</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>连接</strong> 结点n=c1c2</td>
<td style="text-align:left">nullable(c1) 逻辑与 nullable(c2)</td>
<td style="text-align:left">如果 <strong>nullable(c1)</strong> 为真，那么值为firstpos(c1) ∪ firstpos(c2)。否则为firstpos(c1)</td>
<td style="text-align:left">如果 <strong>nullable(c2)</strong> 为真，那么值为lastpos(c1) ∪ lastpos(c2)。否则为lastpos(c2)</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>闭包</strong> 结点n=c1*</td>
<td style="text-align:left">true</td>
<td style="text-align:left">firstpos(c1)</td>
<td style="text-align:left">lastpos(c1)</td>
</tr>
</tbody>
</table>
<ul>
<li>1、每个叶子结点的firstpos和lastpos只包含它自身。上表中第2点；</li>
<li>2、“并” 结点的firstpos和lastpos分别是它所有子节点的firstpos和lastpos的并集。上表第3点；</li>
<li>3、“闭包”结点的firstpos和lastpos分别是它唯一子节点的firstpos和lastpos。上表的第5点；</li>
<li>4、对于“连接”结点而言，firstpos主要是看左子结点是否为空。而lastpos右子节点是否为空。</li>
</ul>
<p>现在我们运用上面的规则，将第一节的抽象语法树中每个结点的firstpos和lastpos求出来。如下图：</p>
<p><img src="/uploads/compiler_regular2nfa/2.png" alt=""></p>
<p>图中蓝色表示firstpos集合，而橙色表示lastpos集合。</p>
<h4 id="计算followpos"><a href="#计算followpos" class="headerlink" title="计算followpos"></a>计算followpos</h4><p>只有两种情况会使得正则表达式的某个位置跟在另一个位置之后：</p>
<ul>
<li><p>1）、如果是结点n是一个“连接”结点，且在抽象语法树中其左右子节点分别为c1，c2。那么对于lastpos(c1)中的每个位置i，firstpos(c2)中所有位置都在followpos(i)中；<br>通俗的讲就是以“连接”结点为根的子树，左子结点lastpos集合中每个位置的followpos都包含右子结点的firstpos。有点类似于二叉树后序遍历，左子树最大结点的后面跟着的是右子树的最小结点。</p>
</li>
<li><p>2）、如果n是“闭包”结点，lastpos(n)中每个位置的followpos都包含于的firstpos(n)中；</p>
</li>
</ul>
<p>基于上诉两个规则，我们对上面的图求解各个重要结点的followpos（上图已经标出每个结点的firstpos和lastpos）。下面是详细步骤：</p>
<ul>
<li>1、首先我们运用规则1来查看第一个“连接”结点，其左子结点的lastpos为<code>{1,2}</code>，并且其右子结点的firstpos为<code>{3}</code>。因此位置1结点和位置2结点的followpos都包含有位置3。</li>
</ul>
<p><img src="/uploads/compiler_regular2nfa/3.png" alt=""></p>
<p>需要注意一点的是并不是看的当前结点本身的lastpos和firstpos，而是看的其左子结点的lastpos和右子结点的firstpos。</p>
<table>
<thead>
<tr>
<th style="text-align:left">位置n</th>
<th style="text-align:left">followpos(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">{3}</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">{3}</td>
</tr>
</tbody>
</table>
<ul>
<li>2、同理我们将剩下的“连接”结点运用规则1，得到如下结果（这里太简单了我就不画图了）：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">位置n</th>
<th style="text-align:left">followpos(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">{4}</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">{5}</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{6}</td>
</tr>
</tbody>
</table>
<ul>
<li>3、现在是时候运用上面的规则2了，查找抽象语法树中的“闭包”结点。它和“连接”结点不同的是：“连接”结点看的是其左右子树的lastpos和firstpos，而“闭包”结点看的是其本身的lastpos和firstpos。</li>
</ul>
<p><img src="/uploads/compiler_regular2nfa/4.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">位置n</th>
<th style="text-align:left">followpos(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">{1,2}</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">{1,2}</td>
</tr>
</tbody>
</table>
<ul>
<li>4、现在我们将前面三步得到的数据进行合并之后的结果为：</li>
</ul>
<p>很明显位置6作为增广正则表达式中存在的终结符标识，因此其followpos为空集。</p>
<table>
<thead>
<tr>
<th style="text-align:left">位置n</th>
<th style="text-align:left">followpos(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">{1,2,3}</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">{1,2,3}</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">{4}</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">{5}</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{6}</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">∅</td>
</tr>
</tbody>
</table>
<p>回过头来看一下正则表表达式 <code>(a|b)*abb</code>匹配子串中，位置1对应的结点a其后可能存在字符为a（位置1）、b（位置2）、a（位置3）。位置2和位置1同理。</p>
<p>现在我们将每个位置，已经对应的followpos用一个有向图来表示如下：</p>
<p><img src="/uploads/compiler_regular2nfa/5.png" alt=""></p>
<p>很明显的可以看出来，表示followpos函数的有向图几乎就是相应的正则表达式不包含空转换的NFA。</p>
<h2 id="三、根据正则表达式构建DFA"><a href="#三、根据正则表达式构建DFA" class="headerlink" title="三、根据正则表达式构建DFA"></a>三、根据正则表达式构建DFA</h2><p>要从一个正则表达式构造一个DFA的大致步骤如下：</p>
<ul>
<li>1、根据扩展的正则表达式构造出一个抽象语法树；</li>
<li>2、计算每个节点的nullable函数值、firstpos函数值、lastpos函数值。以及重要位置节点的followpos函数值；</li>
<li>3、抽象语法树根节点的 <strong>firstpos</strong> 作为DFA的开始状态；</li>
<li>4、查看正则表达式中存在的各个转换（即a或者b），将当前状态中相同转换的followpos合并到一个集合中；</li>
<li>5、如果合并的集合出现新的状态，则将该状态添加到DFA的状态集合中；</li>
<li>6、如果经过各个转换之后没有新状态就停止。否则重复执行4~6步；</li>
</ul>
<p>看一下例子能够更加清晰地认识到如何根据正则表达式构建DFA。</p>
<p><img src="/uploads/compiler_regular2nfa/2.png" alt=""></p>
<p>图中蓝色表示firstpos集合，而橙色表示lastpos集合。</p>
<p>1）、对于正则表达式 <code>(a|b)*abb</code>，我们构造得到的抽象语法树，已经对应的firstpos/lastpos都在上图中;</p>
<p>2）、我们将根节点的firstpos = {1,2,3} 作为DFA的开始状态：</p>
<p>3）、该正则表达式中存在的转换有<code>a, b</code>，开始状态集合为{1,2,3}，此时我们将状态集合{1,2,3}相同状态的followpos合并到一个集合中。<br>集合{1,2,3}中对应转换a的位置有1，3；对应转换b的位置有{2}。<br>转换a的 <code>followpos(1)={1,2,3}, followpos(3)={4}</code>，将两个集合合并起来为 <code>{1,2,3,4}</code>，由于该状态是新状态，因此将状态集合{1,2,3,4}添加到DFA中；<br>转换b的<code>followpos(2)={1,2,3}</code>，由于该状态并不是新状态。因此只是一个简单转换即可。</p>
<p>重复执行第三步，得到的最终结果为：</p>
<p><img src="/uploads/compiler_regular2nfa/6.png" alt="基于抽象语法树得到的DFA"></p>
<h2 id="四、最小化DFA的状态数"><a href="#四、最小化DFA的状态数" class="headerlink" title="四、最小化DFA的状态数"></a>四、最小化DFA的状态数</h2><p>对于同一个语言，可以存在多个识别此语言的DFA。例如上图和上一节中由NFA通过子集构造法得到的DFA都能够识别正则表达式 <code>(a|b)*abb</code>。可以看出来它们的个数也不一样。因此如果让我们使用DFA来实现词法分析器，我们肯定是希望使用状态数量尽量少的DFA了。</p>
<p>首先我们先看看区分状态的概念： <strong>区分状态</strong>，如果从状态s和t出发，沿着标号为x的路径到达的两个状态中只有一个是接受状态，那么我们就说串x区分状态s和t。状态s和t是可区分的。<br>空串ε可以区分任何一个接受状态和非接受状态。</p>
<p><img src="/uploads/compiler_regular2nfa/7.png" alt="子集构造法得到的DFA"></p>
<p>上图中串 <code>bb</code> 可以区分状态A和B，这是因为从A出发经过标号为bb的路径到达会接受状态C，而状态B经过标号bb的路径到达状态E接受状态。</p>
<p>其次还有一个重要的结论：<strong>任何正则语言都有一个唯一的状态数目最少的DFA</strong>。而且从任意一个接受相同语言的DFA出发，通过 分组、合并等价的状态，我们总是可以构建得到这个状态数量最少的DFA。</p>
<p>因此DFA状态最小化算法的工作原理是：</p>
<blockquote>
<p><strong>将一个DFA的状态集合划分成多个组，每个组中的各个状态之间相互不可区分，但是来自不同组任意的两个状态是可区分的</strong>（前面提到的区分概念）。</p>
</blockquote>
<p>然后将每个组中的状态合并成状态最少DFA的一个状态。</p>
<p>最初，划分两个组：<strong>接受状态组和非接受状态组</strong>。基本步骤是从当前划分中取一个状态组，比如 A = {s<sub>1</sub>, s<sub>2</sub>, … , s<sub>k</sub>}，并选定某个输入符号a，检查a是否可以用于区分A组中的某些状态。查看s<sub>1</sub>, s<sub>2</sub>, … , s<sub>k</sub>在a上的转换，如果这些转换的到达的状态落入当前划分的两个或多个组中，我们就将A分割成多个组。</p>
<p>我们以上图为例来看看DFA状态最小化算法：<br>1）、首先划分两组：接受状态组合非接受状态组，这里我们分别给他们起名为组1和组2。</p>
<p><img src="/uploads/compiler_regular2nfa/8.png" alt=""></p>
<p>2）、在上图看到DFA仅有a、b两种转换。由于组2只包含了一个状态，并且该状态为接受状态而不能再被分割，所以组2原封不动。因此我们继续看组1。<br>组1中的状态A、B、C、D针对a的转换，得到的状态均为状态B，因此串a无法区分状态A、B、C、D。</p>
<p>3）、组1中的状态A、B、C、D针对b的转换，状态A、B、C都是到达组内某个成员上，这显然是无法区分的（前面提到过组内各个状态之间互不可区分）。但状态D到达的是组2成员对应的状态，很明显状态D可以和A、B、C区分开来。因此我们可以继续将组1划分更小的组：</p>
<p><img src="/uploads/compiler_regular2nfa/9.png" alt=""></p>
<p>4）、类似于第三步，组3的状态A、B、C针对b的转换可以划分为两个不同的组。这是因为状态A、C经过转换b之后均为组内状态；而状态B经过转换b得到的组4成员对应的状态：</p>
<p><img src="/uploads/compiler_regular2nfa/10.png" alt=""></p>
<p>由于组5中各个状态，无论是针对转换a，还是转换b而言，得到的状态均相同。因此我们不能讲组5进行更细粒度的划分。那么上图就是最终的划分结果。</p>
<p>现在我们根据上面的信息画出对应的状态转换表，由于状态A和状态C经过转换得到的状态是一样的，因此集合{A,C}这里以状态A表示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">D</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">B</td>
<td style="text-align:left">E</td>
</tr>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">B</td>
<td style="text-align:left">A</td>
</tr>
</tbody>
</table>
<p>我们画出对应的DFA，并将其与上面我们用抽象语法树构造得到的DFA进行对比：</p>
<p><img src="/uploads/compiler_regular2nfa/11.png" alt=""></p>
<p>很明显能够对比出来，上面两个DFA除了赋予各个状态的名称不一样之外，各个转换以及转换后的状态都是一样的。我们称这两个状态机是同构的。<strong>同构</strong>是指对于两个不同的自动机，如果某个自动只是通过更改状态的名字就可以转换为另一个自动机。</p>
<h2 id="五、DFA模拟中的时间和空间的权衡"><a href="#五、DFA模拟中的时间和空间的权衡" class="headerlink" title="五、DFA模拟中的时间和空间的权衡"></a>五、DFA模拟中的时间和空间的权衡</h2><p>最简单和最快捷的表示一个DFA的转换函数的方法是：使用一个以状态和字符为下标的二维表。给定一个状态和下一个输入字符，我们访问这个数组就可以找出下一个状态以及我们必须要执行的特殊动作。<br>但是我们知道对于二维表而言，各个状态针对某些字符并没有对应转换。如果数量变多了之后就会存在大量的空间浪费问题。</p>
<p>我们可以使用一个带有四个数组的数据结构，如下图所示：</p>
<p><img src="/uploads/compiler_regular2nfa/12.png" alt=""></p>
<p>1）、base数组用于确定状态s条目的基准位置；<br>2）、next和check数组存放的正式对应状态条目；<br>3）、数组check用于确定base[s]给出的基准位置是否正确，如果错误则使用default数组来确定另一个基准位置；</p>
<p>在计算状态s在输入a的后继状态时，我们首先查看数组next和check中在位置 <code>index = base[s] + a</code> （a指当前输入字符，其对应于ascii码表上固定数字）上的状态条目。<br>a、如果check[index] == s，那么该状态条目有效（该状态指的是经过转换a之后得到的后续状态）；<br>b、如果check[index] != s，那我们则得到另一个状态条目t = default[s]。并将状态t设置为当前状态重复上诉过程获取下一个状态；</p>
<p>下面是对应的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int nextState(s,a) &#123;</div><div class="line">  if(check[base[s]+a] == s) return next[base[s]+a];</div><div class="line">  else return nextState(default[s],a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节中需要重点理解的就是抽象语法树：抽象语法树的每个内部结点代表一个运算符，该内部结点的子节点代表运算符的运算分量。然后可以根据正则表达式构造对应的抽象语法树。<br>函数nullable、firspos、lastpos以及followpos在构造DFA中起着重要的作用。nullable指的是对应结点的子表达式是否可能返回空串；firstpos是子表表达式串的第一个符号；lastpos是子表达式串的最后一个符号；followpos则是相对要复杂一点，只针对连接结点和闭包结点求followpos。<br>在有了上面只是作为铺垫之后，求正则表达式来DFA的转换就要轻松许多。首先是在抽象语法树中以根节点所在的firstpos集合作为DFA的开始状态。然后查看集合内部各个序号对应的转换，获取对应需要的followpos求并集。以此类推下去可构造一个完整的DFA。<br>而在最小化DFA状态数时，则根据不同的划分，递归地将各组区分开来，得到状态数最少的DFA。而在最后也给出了权衡时间和空间的数据结构。</p>
<p>到这儿基本上把词法分析相关的知识都简单过了一遍了。后续再继续更新语法分析部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇文章中，我们至少学会了将正则表达式构造成对应的NFA和DFA。但是用上篇文章中从正则表达式转换为对应DFA的方式效率低下，即我们要先将正则表达式转换为NFA，然后使用子集构造法将NFA转换为对应DFA。&lt;/p&gt;
&lt;p&gt;在本篇文章中，我们将首先学习如何将正则表达式直接转
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="词法分析" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>词法分析——从正则表达式到有穷自动机</title>
    <link href="http://yoursite.com/2019/10/28/compiler_regular_fa/"/>
    <id>http://yoursite.com/2019/10/28/compiler_regular_fa/</id>
    <published>2019-10-28T04:49:52.840Z</published>
    <updated>2019-10-28T05:13:10.289Z</updated>
    
    <content type="html"><![CDATA[<p>自动机在本质上是和状态转换图类似的。但也有一点不同，它们只能对每个可能的输入串简单地回答“是”或者“否”；有穷自动机分为两类：</p>
<ul>
<li>1、<strong>不确定的有穷自动机（NFA）</strong>：其边上的标号没有任何限制，离开一个状态的多条边上可以存在多个相同的符号，也可以是空；</li>
<li>2、<strong>确定的有穷自动机（DFA）</strong>：对于每个符号而言，以该符号为标号的边有且只有一条离开该状态。</li>
</ul>
<p>下面我们就一次来看看不确定的有穷自动机，和确定的有穷自动机。</p>
<h2 id="一、NFA——不确定的有穷自动机"><a href="#一、NFA——不确定的有穷自动机" class="headerlink" title="一、NFA——不确定的有穷自动机"></a>一、NFA——不确定的有穷自动机</h2><p>不确定的有穷自动机由下面几个部分组成：<br>1）、有穷的状态集合，类似于上一节中状态转换表的每一个节点；<br>2）、一个输入符号集合，可以简单地理解为unicode字符集之类的；<br>3）、转换函数，类似于状态转换表中的有向箭头一样；<br>4）、开始状态，或者叫初始状态；<br>5）、接受状态，也称作终止状态，如下图的双圆圈表示；</p>
<p><img src="/uploads/compiler_regular_fa/1.png" alt=""></p>
<p>上图是一个能够识别正则表达式 <code>(a|b)*abb</code>的NFA转换图。</p>
<h4 id="转换表和接收串"><a href="#转换表和接收串" class="headerlink" title="转换表和接收串"></a>转换表和接收串</h4><p>我们可以将一个NFA表示为一张转换表。表的每一行表示一个状态，表的每一列对应于输入符号和空串。先将上图的NFA转换图转换成为对应的转换表，然后根据转换表再具体说明其中的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
<th style="text-align:left">空字符ε</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">{0,1}</td>
<td style="text-align:left">{0}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">{2}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">{3}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">∅</td>
</tr>
</tbody>
</table>
<p>对于一个给定的状态和给定的转换，其得到的值是NFA转换图中应用对应转换之后得到的状态集合。如果对应的转换没有后续状态，则用符号∅表示。</p>
<p>而自动机在判断是否接收字符串的依据是：存在某条字符序列组成符号串的路径，该路径能够从开始状态到达某个接收状态。我们就说NFA接收这个符号串。比如：</p>
<p><img src="/uploads/compiler_regular_fa/2.png" alt=""></p>
<p>该NFA接收符号串：</p>
<p><img src="/uploads/compiler_regular_fa/3.png" alt=""></p>
<p>即字符串<code>aaa</code>被这个NFA接受。路径中的ε并不会记录在实际的路径中。</p>
<h2 id="二、DFA——确定的有穷自动机"><a href="#二、DFA——确定的有穷自动机" class="headerlink" title="二、DFA——确定的有穷自动机"></a>二、DFA——确定的有穷自动机</h2><p>确定的有穷自动机是不确定有穷自动机的特例，它性质如下：<br>1）、没有输入符号ε；<br>2）、对于每一个状态s，每一个输入符号a，有且只有一条边离开状态s。</p>
<p>通俗来讲就是指定某个状态，不存在两个或者以上相同的转换存在。比如对于NFA而言，状态0中转换a可以到达两个及其以上不同的状态；而DFA则只能到达一个（有且只有）状态。 比如下面同样是识别<code>(a|b)*abb</code>的DFA转换图：</p>
<p><img src="/uploads/compiler_regular_fa/4.png" alt=""></p>
<p>对于给定的输入串<code>ababb</code>，这个DFA的对应状态顺序为：0、1、2、1、2、3。</p>
<h2 id="三、正则表达式、NFA以及DFA之间的关联"><a href="#三、正则表达式、NFA以及DFA之间的关联" class="headerlink" title="三、正则表达式、NFA以及DFA之间的关联"></a>三、正则表达式、NFA以及DFA之间的关联</h2><p>这里首先我们将正则表达式转变为接受相同语言的NFA。然后介绍如何将NFA转变为DFA。这样我们就有了一个粗略的方式将正则表达式转换为NFA和DFA的方案。</p>
<h4 id="正则表达构造NFA的规则"><a href="#正则表达构造NFA的规则" class="headerlink" title="正则表达构造NFA的规则"></a>正则表达构造NFA的规则</h4><p>通过正则表达式构造NFA主要分为六种情况。在下面每一个情况中，我们都有提出状态i和状态f是否为新状态。指出的意义在于我们需要明确新构建NFA时出现的状态是否为原各个NFA中已有状态，还是需要我们去新增一个状态。比如在连接运算中出现的状态i和f并非新状态，而是已有状态的特殊状态：</p>
<ul>
<li><p><strong>规则1</strong>、空字符ε表达式；对于表达式ε，构造下面的NFA<br><img src="/uploads/compiler_regular_fa/5.png" alt=""><br>这里i是一个新状态，也是NFA的开始状态；f是另一个新状态，也表示NFA的接受状态</p>
</li>
<li><p><strong>规则2</strong>、字母表中子表达式；<br>这里状态i和状态f是新状态<br><img src="/uploads/compiler_regular_fa/6.png" alt=""></p>
</li>
<li><p><strong>规则3</strong>、正则表达式中的并运算；<br>假设正则表达式s和t对应的NFA为N(s)和N(t)，<code>r = s|t</code>的NFA为N(r)。这里状态i和状态f是新状态：<br><img src="/uploads/compiler_regular_fa/7.png" alt=""><br>因此从状态i到状态f的任何路径要么只通过N(s)，要么只通过N(t)。且离开i或进入f的ε转换都不会改变路径上的标号。因此我们可以判定 <strong>N(r)识别 L(r) = L(s) ∪ L(t)</strong> 。</p>
</li>
<li><p><strong>规则4</strong>、正则表达式中的连接运算；<br>同样的，假设正则表达式s和t对应的NFA为N(s)和N(t)，<code>r = st</code> 。对应的NFA为：<br><img src="/uploads/compiler_regular_fa/8.png" alt=""><br>这个情形下的状态i和状态f并非新引入的状态，而是原有正则表达式s和t中已有的状态。</p>
</li>
<li><p><strong>规则5</strong>、正则表达式中的闭包运算；<br>这里假设正则表达式 <code>r = s*</code>，N(s)表示正则表达式s对应的NFA。因此闭包运算得到的NFA为：<br><img src="/uploads/compiler_regular_fa/9.png" alt=""><br>这里状态i和状态f都是新引入的状态。</p>
</li>
<li><p><strong>规则6</strong>、括号表达式<code>r = (s)</code> 其NFA是完全相同的；</p>
</li>
</ul>
<p>因此 <strong>只有在正则表达式的连接运算和括号存在时，才不会引入新的状态</strong> 。N(r)的状态数最多为r中出现的运算符和运算分量总数的两倍。这是因为每一个构造步骤最毒只引入两个新状态。</p>
<h4 id="正则表达式构造NFA实例"><a href="#正则表达式构造NFA实例" class="headerlink" title="正则表达式构造NFA实例"></a>正则表达式构造NFA实例</h4><p>现在我们运用上面提到的规则，来将一个正则表达式转换为对应的NFA。将正则表达式转换为NFA的算法是语法制导的，也就是说：</p>
<blockquote>
<p>沿着正则表达式的语法分析树 <strong>自底向上</strong> 递归的进行。</p>
</blockquote>
<p>下面关于语法分析树定义部分可以选读，由于会用到很多专业名词，此时大可不必去细究语法分析树，因为对于我来说理解下文并不是必须需要这些知识点。但为了行文的准确性，我将下面要用的语法分析树的定义先列出来。<br>语法分析树用图形方式展示了从文法的开始符号推导出相应语言中符号串的过程。给定一个上下文无关文法，该文法的语法分析树具有如下形式：<br>1）、根节点的标号为文法的开始符号（大体上为文法的第一个产生式的首个符号）；<br>2）、每个叶子结点的标号为一个终结符或者空ε（具体字母表中的符号，粗略来看它的叶子结点从左到右组成了最终的正则表达式）；<br>3）、每个内部结点的标号为一个非终结符（可以简单理解为该符号还存在产生式还可以可以推导出终结符号）。<br>4）、对于产生式A-&gt;XYZ，对于X, Y ,Z来说既可以是终结符，也可以是非终结符。</p>
<p>对于正则表达式 <code>(a|b)*abb</code> ，我们构造处对应的语法分析树：</p>
<p><img src="/uploads/compiler_regular_fa/10.png" alt=""></p>
<p>1）、既然是自底向上的，那首先肯定是看子表达式a和b。运用规则1，即可得到两个NFA：</p>
<p><img src="/uploads/compiler_regular_fa/11.png" alt=""></p>
<p>2）、现在的叶子节点为并运算符，此时运用规则3。此时我们需要新引入两个状态，并且原有NFA中的接受状态要变为非接受状态：</p>
<p><img src="/uploads/compiler_regular_fa/12.png" alt=""></p>
<p>对于带有括号的正则表达式而言，我们从规则6可知，括号运算符不会改变当前的NFA。因此当遇到括号时NFA不改变。</p>
<p>3）、对于闭包运算符来说，同样会引入两个新状态：</p>
<p><img src="/uploads/compiler_regular_fa/13.png" alt=""></p>
<p>4）、最后是3个连接操作，连接的子表达式分别是a、b、b。因此将它们连接之后得到的最终NFA如下：</p>
<p><img src="/uploads/compiler_regular_fa/14.png" alt=""></p>
<h4 id="NFA到DFA的转换——子集构造法"><a href="#NFA到DFA的转换——子集构造法" class="headerlink" title="NFA到DFA的转换——子集构造法"></a>NFA到DFA的转换——子集构造法</h4><p>现在我们已经能够从正则表达式转换为NFA了，那如果我们要把正则表达式转换为DFA呢？这里先介绍用NFA转换为DFA的方式，后续会将通过抽象语法树搭配firstpos，lastpos和followpos直接从正则表达式构造DFA。现在我们先通过子集构造法来讲NFA转换为DFA。</p>
<p>子集构造法中，我们需要通过NFA为DFA构造转换表。</p>
<blockquote>
<p><strong>DFA的每一个状态是一个NFA的状态集合</strong>。</p>
</blockquote>
<p>DFA的状态是一个集合，该集合里面包含的是对应NFA的状态。</p>
<p>我们在上面看到在将正则表达式构造成NFA时，NFA里面存在很多空转换。所以当务之急是如果正确地处理NFA上面的空转换。下面展示了NFA的状态集合上的相关操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">ε-closure(s)</td>
<td style="text-align:left">指的是从NFA的状态s开始，可以通过ε转换得到的状态集合</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">ε-closure(T)</td>
<td style="text-align:left">指的是集合T中的某个NFA状态，该状态只通过ε转换得到的状态集合</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">move(T,a)</td>
<td style="text-align:left">即集合T中的状态通过转换a得到的状态集合</td>
</tr>
</tbody>
</table>
<p>假设s<sub>0</sub>是NFA的开始状态，那么对应DFA的开始状态就是 <strong>ε-closure(s<sub>0</sub>)</strong> 。而DFA的接受状态是至少包含NFA接受状态的集合。</p>
<p>我们在上一节得到的NFA，现在我们将该NFA转换为DFA：</p>
<p>1、对于开始状态0，我们使用操作1（上表中序号为1的操作，下文类似），即状态0通过ε空转换可以得到的状态集合为： <code>{0, 1, 2, 3, 7}</code>。<br>这里有一点需要注意的是：因为路径可以不包含边，所以状态0也是可以从它自身出发经过标号ε到达的状态。</p>
<p><img src="/uploads/compiler_regular_fa/15.png" alt=""></p>
<p>2、我们对第一步得到的集合求转换a的集合。现在我们看状态集合<code>{0, 1, 2, 3, 7}</code>通过转换a（即应用操作3）可以得到的状态集合<code>{3,8}</code>。此时我们对集合<code>{3,8}</code>应用操作2得到的集合为<code>{1, 2, 4, 6, 7}</code>：</p>
<p><img src="/uploads/compiler_regular_fa/16.png" alt=""></p>
<p>在集合{0, 1, 2, 3, 7}里面，只有状态2和状态7可以通过a转换得到的集合是{3, 8}。此时查看状态3通过空转换得到集合为：<br>a、s<sub>3</sub> –<code>ε</code>–&gt; s<sub>6</sub> –<code>ε</code>–&gt; s<sub>7</sub>;<br>b、s<sub>3</sub> –<code>ε</code>–&gt; s<sub>6</sub> –<code>ε</code>–&gt; s<sub>1</sub> –<code>ε</code>–&gt; s<sub>2</sub>;<br>c、s<sub>3</sub> –<code>ε</code>–&gt; s<sub>6</sub> –<code>ε</code>–&gt; s<sub>1</sub> –<code>ε</code>–&gt; s<sub>4</sub>;<br>因此最终的集合为 <strong>{1,2,3,4,6,7,8}</strong>。</p>
<p>3、同样的，我们对第一步得到的集合求转换b的集合。现在我们看状态集合<code>{0, 1, 2, 3, 7}</code>通过转换b可以得到的状态集合<code>{5}</code>。然后集合{5}通过空转换可以得到的集合为{1, 2, 4, 6, 7}</p>
<p><img src="/uploads/compiler_regular_fa/17.png" alt=""></p>
<p>具体的分析和第2步类似。</p>
<p>这样我们对后续出现的每一个状态都执行对应的转换a、转换b。我们可以得到一个状态转换表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">NFA状态</th>
<th style="text-align:left">DFA状态</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">{0,1,2,4,7}</td>
<td style="text-align:left">A</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">{1,2,3,4,6,7,8}</td>
<td style="text-align:left">B</td>
<td style="text-align:left">B</td>
<td style="text-align:left">D</td>
</tr>
<tr>
<td style="text-align:left">{1,2,4,5,6,7}</td>
<td style="text-align:left">C</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">{1,2,4,5,6,7,9}</td>
<td style="text-align:left">D</td>
<td style="text-align:left">B</td>
<td style="text-align:left">E</td>
</tr>
<tr>
<td style="text-align:left">{1,2,4,5,6,7,10}</td>
<td style="text-align:left">E</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
</tr>
</tbody>
</table>
<p>我们前面说过NFA开始状态通过ε转换得到集合为开始状态，因此上表中对应DFA对应的状态为A。而NFA状态集合中包含有接受状态对应DFA的状态E，因此E为DFA的接受状态。对应的DFA如下：</p>
<p><img src="/uploads/compiler_regular_fa/18.png" alt=""></p>
<p>下面是对应算法的伪代码描述。模拟一个NFA的执行（即NFA转换为DFA）</p>
<p>a）、输入部分：<br>一个以eof结束的输入串x；<br>一个NFA N，它的开始状态为s<sub>0</sub>，接受状态为F，转换函数<code>move</code>；<br>b）、输出：如果NFA N接受符号串x，则返回yes，否则返回no；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">S = ε-closure(s0); /// 首先求出开始状态经过空转换之后的集合，即上面的第1步</div><div class="line">c = nextChar(); /// 读取下一个输入字符</div><div class="line">while(c != eof) &#123;</div><div class="line">  /// 首先计算当前集合S经过转换c之后得到集合，然后用该集合进行空转换。得到c转换之后真正的元素集合。</div><div class="line">  /// 即上面提到的第2、3步</div><div class="line">  S = ε-closure(move(S,c)); </div><div class="line">  c = nextChar();</div><div class="line">&#125;</div><div class="line">if (S ∩ F != ∅) return YES;</div><div class="line">else retnru NO;</div></pre></td></tr></table></figure>
<h2 id="四、词法分析器生成工具的设计"><a href="#四、词法分析器生成工具的设计" class="headerlink" title="四、词法分析器生成工具的设计"></a>四、词法分析器生成工具的设计</h2><p>词法分析器的程序包含一个固定模拟自动机的程序（先不指定是NFA，还是DFA）。下图是一个lex程序转换成自动机的结构：</p>
<p><img src="/uploads/compiler_regular_fa/19.png" alt=""></p>
<p>这里提到了前面介绍的几个概念，这儿简要说明一下。输入缓冲区可以让我们依次读入多个字符到缓冲区中（这个大致为4096字节），而不是每读入一个字符就调用一次系统读取命令；词素作为匹配了某个模式词法单元的字符串，比如词素为<code>name</code>词法单元<strong>id</strong>；指针lexemeBegin指向当前词素的开始位置处；指针forward的作用是一直向前扫描，直到匹配某个模式为止。</p>
<p>下表中有三个模式，已经对应模式的动作。这个表指明了词法分析器需要的模式，已经匹配到对应模式之后的动作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">模式</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">P<sub>1</sub></td>
<td style="text-align:left"><code>a</code></td>
<td style="text-align:left">A<sub>1</sub></td>
</tr>
<tr>
<td style="text-align:left">P<sub>2</sub></td>
<td style="text-align:left"><code>abb</code></td>
<td style="text-align:left">A<sub>2</sub></td>
</tr>
<tr>
<td style="text-align:left">P<sub>3</sub></td>
<td style="text-align:left"><code>a*b+</code></td>
<td style="text-align:left">A<sub>3</sub></td>
</tr>
</tbody>
</table>
<p>这里的动作是指匹配到对应模式之后需要做的相关操作，比如匹配到词法单元id之后的动作是生成对应的标识符，获取对应词法单元并返回给语法分析器；匹配到空白符之后我们将输入回退到非空白符的开头，而且不向语法分析器返回任何词法单元。等等。</p>
<p>上表中满足模式P<sub>2</sub>和也同时满足模式P<sub>3</sub>，当出现这种冲突时我们首先选择P<sub>2</sub>。这是因为在解决冲突时 </p>
<blockquote>
<p><strong>以先出现的模式为主</strong> (P<sub>2</sub>先于P<sub>3</sub>列出)。</p>
</blockquote>
<p>下面列出三个模式对应的NFA：</p>
<p><img src="/uploads/compiler_regular_fa/20.png" alt=""></p>
<p>以及将上面三个合并之后得到的NFA：</p>
<p><img src="/uploads/compiler_regular_fa/21.png" alt=""></p>
<p>现在如果词法分析器模拟了上图的NFA，那么该分析器必须从它的输入中<code>lexemeBegin</code>指向的位置开始读取输入，并移动forward指针。然后根据子集构造法来获取当前的状态集合。<br>需要注意的是：这里并不是使用子集构造法将NFA转换为DFA，而只是简单地想知道某一状态集合通过子集构造法之后得到的新的状态集合（不过在下面的“词法分析器使用的DFA”一节会使用该表，该表的第二列就是对应DFA的状态）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">NFA状态</th>
<th style="text-align:left">状态编号（DFA状态）</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">{0,1,3,7}</td>
<td style="text-align:left">A</td>
<td style="text-align:left">B</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">{2,4,7}</td>
<td style="text-align:left">B</td>
<td style="text-align:left">D</td>
<td style="text-align:left">E</td>
</tr>
<tr>
<td style="text-align:left">{8}</td>
<td style="text-align:left">C</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">{7}</td>
<td style="text-align:left">D</td>
<td style="text-align:left">D</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">{5,8}</td>
<td style="text-align:left">E</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td style="text-align:left">{6,8}</td>
<td style="text-align:left">F</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">C</td>
</tr>
</tbody>
</table>
<p>在上表中，最终会达到一个没有后续状态的输入点。此时不可能有任何更长的输入前缀使得这个NFA到达某个接受状态，此后的状态将一直为空。比如上表中状态编号为C、E、F之后再继续输入a，那么此时就没有任何的后续状态。</p>
<p><img src="/uploads/compiler_regular_fa/22.png" alt=""></p>
<p>上图中我们的输入字符串以 <code>aaba</code> 开头。当我们在读入第四个符号 a 之后，此时我们处于一个空状态集合中（也可以从上表中第三行得出）。</p>
<blockquote>
<p><strong>这时候我们就沿着状态集的顺序往回找，直到找到包含一个或多个接受状态的集合为止</strong> 。</p>
</blockquote>
<p>如果集合中存在多个接受状态，那么我们就选择模式靠前相对应的接受状态。此时将<code>forward</code>指针移动到词素的末尾，同时执行对应的动作（前面表格中的A<sub>1</sub>…A<sub>3</sub>）。</p>
<p>在这里表明输入串aaba被模式 <code>a*b+</code> 匹配。然后执行对应的动作A<sub>3</sub>。</p>
<h4 id="词法分析器使用的DFA"><a href="#词法分析器使用的DFA" class="headerlink" title="词法分析器使用的DFA"></a>词法分析器使用的DFA</h4><p>根据前面的转换表，我们构造出对应的DFA：</p>
<p><img src="/uploads/compiler_regular_fa/23.png" alt=""></p>
<p>对于状态{6,8}而言有两个接受状态，分别对应于模式 abb 和 a<em>b+ 。由于前一个模式先被列出，因此我们选择 <em>*abb</em></em> 作为状态{6,8}所关联的模式。</p>
<p>在词法分析器中，使用DFA和使用NFA的方法相似。模拟DFA运行，直到某一点上没有后续状态为止。这种时候我们就沿着顺序往回找，直到找到包含一个或多个接受状态的集合为止。</p>
<h4 id="向前看运算符"><a href="#向前看运算符" class="headerlink" title="向前看运算符"></a>向前看运算符</h4><p>有时候为了能够正确地识别某个词法单元的实际词素，我们需要指明 <strong>该词法单元模式r<sub>1</sub>之后必须跟着模式r<sub>2</sub></strong> ，因此我们可以将其表示为 “r<sub>1</sub>/r<sub>2</sub>“ 。实际上在将r<sub>1</sub>/r<sub>2</sub>转换为对应的NFA时，<strong>我们把/看成ε（不会去输入中查找/）</strong>。 例如：</p>
<p><img src="/uploads/compiler_regular_fa/24.png" alt=""></p>
<p>上图是词法单元IF的模式，在这个模式中我们使用了向前看运算符。状态6表明了关键字IF的出现，因为如果只是单单的空转换之前的模式（r<sub>1</sub>）将无法准确的识别是关键字if，还是一个带有if前缀的标识符。<br>当进入了状态6时，我们需要向回扫描到最晚出现的状态2，此时我们找到了对应词法单元的词素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中，我们认识到了NFA（不确定的有穷自动机）和DFA（确定的有穷自动机），以及它们与状态转换图之间的差异。DFA和NFA最明显的差异莫过于对于每一个状态s，对于同一个输入符号而言有且只有一条离开该状态的边。<br>其次我们知道了如何通过正则表达式构造NFA，大致的操作有连接、并、闭包和简单的括号操作操作。其中并和闭包操作会引入新状态（使用空转换进行连接）。<br>然后我们通过子集构造法可以将NFA转换为对应的DFA。其中包括有三种操作，分别是：某一指定状态的空转换；某一指定集合执行空转换；某一指定集合执行特定转换a。通过这三种操作我们构造出NFA对应DFA的转换表。<br>最后我们了解了一点词法分析器生成工具的设计，以及向前看运算符的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动机在本质上是和状态转换图类似的。但也有一点不同，它们只能对每个可能的输入串简单地回答“是”或者“否”；有穷自动机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、&lt;strong&gt;不确定的有穷自动机（NFA）&lt;/strong&gt;：其边上的标号没有任何限制，离开一个状态的多条边上可以
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="词法分析" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>词法分析——手动词法单元的识别（状态转换图、KMP算法）</title>
    <link href="http://yoursite.com/2019/10/28/compiler_stateGraph_kmp/"/>
    <id>http://yoursite.com/2019/10/28/compiler_stateGraph_kmp/</id>
    <published>2019-10-28T04:10:38.170Z</published>
    <updated>2019-10-28T04:47:25.849Z</updated>
    
    <content type="html"><![CDATA[<p>在这儿我们先用手工的方式将正则表达式表示的模式转换为状态转换图。在下一节我们会用自动化的方法构造对应的转换图。</p>
<p><img src="/uploads/compiler_stateGraph_kmp/1.png" alt=""></p>
<p>1）、<strong>结点</strong>：状态转换图有一组被称为“状态”的结点，它表示在扫描过程（即词法分析器扫描指定输入串，寻找指定模式词素）中可能出现的状态。也就是lexemeBegin指针和forward指针之间的所有的字符。<br>2）、<strong>边</strong>：从图的一个状态指向另一个状态，每条边的标号包含了一个或多个符号。如果找到这样的一条边，就将forward指针前移，并进入该边指向的下一个状态。<br>3）、<strong>开始状态</strong>：也就是上图中的<code>start</code>。<br>4）、<strong>接收状态或者最终状态</strong>：该状态表明已经找到了一个词素。也就是上图中两个圆圈。</p>
<blockquote>
<p>接收状态通常是 <strong>向语法分析器返回一个词法单元和相关的属性值</strong> 。</p>
</blockquote>
<p>5）、<strong>回退🌟号</strong>：上图中接受状态右上角的*号，表示我们识别到的词素并不包含使我们到达接受状态的符号（也就是上图中的no let/dig边）。此时我们需要回退forward指针到倒数第二个状态。这其中可能会回退多步，所以这里用*号来表示需要回退；</p>
<h3 id="relop状态转换图"><a href="#relop状态转换图" class="headerlink" title="relop状态转换图"></a>relop状态转换图</h3><p>我们根据上一节的relop词法单元，已经对应的属性来构造一个relop的状态转换图</p>
<table>
<thead>
<tr>
<th style="text-align:left">词素</th>
<th style="text-align:left">词法单元名字</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">LT</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">GT</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left"><strong>…</strong></td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">NE</td>
</tr>
</tbody>
</table>
<p><img src="/uploads/compiler_stateGraph_kmp/2.png" alt=""></p>
<p>其实对于这个状态转换图来说，我只画了其中的比较运算符和逻辑运算符。对于位运算符（&lt;&lt;左移, &gt;&gt;右移）并没画出来。这里主要是想表达各个接收状态，和forward指针回退的操作。</p>
<h3 id="id（标识符）和关键字的状态转换图"><a href="#id（标识符）和关键字的状态转换图" class="headerlink" title="id（标识符）和关键字的状态转换图"></a>id（标识符）和关键字的状态转换图</h3><table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>letter</strong></td>
<td style="text-align:left">[A-Za-z]</td>
</tr>
<tr>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">letter(letter , digit)*</td>
</tr>
</tbody>
</table>
<p>注：上表中的正则表达式将逗号“,”更改为”|”。<br>对于关键字来说，它们看起来和标识符是很像的。但它们并不是标识符。</p>
<p><img src="/uploads/compiler_stateGraph_kmp/3.png" alt=""></p>
<p>对于关键字<code>if/else/for</code>等等关键字，标识符<code>forearm</code>同样也是满足上诉转换图的。</p>
<p>为了解决上诉问题，编译原理中的处理方案有两个：</p>
<ul>
<li>（1）👏👏👏、初始化时就将各个保留字填入符号表中；<br>符号表的某个字段会指明这些串并不是普通的标识符，并指出其对应的词法单元。<br>当我们找到一个标识符时，如果该标识符尚未出现在符号表中，就会调用上图中出现的<code>installID</code>将此标识符放入符号表中，并返回一个指针（该指针指向词素对应的符号表条目）。</li>
</ul>
<blockquote>
<p><strong>任何在词法分析时不在符号表中的标识符都不可能是一个保留字，因此它的词法单元是id</strong></p>
</blockquote>
<ul>
<li>（2）、为每一个关键字建立单独的状态转换图；</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/1.png" alt=""></p>
<p>对于这个状态图来说，我们必须要区分以<code>else</code>为前缀的标识符（比如elseid），因此我们在倒数第二个状态后的边，必须要限制为非字符和数字。</p>
<p>使用第二个方案时：<strong>必须要设定词法单元的优先级，使得当一个词素同时匹配id和保留字模式时，优先识别保留字词法单元</strong>。</p>
<p>我们从第一点可以确定标识符加入符号表的时机是：</p>
<blockquote>
<p>识别到对应词法单元时，如果该标识符尚未加入符号表。此时词法分析器会将该 <strong>标识符</strong> (也可以理解为词素) 放入符号表中。</p>
</blockquote>
<h3 id="词法单元number状态转换图"><a href="#词法单元number状态转换图" class="headerlink" title="词法单元number状态转换图"></a>词法单元number状态转换图</h3><table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>digit</strong></td>
<td style="text-align:left">[0-9]</td>
</tr>
<tr>
<td style="text-align:left"><strong>digits</strong></td>
<td style="text-align:left">digit+</td>
</tr>
<tr>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">digits(.digits)?(E[+-]?digits)?</td>
</tr>
</tbody>
</table>
<p>下图是一个识别整数和浮点数的状态转换图：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/4.png" alt=""></p>
<p>从上图中我们可以看到，接收状态22既匹配到了科学计数法表示的浮点数（包含小数部分，也包含指数部分），也匹配到了科学计数法表示的整数。<br>接收状态23是匹配到的整数词素；接收状态24为不带科学计数法的的整数。</p>
<p>当我们在接收状态时，返回词法单元 <strong>number</strong> 以及一个指向 <strong>常量表</strong> 条目的指针，上面找到的词素就放在这个常量表条目中。</p>
<h3 id="ws（空白符）状态转换图"><a href="#ws（空白符）状态转换图" class="headerlink" title="ws（空白符）状态转换图"></a>ws（空白符）状态转换图</h3><table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>ws</strong>(空白符)</td>
<td style="text-align:left">(blank \</td>
<td>tab \</td>
<td>newline)+</td>
</tr>
</tbody>
</table>
<p>我们用转换delim替换上表中的blank、tab、newline：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/5.png" alt=""></p>
<p>空白符后面需要跟一个非空白符才能确定当前已经完成了对连续空白符的扫描。</p>
<blockquote>
<p>当我们识别到空白符之后，但我们 <strong>并不向语法分析器返回任何词法单元。相反，我们必须在这个空白符之后再次启动词法分析过程</strong> 。</p>
</blockquote>
<h3 id="基于状态转换图的的词法分析器体系结构"><a href="#基于状态转换图的的词法分析器体系结构" class="headerlink" title="基于状态转换图的的词法分析器体系结构"></a>基于状态转换图的的词法分析器体系结构</h3><ul>
<li>1、使用一个state变量来保存一个状态转换图的当前状态编号（就是前面我们从0到27的编号）。</li>
<li>2、用switch语句根据state的值将我们转到对应状态相应的代码段，该代码段为对应状态所需要执行的动作；</li>
</ul>
<h2 id="二、KMP算法"><a href="#二、KMP算法" class="headerlink" title="二、KMP算法"></a>二、KMP算法</h2><p>现在我们看一下KMP算法，它可以用于在文本串中识别一组关键字。在看KMP字符串匹配算法之前，我们先看一下朴素字符串匹配算法。</p>
<h3 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h3><p>朴素字符串匹配算法是同一个循环找到所有有效偏移，寻找满足条件的情况。</p>
<p><img src="/uploads/compiler_stateGraph_kmp/6.png" alt=""></p>
<p>朴素字符串匹配算法可以形象地看成是待匹配串（子串）沿着原文本（主串）滑动，同时对每个偏移都要检测子串上的字符是否与主串中对应字符相等。其中红色字符表示对应位置匹配成功，灰色字符表示匹配失败。<br>大致的代码是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">using namespace std;</div><div class="line">int naive_string_matcher(string text, string pattern)</div><div class="line">&#123;</div><div class="line">     string::size_type n = text.size();</div><div class="line">     string::size_type m = pattern.size();</div><div class="line">     string::size_type total = n-m;</div><div class="line">     string::size_type s = -1;</div><div class="line">     for (string::size_type i = 0; i &lt; total; i++)</div><div class="line">     &#123;</div><div class="line">         s = i;</div><div class="line">         string::size_type matched = 0;</div><div class="line">         for(string::size_type idx = 0; idx &lt; m; idx++)</div><div class="line">         &#123;</div><div class="line">             if(pattern[idx] == text[s+idx]) matched++;</div><div class="line">         &#125;</div><div class="line">         if (matched == m) return s;</div><div class="line">     &#125;</div><div class="line">     return s;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在最坏情况下，朴素字符串匹配算法的平均时间复杂度为O(n<sup>2</sup>) 。</p>
<h3 id="失效函数"><a href="#失效函数" class="headerlink" title="失效函数"></a>失效函数</h3><p>KMP算法在最坏情况下也会比朴素字符串匹配算法好很多。为了快速处理文本串并在这些串中搜索一个关键字，定义了 <strong>失效函数</strong> f(s) ，其中s为对应状态图上的各个状态。也可以叫做辅助函数。<br>在这之前我们先看看串的一部分术语：</p>
<ul>
<li><strong>前缀</strong>：从串s尾部删除0个或多个符号后得到的串；</li>
<li><strong>后缀</strong>：从串s开始处删除0个或多个符号后得到的串；</li>
<li><strong>子串</strong>：删除某个前缀或者后缀之后得到的串；</li>
<li><strong>真前缀、真后缀、真子串</strong>：指的是既不包含空串，也不包含本身的前缀、后缀、子串；</li>
</ul>
<p>针对关键字b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>…b<sub>n</sub>，其目标是使得b<sub>1</sub>b<sub>2</sub>…b<sub>f(s)</sub>不仅是b<sub>1</sub>…b<sub>s</sub>的真前缀，又是b<sub>1</sub>…b<sub>s</sub>后缀的子串。并且b<sub>1</sub>b<sub>2</sub>…b<sub>f(s)</sub>是所求得的最长串。下面我们以串<code>ababaca</code>来进行讲解：</p>
<h5 id="a、构造关键字状态转换图"><a href="#a、构造关键字状态转换图" class="headerlink" title="a、构造关键字状态转换图"></a>a、构造关键字状态转换图</h5><p>我们根据前面的知识，节点表示状态，有向边指的是转换</p>
<p><img src="/uploads/compiler_stateGraph_kmp/7.png" alt=""></p>
<p>现在有了状态转换图，我们需要构造每一个状态节点s，所对应的失效函数值。</p>
<h5 id="b、求解每一个状态s的函数值"><a href="#b、求解每一个状态s的函数值" class="headerlink" title="b、求解每一个状态s的函数值"></a>b、求解每一个状态s的函数值</h5><ul>
<li>1）、由于前面提到过真前缀的前提，因此我们从s=1开始计算。首先我们将f(1)设置为0，既状态1对应的失效函数值为0。并且这里我们新增一个辅助游标t用于对照状态s：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/8.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">s</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<ul>
<li>2）、此时我们比较一下状态t的转换（a）和状态s的转换（b），发现字符a并不等于字符b。此时我们将f(s+1)，即f(2)的值设置为0：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">s</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<p>并且将s移动到状态2：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/9.png" alt=""></p>
<ul>
<li>3）、继续比较状态t的转换（a）和状态s的转换（a）此时他们相等。因此 <strong>先将t的自增1，然后将f(s+1)，即f(2)的值设置为t的值（此时为1）</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">s</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<p>同样的，此时将s移动到状态3：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/10.png" alt=""></p>
<ul>
<li>4）、依次比较后续的s=3，和s=4的情况。它们的情形和第三步类似：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">s</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<p>此时t=3，s=5。对应的状态转换图为：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/11.png" alt=""></p>
<ul>
<li>5）、现在我们比较一下状态t的转换（b）和状态s的转换（c），它们并不相等。由于 <strong>此时t不为0，说明在此之前肯定是存在某一串既为真前缀，又为后缀子串</strong> 。因此我们获取t当前位置对应失效函数函数的值。<br>此时t=3，查上表可知f(3)=1。所以现在我们将t移动到状态1：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/12.png" alt=""></p>
<ul>
<li>6）、同样的比较状态t的转换（b）和状态s的转换（c），依然不相等。<br>由于t不等于0，此时t=1，查第4步的表可知f(1)=0。所以我们现在将t移动到状态0：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/13.png" alt=""></p>
<ul>
<li>7）、对于后续状态的失效函数值确定，可以仿照第2、3和5步进行求解。最终完整失效函数为：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">s</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>下面是对应的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">void trie_func(string pattern, vector&lt;int&gt; &amp;f) &#123;</div><div class="line">	const string::size_type length = pattern.size()+1;</div><div class="line">	int t = 0;</div><div class="line">	f[0]=t;// f[0] store t</div><div class="line">	f[1]=0;</div><div class="line">	for(int s = 1; s&lt; length-1; s++)	</div><div class="line">	&#123;</div><div class="line">		while(t&gt;0 &amp;&amp; pattern[t] != pattern[s])&#123; t=f[t]; f[0]=t;  &#125;	</div><div class="line">		if(pattern[s]==pattern[t])&#123; t=t+1; f[s+1]=t; f[0]=t; &#125;</div><div class="line">		else &#123;f[s+1]=0;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[])&#123;</div><div class="line">	string pattern(&quot;ababaca&quot;);</div><div class="line">	vector &lt;int&gt; trie(pattern.size()+1);</div><div class="line">	trie_func(pattern,trie);</div><div class="line">	for (vector&lt;int&gt;::iterator itr = trie.begin(); itr != trie.end(); itr++) &#123;</div><div class="line">		cout&lt;&lt;*itr&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子串与主串的比较"><a href="#子串与主串的比较" class="headerlink" title="子串与主串的比较"></a>子串与主串的比较</h3><p>现在我们以主串<code>bcbababaababacacd</code> 和子串 <code>ababaca</code> 作为例子，来看主串是否包含子串。</p>
<p><img src="/uploads/compiler_stateGraph_kmp/14.png" alt=""></p>
<p>我们从前面知道子串失效函数为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">state</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
<th style="text-align:left">4</th>
<th style="text-align:left">5</th>
<th style="text-align:left">6</th>
<th style="text-align:left">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">f(s)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>这里我将上一节的字符s替换为state，是因为这一节我会用字符s用作当前子串相对于主串的偏移量。而真正原因是我太懒了，发现图中和失效函数都用了同一个字符s。为了避免混淆，但又不想重新画图🤣。</p>
<ul>
<li>1）、主串的第一个字符和子串的第一个字符不相等。此时我们将子串向右滑动一位，此时偏移值<code>s = 1</code> ：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/15.png" alt=""></p>
<ul>
<li>2）、依次对后面机会字符进行对比，直到<code>s=3</code>时，我们发现字符串 <code>ababa</code> 成功匹配，但是子串的第六个字符和主串的第九个字符并不相等：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/16.png" alt=""></p>
<p>这时候失效函数就派上用途了。此时已匹配长度<code>q=5</code>，也就是说在状态转换图中对应于状态5。而状态5对应的失效函数值为3，对于串<code>ababa</code>来说，长度为3的串<code>aba</code>既是它的真前缀，又是它后缀的子串。此时主串和子串中的<code>aba</code>已经失效，已经没有再去比较的意义了，我们可以直接去比较主串中的a和子串中的b了：</p>
<p><img src="/uploads/compiler_stateGraph_kmp/17.png" alt=""></p>
<ul>
<li>3）、现在我们将子串向右边移动2个字符，然后继续进行比较：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/18.png" alt=""></p>
<p>这里计算偏移量s很重要：</p>
<blockquote>
<p>⚠️⚠️⚠️ <strong><code>s = s + (state - f(state))</code></strong></p>
</blockquote>
<p>比如这里的q=5，也就说明state=5，而f(state) = 3。因此向右的偏移量为：s = 3 + (5-3) = 5。</p>
<ul>
<li>4）从图中标红也能看出来a≠b，因此我们需要继续重复步骤3的事情：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/19.png" alt=""></p>
<ul>
<li>5）、如上图所示，我们继续将子串向右移动2个字符，进行比较：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/20.png" alt=""></p>
<p>相等。但这里有一个需要注意的点是：此时state为1，而f(state)=0。这意味着此时并没有存在即是真前缀又是后缀的子串。<br>现在只能和第一步一样，手动将偏移量加1。</p>
<ul>
<li>6）、现在将偏移量加1之后，并将子串和主串进行匹配。此时匹配成功，因为我们可以判断主串是包含有指定关键字的字符串：</li>
</ul>
<p><img src="/uploads/compiler_stateGraph_kmp/21.png" alt=""><br>下面是简单的代码实现，需要注意的是这里并没有做极端情况的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">int kmp_match(string text, string pattern) &#123;</div><div class="line">	vector&lt;int&gt; trie(pattern.size() + 1);</div><div class="line">	trie_func(pattern, trie);</div><div class="line"></div><div class="line">	int offset = -1;</div><div class="line">	int q = 0;</div><div class="line">	string::size_type m = text.size();</div><div class="line">	string::size_type n = pattern.size();</div><div class="line">	if (m &lt; n)</div><div class="line">	&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (string::size_type i = 0; i &lt; m; i++)</div><div class="line">	&#123;</div><div class="line">		while (q &gt; 0 &amp;&amp; text[i] != pattern[q] &amp;&amp; q != 0)</div><div class="line">		&#123;</div><div class="line">			q = trie[q];</div><div class="line">		&#125;</div><div class="line">		if (text[i] == pattern[q])</div><div class="line">		&#123;</div><div class="line">			q++;</div><div class="line">		&#125;</div><div class="line">		if (q==n)</div><div class="line">		&#123;</div><div class="line">			offset = i - q + 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	string text(&quot;bcbababaababacacd&quot;);</div><div class="line">	string pattern(&quot;ababaca&quot;);</div><div class="line">	int offset = kmp_match(text, pattern);</div><div class="line">	cout &lt;&lt; &quot;offset: &quot; &lt;&lt; offset &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节到这儿，我们已经能够手工地为各类词法单元构造状态转换图了。这类词法单元包括有：标识符（包括字符）、数字（包括数位）、关键字、运算符等等，而且也知道如何使用KMP算法来寻找指定串，例如标识符和关键字等等。<br>在下一节就需要通过自动地方式里生层对应的状态图了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这儿我们先用手工的方式将正则表达式表示的模式转换为状态转换图。在下一节我们会用自动化的方法构造对应的转换图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/compiler_stateGraph_kmp/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;1）、&lt;stron
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="词法分析" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>词法分析——词法单元和正则表达式</title>
    <link href="http://yoursite.com/2019/10/28/compiler_token_regular/"/>
    <id>http://yoursite.com/2019/10/28/compiler_token_regular/</id>
    <published>2019-10-28T03:09:25.132Z</published>
    <updated>2019-10-28T03:51:36.600Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章是《编译原理》的读书笔记，并加入了一些个人的理解。本系列的主要内容顺序如下：<br>1）、首先解释什么是词法单元；<br>2）、如何手动识别词法单元；<br>3）、最后是词法分析器如何自动机自动识别词法单元；<br>本文主要是看一下词分析器的词法单元部分。包括一些基本概念，以及词法单元的识别。</p>
<p>首先我们先大体上看一下词法分析器的作用。它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元的序列。每个词法单元对应一个词素。</p>
<p>这里我们有提到几个专业名词：词素、词法单元。它们的定义马上就会说到，我们可以先看看下面这幅图：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/5156ab1334b7f33858c6233c6a88fcd8.png" alt=""></p>
<p>从图中我们可以看出来词法分析器还在和符号表进行交互，其主要作用是从符号表中读取有关标识符种类信息，以确定需要向语法分析器传送的词法单元。</p>
<h2 id="一、词法单元"><a href="#一、词法单元" class="headerlink" title="一、词法单元"></a>一、词法单元</h2><p>现在我们就先来看看前面提到的一些专业名词：</p>
<ul>
<li><strong>词法单元</strong>：由一个 <strong>词法单元名和一个可选的属性</strong> 构成。<br>比如一个特定的关键字，或者代表一个标识符的输入字符序列。</li>
</ul>
<blockquote>
<p>词法单元是语法分析器处理的输入符号。</p>
</blockquote>
<ul>
<li><p><strong>词素</strong>：源程序中的一个字符序列，它和某个词法单元的模式匹配。它被词法分析器识别为该词法单元的一个实例；</p>
</li>
<li><p><strong>模式</strong>：它描述了一个词法单元的词素可能具有的形式；</p>
</li>
</ul>
<p>这儿我大致地解释一下这三个概念之间的关系：词法单元指定的是某一类型的事物，用面向对象来说就是，词法单元类（class）；词素就是指的是该类的具体实例；而模式就是该类的一个属性，它描述了词素所具有的具体特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Tokens&#123;</div><div class="line">  string pattern;</div><div class="line">&#125;;</div><div class="line">Tokens lexeme;</div></pre></td></tr></table></figure>
<p>并不是说实际就是这个代码，我只是为了便于理解，而进行的类比。下表给出了一些常见的词法单元：</p>
<table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">非正式描述</th>
<th style="text-align:left">词素实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>if(关键字)</strong></td>
<td style="text-align:left">字符i,f</td>
<td style="text-align:left">if</td>
</tr>
<tr>
<td style="text-align:left"><strong>else(关键字)</strong></td>
<td style="text-align:left">字符e,l,s,e</td>
<td style="text-align:left">else</td>
</tr>
<tr>
<td style="text-align:left"><strong>comparison(比较运算符)</strong></td>
<td style="text-align:left">&lt;,&gt;,&lt;=,&gt;=,==…</td>
<td style="text-align:left">&lt;=, !=</td>
</tr>
<tr>
<td style="text-align:left"><strong>id(标识符)</strong></td>
<td style="text-align:left">字母开头的字母/数字串</td>
<td style="text-align:left">pi, printf</td>
</tr>
<tr>
<td style="text-align:left"><strong>number(数字)</strong></td>
<td style="text-align:left">数字常量</td>
<td style="text-align:left">3.1415</td>
</tr>
<tr>
<td style="text-align:left"><strong>literal(字符/串)</strong></td>
<td style="text-align:left">两双引号之间的任何字符</td>
<td style="text-align:left">“hello, world”</td>
</tr>
</tbody>
</table>
<h4 id="词法单元的大致分类"><a href="#词法单元的大致分类" class="headerlink" title="词法单元的大致分类"></a>词法单元的大致分类</h4><p>1）、<strong>关键字</strong>：每个关键字有一个词法单元；<br>2）、<strong>标识符</strong>：一个表示所有标识符的词法单元；<br>3）、<strong>常量</strong>：常量词法单元包含的数字和字符串；<br>4）、<strong>运算符</strong>：运算法也是一个词法单元，可以是比较运算符，也可以是算术运算符；<br>5）、<strong>标点符号</strong>：每一个标点符号有一个词法单元。比如括号等等；</p>
<h4 id="词法单元的属性值"><a href="#词法单元的属性值" class="headerlink" title="词法单元的属性值"></a>词法单元的属性值</h4><p>从这里我们可以看出来词法单元表示了一类事物，但是我们如何去区分具体的词素？ <strong>词法分析器不仅向语法分析器返回一个词法单元的名字，还会返回一个描述该词法单元的词素属性值</strong>。</p>
<p>比如我们声明的一个变量、或者函数时，它作为标识符一类的词法单元。它们更加详细的信息（词素、类型、第一次在源代码中出现的位置）都会保存在符号表中。<br>因此：</p>
<blockquote>
<p><strong>一个标识符的属性值是一个指向符号表中该标识符对应项的指针</strong>。</p>
</blockquote>
<p>注意，词法单元的属性值是指向符号表项的指针。</p>
<h2 id="二、正则表达式"><a href="#二、正则表达式" class="headerlink" title="二、正则表达式"></a>二、正则表达式</h2><p>这一节主要是在讲正则表达式，如果已经熟悉了正则表达式，可以直接跳过阅读词法单元的识别。而且这一节会增加很多概念，也是比较枯燥的。<br>从前面我们可以感性（直观）知道哪些词素是某一类型的词法单元。为了能够明确地划分不同词素对应的词法单元，我们需要引入正则表达式。<br>正则表达式是一种用来描述词素模式的重要表示方法。因此正则表达式就描述了特定词素对应的模式。</p>
<p>在词法分析中，最重要的语言上的运算是：<strong>并、连接和闭包</strong> 运算：</p>
<ul>
<li>并（L|M）：得到的串s可能属于L也可能属于M。但只能是其中之一；</li>
<li>连接(LM)：得到的串s即属于L，也属于M；</li>
<li>闭包：闭包分Kleene闭包和正闭包。Kleene闭包是指某一集合的符号重复 0～∞ 多次，可能是空串。正必报不包含重复0次，即不包含空串；</li>
</ul>
<p><code>letter_ (letter_ | digit_) *</code>这是一个c语言中标识符的正则表达式。其中用letter<em>来表示任一字母或者下划线，用digit</em>表示数位。c语言中标识符必须是必须是以字符开头，包含数字、字符来表示。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>正则表达式中，括号的优先级最高，优先级依次降低：<br>1）、一元运算符 <code>*</code>；<br>2）、连接（左结合）；<br>3）、并运算符优先级最低（左结合）；</p>
<p>比如正则表达式 <code>(a|b)*</code>，可以表示多个串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">空集;//闭包次数为0;　</div><div class="line">a;//闭包次数为1,取并的左边;</div><div class="line">aa;//闭包次数为2,一直取并的左边;</div><div class="line">aa...a;//闭包次数为n,一直取并的左边;</div><div class="line">b;//闭包次数为1,取并的右边;</div><div class="line">bb;//闭包次数为2,取并的右边;</div><div class="line">bb...b;//闭包次数为n,取并的右边;</div><div class="line">ab;//闭包次数为2,先取左边再取右边;</div><div class="line">ba;//闭包次数为2,先取右边再取左边;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如上, 可以用一个正则表达式定义的语言叫做<strong>正则集合</strong>。如果两个正则表达式r和s表示相同的语言，则称 r 和 s 等价<code>r=s</code> 。</p>
<h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p>c语言中的标识符是由字母、数字和下划线组成的串，下面是c标识符对应语言的正则定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">letter_ -&gt; A | B | C | ... | Z | a | b | c | ... | z | _ </div><div class="line">digit  -&gt; 0 | 1 | ... | 9 </div><div class="line">id -&gt; letter_ (letter_ | digit  ) *</div></pre></td></tr></table></figure>
<h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p>无符号数是形如5280、0.01234、6.336E4或者1.89E-4的串。下面的正则定义给出了这类符号串的精确定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">digit -&gt; 0 | 1 | ...| 9</div><div class="line">digits -&gt; digit  digit* </div><div class="line">optionalFraction -&gt; . digits | 空集</div><div class="line">optionalExponent -&gt; (E (+|-|空) digits) | 空</div><div class="line">number -&gt; digits optionalFraction optionalExponent</div></pre></td></tr></table></figure>
<h4 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h4><ul>
<li><strong>单目后缀运算符+</strong>：指的正闭包；</li>
<li><strong>单目后缀运算符?</strong>：表示出现0个，或者一个；</li>
<li><strong>字符类</strong>：正则表达式a<sub>1</sub> | a<sub>2</sub> | a<sub>3</sub> |…|a<sub>n</sub>可以缩写为 <strong>[a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>]</strong>。当a1到an形成一个逻辑上连续的序列时，可以写作 <strong>[a1 - a<sub>n</sub>]</strong>;</li>
</ul>
<h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p>我们可以使用正则表达式的扩展，来把例一的正则表达式进行改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">letter_ -&gt; [A-Za-z_]</div><div class="line">digit  -&gt; [0-9]</div><div class="line">id -&gt; letter_ (letter_ | digit  ) *</div></pre></td></tr></table></figure>
<p>现在通过正则表达式，我们可以写出对应词法单元对应的模式来。因此下一步要做的就是读取源代码里面的字符流，搭配对应的词法单元的模式，生成对应的词法单元。</p>
<h2 id="三、输入缓冲"><a href="#三、输入缓冲" class="headerlink" title="三、输入缓冲"></a>三、输入缓冲</h2><p>很多情况下，我们需要至少向前看一个字符。比如在c语言中，像-、=或者&lt; 这样单字符运算符也有可能是 -&gt; 、== 或者&lt;= 这样的双字符。<br>在编译原理中会引入一个哨兵标记的双缓冲区方案来处理向前看运算符的问题。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/1d850c00280d8de9ea211898983c3e50.png" alt=""><br>上图中出现的lexemeBegin和forward指针作用分别是：<br>1）、<code>lexemeBegin</code>：该指针指向当前词素的开始处。当前我们正在匹配某一正则表达式对应模式的词素；<br>2）、<code>forward</code>：该指针一直向前扫描，直到发现某个模式被匹配为止。</p>
<ul>
<li><p>第一步、读取内容到缓冲区中：每次读取缓冲区长度的字符到缓冲区中；<br>每个输入缓冲区的容量通常是一个磁盘块的大小，比如4096字节。我们在读取的时候就是一次性读取一个缓冲区长度的字符到缓冲区中，以避免频繁的使用读取函数。<br>当输入文件中的剩余字符不足缓冲区长度的时候，文件的默认会有一个eof（end of file）来表示文件结束。</p>
</li>
<li><p>第二步、lexemeBegin和forward指针的移动：使用lexemeBegin指针和forward指针读取指定模式的词素。<br>一旦确定了下一个词素（下图中的左括号）forward指针将指向该词素 <strong>结尾的字符</strong> 。词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来（在前面我们提过的词法单元分为词法单元名和可选的属性）。<br>然后lexemeBegin指针移动到 <strong>刚刚找到词素之后的第一个字符</strong> 。如下图所示：</p>
</li>
</ul>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/f38cb361abc1acc4d90fe24357c9d88e.png" alt=""></p>
<ul>
<li>第三步、缓冲区的替换：我们在移动forward指针前需要判断当前是否已经到达某个缓冲区的末尾。<br>如果是，我们需要将新字符读入到另外一个缓冲区中（前面提到的双缓冲区），且将forward指针指向新缓冲区的头部。</li>
</ul>
<h4 id="哨兵标记"><a href="#哨兵标记" class="headerlink" title="哨兵标记"></a>哨兵标记</h4><p>如前面所说，我们在每次移动forward指针时，我们都需要检查是否到达了缓冲区的末尾。如果是的话，我们就需要加载另一个缓冲区。因此在这里我们需要做两次测试：<br>1）、检查是否到达缓冲区的末尾；<br>2）、确定读入的字符是什么；<br>解决这两个问题，我们可以在缓冲区的末尾增加一个“哨兵”，比如<code>eof</code>：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/632ec991b874e291d70cecf5039ebc90.png" alt=""></p>
<p>从这儿我们可以知道，对于编译器而言在进行词法分析的时候，需要通过lexemeBegin和forward来扫描缓冲区。如果匹配某一个词素时，比如很长的字符串（比如将一片短篇小说作为常量字符串放到一个变量中）时，那就会出现缓冲区长度不足的情况，因此在日常编码中将长字符串拆分成多个短的字符串。</p>
<p>这其实也算是学习编译原理，有助于提供编程效率的一个例子了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前面我们用正则表达式来表示一个模式，现在我们需要通过制定模式来识别对应的词法单元。下面是大部分词法单元，以及对应的模式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>digit</strong></td>
<td style="text-align:left">[0-9]</td>
</tr>
<tr>
<td style="text-align:left"><strong>digits</strong></td>
<td style="text-align:left">digit+</td>
</tr>
<tr>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">digits(.digits)?(E[+-]?digits)?</td>
</tr>
<tr>
<td style="text-align:left"><strong>letter</strong></td>
<td style="text-align:left">[A-Za-z]</td>
</tr>
<tr>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">letter(letter,digit)*</td>
</tr>
<tr>
<td style="text-align:left"><strong>if</strong></td>
<td style="text-align:left">if</td>
</tr>
<tr>
<td style="text-align:left"><strong>then</strong></td>
<td style="text-align:left">then</td>
</tr>
<tr>
<td style="text-align:left"><strong>else</strong></td>
<td style="text-align:left">else</td>
</tr>
<tr>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">&lt;,&gt;,&lt;=,&gt;=,==,!=</td>
</tr>
<tr>
<td style="text-align:left"><strong>ws</strong>(空白符)</td>
<td style="text-align:left">(blank,tab,newline)+</td>
</tr>
</tbody>
</table>
<p>由于这块儿markdown解析的问题（加了转义字符之后依然显示有点问题），我将”|”替换为”,”。在理解的时候只需要将”,”更改为”|”即可。</p>
<p>上表中的词法单元<code>ws</code>和其他词法单元不同。当我们识别到ws时，</p>
<blockquote>
<p><strong>我们并不将它返回给语法分析器，而是从这个空白符之后的字符开始继续进行词法分析。返回给语法分析器的是下一个词法单元</strong> 。</p>
</blockquote>
<p>我们从前面的知识了解到，词法分析器通过对应模式识别到词法单元之后，会将词法单元名返回给语法分析器（空白符除外），以及对应词法单元的属性来确定某一特定实例。下表展示了对应词法单元，和对应属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">词素</th>
<th style="text-align:left">词法单元名字</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">任何空白符</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left"><strong>if</strong></td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">else</td>
<td style="text-align:left"><strong>else</strong></td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">指向符号表条目的指针</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">指向符号表条目的指针</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">LT</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">GT</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left"><strong>…</strong></td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">NE</td>
</tr>
</tbody>
</table>
<p>表格里面的relop词法单元，区分其具体实例是通过对应词法单元属性值进行。</p>
<p>这一节主要是了解了词法单元相关知识其中，包括有词法单元、词素和模式。为了能够了解模式，我们又学习了一下正则表达式。下一节则主要是讲解词法单元的识别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章是《编译原理》的读书笔记，并加入了一些个人的理解。本系列的主要内容顺序如下：&lt;br&gt;1）、首先解释什么是词法单元；&lt;br&gt;2）、如何手动识别词法单元；&lt;br&gt;3）、最后是词法分析器如何自动机自动识别词法单元；&lt;br&gt;本文主要是看一下词分析器的词法单元部分。包括一些
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="词法分析" scheme="http://yoursite.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>A Malloc Tutorial</title>
    <link href="http://yoursite.com/2019/02/17/a_malloc_tutorial/"/>
    <id>http://yoursite.com/2019/02/17/a_malloc_tutorial/</id>
    <published>2019-02-17T14:01:30.825Z</published>
    <updated>2019-10-28T04:11:15.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章是对<a href="https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc_tutorial.pdf" target="_blank" rel="external">该文章</a>的翻译，如有疑问可对照原文。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>什么是malloc？如果连这个名儿都没有听说的话，那么应该在读这篇文章之前先去学习一下Unix环境下的C语言。对于程序员来说，malloc是在C语言编程中分配一块内存的函数，然后大多数人并不知道其背后的真实情况，或者仅仅是认为这是一个syscall或者语言关键字。这篇文章中只需要一些C的技能和一些系统知识，就能了解到malloc也只不过是一个简单的函数而已。<br>本文的主要目的是编写一个简单的malloc函数，来帮助我们了解底层概念。其目的并不是为了实现一个高效的malloc，仅仅提供基础功能。但是背后的概念能够帮助我们有效地去理解进程中内存是如何管理的，以及如何处理块的分配，再分配以及释放等等。<br>站在教学的角度来说，这是一个很好的C语言编程练习。同样也是一个很好文档，它能够帮助我们理解指针怎么来的，它们在堆里面是怎样组织起来的。</p>
<h4 id="malloc是什么"><a href="#malloc是什么" class="headerlink" title="malloc是什么"></a>malloc是什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"> void *malloc(size_t size);</div></pre></td></tr></table></figure>
<p>malloc是一个标准C库函数，用于分配内存块。它遵循以下规则：</p>
<ul>
<li>malloc至少要分配请求字节大小（size）内存；</li>
<li>malloc的返回的指针，指向一个已分配的内存（比如一个在编程时可读或者可写的空间）；</li>
<li>在该指针没有被释放之前，其他任何的malloc调用都不会分配该空间或者该空间中的任何一部分；</li>
<li>malloc应该能很好处理，而且能够很快执行结束；</li>
<li>malloc需要提供重新设置大小或者释放的能力；</li>
</ul>
<p>malloc函数返回的指针在失败或者没有可用内存空间的情况下为NULL。</p>
<h2 id="二、堆和brk、sbrk系统调用"><a href="#二、堆和brk、sbrk系统调用" class="headerlink" title="二、堆和brk、sbrk系统调用"></a>二、堆和brk、sbrk系统调用</h2><p>在编写malloc之前，我们需要理解内存在多任务系统中是如何管理的。由于具体实现依赖于操作系统的实现细节，下面提到的内容更多是基于抽象的概念来进行阐述。</p>
<h3 id="进程的内存"><a href="#进程的内存" class="headerlink" title="进程的内存"></a>进程的内存</h3><p>每个进程都有它自己的虚拟地址空间，由MMU（内核）提供从虚拟地址空间到物理地址空间的转换。而该空间被分为多个部分，比如用户存储局部变量和volatile变量的栈，还有存储常量和全局变量的空间，以及用于存储程序数据，称为堆的散乱空间。</p>
<p>就虚拟地址而言，堆是一个连续的内存空间，它有三个划分的边界：起始点、最大值和称一个为<code>break</code>的终点。<br>最大值的管理可以调用<sys resource.h="">(原文中写成了sys/ressource.h)里面的<code>setrlimit</code>和<code>getrlimit</code>。break用于标记已映射内存空间的尾部，已映射内存空间指的是已经和实际内存一一对应起来的那部分虚拟地址空间（我的理解也就是对应的PTE里面有效位应该是为1，更或者TLB有对应的缓存的Page）。下图展示了内存组织的形式：</sys></p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/e913ee43a503e7e74a8b0cb0b6dacd19.png" alt="图一"></p>
<p>为了能够编写malloc函数，我们需要知道堆（heap）的开始位置和break的位置。当然我们还需要有能力去移动break，可以使用<code>brk</code>和<code>sbrk</code>系统调用来实现。</p>
<h3 id="brk和sbrk"><a href="#brk和sbrk" class="headerlink" title="brk和sbrk"></a>brk和sbrk</h3><p>我们可以在他们的手册（比如<code>man brk</code>）里面找到关于这些系统调用的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int brk(const void *addr);</div><div class="line">void *sbrk(int incr);</div></pre></td></tr></table></figure>
<p>brk函数通过传入的 <strong>addr</strong> 来设置brak的值，成功返回0，失败返回-1。使用全局<code>errno</code>来指明错误的原因（错误码对应的错误信息可以在\<sys errno.h\="">中查看）；</sys></p>
<p>而sbrk通过传入的增量（以字节为单位）来移动break的位置。基于不同系统的实现，其返回值可能会返回老的地址，也可能返回移动之后新的地址。<br>如果函数调用失败则返回-1，并且设置errno的值。在有些系统上sbrk支持传入一个负数用于释放那些已被映射的地址空间。</p>
<p>由于sbrk没有规范其返回值的意义，因此我们在 <strong>移动break的时候</strong> 不会去使用它返回值。但是我们可以使用特定情况下的sbrk，当调用sbrk其增量为0时，它的返回值就是实际的break地址（也就是老的地址和新的地址是同一个值）。因此sbrk用于获取堆的开始位置，也就是break的初始位置（上图中mapped Region长度为0的时候，也就是break的初始位置）。</p>
<p>因此我们将使用sbrk作为我们主要的工具。而我们的目的是在需要更多空间的情况下，我们要做的就是获取更多的资源来满足需求。</p>
<h3 id="未映射区域和无人区（No-Man’s-Land）"><a href="#未映射区域和无人区（No-Man’s-Land）" class="headerlink" title="未映射区域和无人区（No-Man’s Land）"></a>未映射区域和无人区（No-Man’s Land）</h3><p>我们看一下早期break标记已映射虚拟地址空间结束点的原理：在访问break之前的区域时会触发一个总线错误。在break点和最大限制（rlimit）之间的空间，系统（MMU和内核部分）是没有将物理内存和虚拟内存关联起来的。<br>如果知道一点关于虚拟内存的知识的话，应该清楚内存是通过页的方式来进行管理：物理内存和虚拟内存通常情况下以固定大小的页面进行组织，而页的大小在实际系统中通常为4096Byte（4KB）。因此break点可能并不是在整页的边界上。<br>说点题外话，在《现代操作系统》中介绍缺页处理程序是通过懒加载的方式来将物理内存和虚拟内存联系起来的。不考虑TLB的情况下，MMU是将VPN和PPN通过PTE来进行映射的</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/a4d659e75bd3db110cebfd1785fd6b3b.png" alt="图二"></p>
<p>图二相比于图一，我们增加了页面边界的表示。可以看到break并没有和页边界吻合对应起来。那么处于break和下一页边界之间的内存是什么状态呢？实际上，这一段空间是可用的，我们可以对这段空间进行读写操作。但问题在于我们没有办法知道下一页边界的任何头绪，它的实现是非常依赖于特定系统的，所以对于可移植性来说，不建议这么去做。</p>
<p>无人区（no-man’s land）可能是大部分BUG的根源：在堆外面进行错误地指针操作时，对于小规模测试大部分时间是可以成功的，但是在更大量数据的时候该操作就会出现失败。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>尽管在这个教程中我们并不会使用它，但是我们应该要注意到<code>mmap</code>系统调用。mmap大部分情况用于将文件和内存映射起来，但是它可以以匿名模式来实现malloc（在某些特定情况下）。<br>匿名模式下的mmap可以分配指定数量的内存（以页面大小为单位），<code>munmap</code>可以释放掉它们。使用这种方式实现的malloc相较于传统基于sbrk实现的malloc通过更加简单。 <strong>有些malloc使用mmap来实现大内存的分配</strong>（超过一页的大小）。<br>OpenBSD的做法是使用mmap并搭配一些奇技淫巧来增加安全性（页与页之间在分配的时候增加边框来进行分配。这里翻译不太顺，加边框的意思是在页的边界处使用额外的空间来达到整页使用的效果，想象卷积的时候增加padding来读取矩阵左上角的数据。如果翻译有问题请联系我）。</p>
<h2 id="三、Dummy-malloc"><a href="#三、Dummy-malloc" class="headerlink" title="三、Dummy malloc"></a>三、Dummy malloc</h2><p>首先，我们会使用sbrk来假设一个malloc。这个版本的malloc可能是最差的一个，甚至是最简单的一个。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>思想很简单，每次在调用malloc的时候，我们根据请求的空间大小来移动break，并且返回break之前的地址。这样做的确够简单，也够快。。。它仅仅只需要三行代码。但是这样的话我们没法去实现一个真实的free，当然realloc同样也不行。</p>
<p>这个版本的malloc会浪费很大一部分用过的内存块儿。在这儿只是出于科普的目的来指出如何sbrk系统调用，同样还将为malloc添加一些错误管理。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void *malloc(size_t size)&#123;</div><div class="line">    void *p;</div><div class="line">    p = sbrk(0);</div><div class="line">    /// 如果sbrk失败，返回NULL</div><div class="line">    if (-1 == sbrk(size)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、组织堆（Organizing-the-Heap）"><a href="#四、组织堆（Organizing-the-Heap）" class="headerlink" title="四、组织堆（Organizing the Heap）"></a>四、组织堆（Organizing the Heap）</h2><p>在上一节我们写了第一个版本的malloc函数，但是并没有满足我们所有的需求（前面提到的free和realloc）。在这一节我们会尝试找到一个高效组织heap的方案，其中包括了malloc、free和realloc。</p>
<h3 id="我们需要什么"><a href="#我们需要什么" class="headerlink" title="我们需要什么"></a>我们需要什么</h3><p>如果我们在编程上下文之外思考问题，能推断出在解决这个问题的时候我们需要哪些信息吗？来看个比喻：你拥有一片农场，并将他们划分成很多块农田区域出来。将这些分块的农田出租出去。租户希望租用连续的，但不同长度的农田（这里只使用长度这个维度来划分，不考虑面积）。当租户使用完成之后将其租用农田归还，以便下次继续向外出租。</p>
<p>在农场边提供了用于行驶“可编程”车的道路：输入距离开始点的偏移量和目的地（目的地是一块不是一个点，所以这里表达的是该块的开始点位）。因此我们需要知道每一块的开始点在哪儿，而且当我们处于某一块的起始点的时候，我们还需要知道下一块的地址。</p>
<p>其中一个解决方案是在每一块农田的开头部分放入一个标签来标明下一块的地址（和当前块的大小以避免不必要的计算），当租户将农田资源归还的时候，在空闲区域添加一个标记。<br>好了，现在当租户想要固定大小农田的时候，我们可以带着他行驶在一处一处的标签那儿去。当我们发现一块标记为可用状态的农田，并且足够交付租户需求的时候，我们将该空闲标记从标签中移除。但是如果到达最后一块农田（也就是标签中没有下一个农田的地址），我们只需要到达该区域的末尾并添加一个新的标记。</p>
<p>现在我们将这个比喻转换到内存： <strong>我们需要在每一块开始部分存储额外的信息，包括每一个块的大小、下一个块的地址、以及是否空闲等信息</strong>。</p>
<h3 id="如何表示块信息"><a href="#如何表示块信息" class="headerlink" title="如何表示块信息"></a>如何表示块信息</h3><p>我们需要在每一个大块（chunk）的开始部分包含一小段（block）用于容纳额外信息，这一小段我们成为“meta-data”；该段至少包含了下一块的指针、用于空闲块的标记、以及该块数据大小。当然，该段信息是在mallc函数返回的指针之前。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/4dcc638b63fdb4015bf534fd125b7f67.png" alt="图三"></p>
<p>图三展示了一个堆组织的例子，含有已分配段前面的meta-data。 <strong>每一个大块（chunk）由数据块和meta-data组成</strong>，malloc函数返回的指针在上图下面由红色标记出来，需要注意的是该指针是指向的数据块，并不是完整的大块（chunk，不是指向meta-data的起始点）。<br>现在我们需要怎样来把这些用C代码表示出来呢？这个看起来像传统的链表（实际上就是个链表）。我们编写一个链表类型，该类型成员用来表示所需的信息。我们使用 <strong>typedef</strong>来简化结构类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct s_block* t_block;</div><div class="line">struct s_block &#123;</div><div class="line">    size_t size;</div><div class="line">    t_block next;</div><div class="line">    int free;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这儿看起来使用int型的free标记有点浪费空间，但由于struct默认是内存对齐的，因此它不会改变任何内容，稍后我们会看到如何缩小meta-data的大小。后续我们会看到malloc返回的地址必须是内存对齐的地址。<br>这儿出现最频繁的问题是：我们如何在没有malloc的情况下去创建一个struct？答案很简单，我们只需要知道struct实际上是什么。在内存中，struct只是将一块儿区域结合了起来，所以结构s_block仅仅只是12字节（对于32位整型来说）。size字段对应前面的4字节，接下来的4字节是指向下一个block的next指针，最后4个字节是一个整型的free标记。<br>当编译器遇到访问结构的域时（比如s.free或者p-&gt;free），将其转换为该结构的基地址加上该域之前长度的和。比如：p-&gt;free就是<em>((char </em>)p+8)，s.free就是<em>((char </em>)&amp;s+8)。我们所需要做的就是使用sbrk分配足够的空间块（包含了meta-data的大小和数据块的大小），并将老的break放入t_block类型的变量内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Example of using t_block without malloc */</div><div class="line">t_block b;</div><div class="line">/// 使用b保存老的break</div><div class="line">b = sbrk(0);</div><div class="line">/// 添加所需空间</div><div class="line">/// size变量是malloc函数的参数</div><div class="line">sbrk(sizeof(struct s_block)+size);</div><div class="line">b-&gt;size = size;</div></pre></td></tr></table></figure>
<h2 id="五、首次适配策略的malloc"><a href="#五、首次适配策略的malloc" class="headerlink" title="五、首次适配策略的malloc"></a>五、首次适配策略的malloc</h2><p>“首次适配”是我采用《深入了解计算计算机系统》的翻译词。在这一节我们将会实现经典的首次适配策略的malloc函数。首次适配算法很简单：我们只要找到了一个空间大小足够满足请求分配的时候就停止遍历其他的块（chunk）。</p>
<h3 id="指针对齐"><a href="#指针对齐" class="headerlink" title="指针对齐"></a>指针对齐</h3><p>通常情况需要将指针和整型大小对齐（即 <strong>指针大小就是一个整型的大小</strong>）。此处我们只考虑32位的情况，所以指针是4的倍数（32bit = 4 byte，那当然是4的倍数）。因此我们的meta-data已对齐，我们仅仅需要做的只是去对齐数据块的大小。<br>那我们该怎么做呢？这儿有几种方式，最有效的方式是使用算术技巧添加预处理宏。<br>首先，算术技巧：给定任意正整数除以4，然后再将它乘以4得到最接近4的倍数。因此为了获得最接近且大于它时，只需要乘以4，然后在此基础上加4。这种方式的确很简单，但它没办法很好地工作在本身就是4的倍数上，结果会变成4的倍数的下一个（由于加了4）。<br>再来使用一次算术，假设x是整型，并且满足：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/03047c2295928a22751f7f623df5de81.gif" alt=""></p>
<p>1）、如果x是4的倍数，那么q = 0，并且满足：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b6b9a98c897b1bee7c0be1bfd3a9f296.gif" alt=""></p>
<p>运用上面说的，先除以4，然后乘以4，最后再加上4：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/312850422499afd4c08b0d7612f0cda0.png" alt=""> </p>
<p>在这个推算过程是将上面x-1的表示用p来进行表示。这里需要注意一点的是，在整型除法中3/4结果为0；</p>
<p>2）、如果x不是4的倍数，此时q != 0：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/39336c86a48c286012ed683927a75edb.png" alt=""></p>
<p>同样运用上面的，先除以4，然后乘以4，最后再加上4：  </p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/e34ae3f9de26312a6bb52d04f979aef2.png" alt=""></p>
<p>因此，公式 <strong><em>(x-1)/4 * 4 + 4</em></strong> 的结果是最接近并且大于或者等于4的倍数。</p>
<p>那么我们在C里面该怎么做呢？首先，注意到除法和乘法我们可以使用右移和左移移位操作符来解决（&gt;&gt;和&lt;&lt;），它们相对于简单乘法要快很多。因此我们的公式在C里面可以写成这样 <code>((x-1)&gt;&gt;2)&lt;&lt;2+4</code>，但是在宏里面需要使用额外的括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define align4(x) (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4)</div></pre></td></tr></table></figure>
<h3 id="寻找块：首次适配算法"><a href="#寻找块：首次适配算法" class="headerlink" title="寻找块：首次适配算法"></a>寻找块：首次适配算法</h3><p>找到一个足够长度的块非常简单：从堆的起始点开始（以某种方式会保存在代码，后续会看到）测试当前块，如果该块成功适配则返回该块的头部，否则继续向下一块寻找，直到最后一个块的头部。<br>这里唯一的技巧是需要保存上一次遍历过的块，所以当没有找到合适的块的时候，malloc函数可以很轻松地去扩展堆的尾部（长度）。代码逻辑很直接，<code>base</code>是一个全局指针变量，指向堆的开始位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">t_block find_block(t_block *last, size_t size) &#123;</div><div class="line">    t_block b = base;</div><div class="line">    while (b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) &#123;</div><div class="line">        *last = b;</div><div class="line">        b = b-&gt;next;</div><div class="line">    &#125;</div><div class="line">    return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数会返回一个合适的块，或者返回NULL（在没有找到的情况下）。函数执行后，last指针指向上一次访问过的块。</p>
<h3 id="扩展堆"><a href="#扩展堆" class="headerlink" title="扩展堆"></a>扩展堆</h3><p>现在，并不能总是找到合适的块，有时候（特别是最开始使用malloc函数）需要去扩展堆。<br>实现同样很简单：移动break，并初始化新的block。当然还需要更新堆中上一个块的next域。<br>在后续开发过程中需要知道<code>struct s_block</code>的大小，所以在这儿定义一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define BLOCK_SZIE sizeof(struct s_block)</div></pre></td></tr></table></figure>
<p>下面代码没有什么可惊讶的，仅仅只是当sbrk失败之后返回NULL（没必要想这么做的原因）。<br>注意，前面提到过我们不能确信sbrk函数返回的上一个break，因此我们首先保存break值，然后移动它。我们需要使用<code>last</code>和<code>last-&gt;size</code>来进行计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">t_block extend_heap(t_block last, size_t size)&#123;</div><div class="line">    t_block b;</div><div class="line">    b = sbrk(0);</div><div class="line">    if ((void *)-1 == sbrk(BLOCK_SZIE+size)) &#123;</div><div class="line">        /// sbrk失败</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    b-&gt;size = size;</div><div class="line">    b-&gt;next = NULL;</div><div class="line">    if (last) &#123;</div><div class="line">        last-&gt;next = b;</div><div class="line">    &#125;</div><div class="line">    b-&gt;free = 0;</div><div class="line">    return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="拆分块（block）"><a href="#拆分块（block）" class="headerlink" title="拆分块（block）"></a>拆分块（block）</h3><p>注意到我们寻找首个可用的块，但并没有管它的大小（足够大）。假想一下，如果只需要2byte的大小，但是找到的块是256byte的，如果这样做会丢失很大一部分的空间。第一个解决方案是拆分块：当一个块足够宽到请求的大小加上一个新块大小（至少BLOCK_SIZE+4），那么向链表中插入一个新块。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/edbffe29859a9c3d269e1c93d92a508a.png" alt=""></p>
<p>下面的函数（split_block）会在空间可用的时候被调用。提供的大小(参数size)必须要是对齐的。<br>在这个函数中我们会做一些关于指针运算，为了防止错误，我们将使用一些小技巧来确保我们所有的操作都以一个字节的精度完成（需要注意一下p+1是依赖于p的类型的，也就是不同类型指针加一的步长不一样）。<br>我们只需要在<strong>struct s_block</strong>中添加一个字符数组的域。结构体中添加数组很简单：数组直接定义在结构的内存块中，因此数组指针的作用是指向meta-data的尾部。C禁止长度为零的数组，那么我们就定义个一字节长的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct s_block &#123;</div><div class="line">	size_t size;</div><div class="line">	t_block next;</div><div class="line">	int free;</div><div class="line">	char data[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>并且需要更新一下宏BLOCK_SIZE的值，由于扩展了s_block的data，如果还是使用sizeof的话将会把data字段也算进去。所以这里需要将BLOCK_SIZE固定位12字节（注意，现在说的32位整型）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define BLOCK_SZIE 12</div></pre></td></tr></table></figure>
<p>这里我说一下这里加了一个data域，为什么BLOCK_SIZE要设置为12，不随sizeof(struct s_block)呢？<br>前面也说过结构只是把内存里面的各个字节赋予了含义而已，我们只是想把12字节认为是meta-data，而并不是硬生生得塞了一块数据到meta-data和数据块之间。<br>加这个域只是为了我们在拆分block的时候方便，不加这个域同样也是可以操作的。</p>
<p>增加了这个扩展之后，并不需要明确为之前 <strong>extend_heap</strong>函数适配新增的data域。函数<code>split_block</code>：会根据传入的参数来拆分为所需大小的块。图四展示该函数的相关操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/// 参数s必须要对齐的</div><div class="line">void split_block(t_block b, size_t s) &#123;</div><div class="line">    if (!b) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    t_block new;</div><div class="line">    new = b-&gt;data + s;</div><div class="line">    new-&gt;size = b-&gt;size - s - BLOCK_SZIE;</div><div class="line">    new-&gt;free = 1;</div><div class="line">    new-&gt;next = b-&gt;next;</div><div class="line">    </div><div class="line">    b-&gt;size = s;</div><div class="line">    b-&gt;next = new;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意代码<code>b-&gt;data+s</code>，由于data域时char[]类型，所以我们能够精确地控制是以字节的步长进行增加。</p>
<h3 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h3><p>现在我们可以开始写malloc函数了，它主要是将前面讲到的函数封装起来。我们必须要将请求的size对齐，并测试是否是第一次调用malloc函数，以及已告知其余所需的条件。<br>在上一节的<code>find_block</code>函数中使用了一个全局变量 <strong>base</strong>，下面是该变量的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *base = NULL;</div></pre></td></tr></table></figure>
<p>它是一个void *类型的指针，并初始化为NULL。在malloc中我们首先要做的就是判断base是否为NULL？如果为NULL那么就表示第一次调用malloc函数，否则就是用前面提到的相关算法。</p>
<p>malloc函数需要具备下面几行中的特性：</p>
<ul>
<li>首先需要对齐请求的大小；</li>
<li>当base已经初始化：<ul>
<li>搜索足够大小的空闲块；</li>
<li>如果找到该块的情况下：<ul>
<li>尝试着去拆分该块（请求的大小和块的大小足够存储meta-data和最小块数据，比如4byte）；</li>
<li>标记该块为已是用(b-&gt;free = 0)；</li>
</ul>
</li>
<li>否则：扩展堆；注意在<code>find_block</code>函数中使用的last指针，它用于记录上一次访问过的块（chunk），因此当我们在扩展块的时候就不用再重新去遍历整个链表。</li>
</ul>
</li>
<li>否则：扩展堆（空指针）。注意此时工作在<code>extend_heap</code>函数时last=NULL。</li>
</ul>
<p>也需要注意在每次失败之后，我们按照预期指定的malloc函数返回NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void *malloc(size_t size)&#123;</div><div class="line">    t_block last,b;</div><div class="line">    size_t align_size = align4(size);</div><div class="line">    if (base) &#123;</div><div class="line">        last = base;</div><div class="line">        if ((b = find_block(&amp;last, align_size))) &#123;</div><div class="line">            if (b-&gt;size - align_size &gt;= (BLOCK_SZIE + 4)) &#123;/// meta-data + 4</div><div class="line">                split_block(b, align_size);</div><div class="line">            &#125;</div><div class="line">            b-&gt;free = 0;</div><div class="line">        &#125;else&#123;///查找heap失败，extend heap</div><div class="line">            b = extend_heap(base, align_size);</div><div class="line">            if (!b) &#123;</div><div class="line">                return NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;///首次调用malloc函数，extend heap</div><div class="line">        /// base = null;</div><div class="line">        b = extend_heap(base, align_size);</div><div class="line">        if (!b) &#123;</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        base = b;</div><div class="line">    &#125;</div><div class="line">    return b-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="六、calloc-free和realloc函数"><a href="#六、calloc-free和realloc函数" class="headerlink" title="六、calloc, free和realloc函数"></a>六、calloc, free和realloc函数</h2><h3 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h3><p>calloc函数：</p>
<ul>
<li>首先调用malloc函数，并分配正确的大小；</li>
<li>将块里面的每一个字节设置为0；</li>
</ul>
<p>这里使用一个小技巧：chunk中数据块的大小总是4的倍数，所以我们以4字节的步长进行迭代。因此我们把new指针当做无符号整型的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void *calloc(size_t number, size_t size) &#123;</div><div class="line">    size_t *new;</div><div class="line">    size_t s4,i;</div><div class="line">    new = malloc(number*size);</div><div class="line">    if (new) &#123;</div><div class="line">        s4 = align4(number*size)&lt;&lt;2;</div><div class="line">        for (i = 0; i &lt; s4; i++) &#123;</div><div class="line">            new[i] = 0;/// new为size_t，所以这里+1的步长为size_t的字节数，在32位整型下面，size_t为4字节</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><p>注：在下文提到的块在原文中的描述如果没有特殊注明均为chunk，而非在malloc一节大量使用的block。</p>
<p>快速实现free是很简单的，但简单并不意味着很方便就能完成。我们有两个问题：找到被释放的块，并且防止出现空间碎片。</p>
<h4 id="碎片：malloc函数遗留问题"><a href="#碎片：malloc函数遗留问题" class="headerlink" title="碎片：malloc函数遗留问题"></a>碎片：malloc函数遗留问题</h4><p>malloc函数的一个重大问题是碎片：在多次使用malloc和free之后，堆被划分为许多块，这些块已经小到足够满足大的malloc，直到整个可用空间使用。这就是空间碎片的问题。在这个算法中我们虽然没有办法避免出现额外的碎片，但可以避免其他来源的碎片。<br>当我们选择的空闲块足以容纳请求分配的量和另外的块时，我们会拆分当前块。在提供更好地内存使用率（新的块为空闲状态以备后用）的同时也引入了更多的碎片。<br>解决碎片化的一个问题就是空闲块。当我们释放一个块时，如果临接的块同样是空闲状态时，我们合并他们成一个更大的块。在这儿我们所有需要的就是去测试前面块和后面块的状态。那么如何去获取之前的块（block）呢？下面有几个解决方案：</p>
<ul>
<li>从头开始搜索，但非常慢（特别是我们已经搜了一些空闲块之后，再从头搜索）；</li>
<li>当我们搜索到当前块的时候，使用一个指针指向上一个访问的块；</li>
<li>双链表；</li>
</ul>
<p>我们选择最后这个解决方案，该方案非常简单地去跟踪目标块。所以我们再一次去修改<code>struct s_block</code>（第一次修改是malloc的时候增加的data成员）。但由于我们还有另外一个待修改的地方（下一节），因此先不急着做修改。</p>
<p>所以我们现在要做的就是合并，我们先写一个简单的合并函数来合并块。在下面的代码中我们会用一个 <strong>prev</strong>域来作为直接前驱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">t_block fusion(t_block b) &#123;</div><div class="line">    if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) &#123;</div><div class="line">        b-&gt;size += BLOCK_SZIE + b-&gt;next-&gt;size;</div><div class="line">        b-&gt;next = b-&gt;next-&gt;next;</div><div class="line">        if (b-&gt;next) &#123;</div><div class="line">            b-&gt;next-&gt;prev = b;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fusion函数很直截了当：如果下一个块是空闲块，那么就将当前块的size和下一个块的size，以及meta-data的大小。然后将next域指向当前变量后继的后继（b-&gt;next-&gt;next），此时如果当前的后继存在，那么久更新该后继的直接前驱（b-&gt;next-&gt;prev）。</p>
<h4 id="找到正确的块"><a href="#找到正确的块" class="headerlink" title="找到正确的块"></a>找到正确的块</h4><p>关于其余释放带来的问题是如何高效地寻找由malloc函数返回的正确的块。实际上，这儿存在几个问题：</p>
<ul>
<li>验证输入的指针（它是否真的是一个malloc指针）；</li>
<li>找到meta-data指针；</li>
</ul>
<p>我们可以通过quick range test来消除无用的指针：如果该指针在堆外，那么它肯定不是一个有效指针。那么剩下的case和上一个case相关，我们如何确定该指针是由malloc函数获得？<br>其中一个解决方案是在结构内使用一个魔数（magic number）。相对于魔数更优的一个方案是我们可以使用一个指针指向它自己。解释一下：我们有一个<code>ptr</code>域指向<code>data</code>域，如果b-&gt;ptr == b-&gt;data的时候，那么该指针大概率是有效块（block）。<br>下面是扩展之后的结构，以及访问和校验给定的指针是否为相应的块（block）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">typedef struct s_block* t_block;</div><div class="line">struct s_block &#123;</div><div class="line">    size_t size;</div><div class="line">    t_block next;/// 后继</div><div class="line">    t_block prev;/// 前驱</div><div class="line">    int free;</div><div class="line">    void *ptr;</div><div class="line">    char data[1];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">t_block get_block(void *p)&#123;</div><div class="line">    char *tmp;</div><div class="line">    tmp = p;</div><div class="line">    tmp = tmp-BLOCK_SZIE;</div><div class="line">    p = tmp;</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int vaild_addr(void *p) &#123;</div><div class="line">    if (base) &#123;</div><div class="line">        if (p &gt; base &amp;&amp; p &lt; sbrk(0)) &#123;/// sbrk(0)是获取当前break线，结合前面提到的图</div><div class="line">            return p == (get_block(p)-&gt;ptr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现free函数"><a href="#实现free函数" class="headerlink" title="实现free函数"></a>实现free函数</h4><p>free函数到现在也渐渐揭开了神秘面纱：验证指针的正确性，并找到相应的块，然后将其标记为空闲块，最后如果有必要就进行合并操作。<br>释放内存时，当我们处于堆的尾部，我们需要调用一下<strong>brk</strong>函数来调整break先到当前块的位置处。<br>下面的代码展示具体实现，大致的逻辑如下：</p>
<ul>
<li>如果指针有效：<ul>
<li>获取block块的地址；</li>
<li>标记为空闲状态；</li>
<li>如果当前节点的直接前驱是空闲的，那么就合并两个块；</li>
<li>继续尝试合并直接后继块；</li>
<li>如果当前处于最后一个块，那么我们释放内存；</li>
<li>如果这儿没有更多的块了，那我们重置为原始状态（base设置为NULL）；</li>
</ul>
</li>
<li>如果该指针不是有效指针的话，我们就什么也不做；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void free(void *ptr) &#123;</div><div class="line">    t_block b;</div><div class="line">    if (vaild_addr(ptr)) &#123;</div><div class="line">        b = get_block(ptr);</div><div class="line">        b-&gt;free = 1;</div><div class="line">        /// 如果可以合并直接前驱</div><div class="line">        if (b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free) &#123;</div><div class="line">            b = fusion(b-&gt;prev);</div><div class="line">        &#125;</div><div class="line">        /// 合并直接后继</div><div class="line">        if (b-&gt;next) &#123;</div><div class="line">            fusion(b);</div><div class="line">        &#125;else&#123;</div><div class="line">            if (b-&gt;prev) &#123;</div><div class="line">                b-&gt;prev-&gt;next = NULL;</div><div class="line">            &#125;else&#123;</div><div class="line">                base = NULL;</div><div class="line">            &#125;</div><div class="line">            brk(0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用realloc重置块的大小"><a href="#使用realloc重置块的大小" class="headerlink" title="使用realloc重置块的大小"></a>使用realloc重置块的大小</h3><p>realloc函数和calloc函数差不多一样直接。基本上我们只需要一个内存拷贝的操作，在这里我们不使用<string.h>里面的<code>memcpy</code>我们可以写一个更好的（大小以块为单位，并且已经对齐）。拷贝函数如下：</string.h></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void copy_block(t_block src, t_block dst) &#123;</div><div class="line">    int *sdata;</div><div class="line">    int *ddata;</div><div class="line">    size_t i;</div><div class="line">    sdata = src-&gt;ptr;</div><div class="line">    ddata = dst-&gt;ptr;</div><div class="line">    for (i = 0; src-&gt;size &gt; 4*i &amp;&amp; dst-&gt;size &gt; 4*i; i++) &#123;</div><div class="line">        ddata[i] = sdata[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照下面的做法可以实现一个非常幼稚（但是能工作）的realloc函数：</p>
<ul>
<li>使用malloc根据指定的大小分噢诶一个新块；</li>
<li>将数据从旧内存数据复制到新内存地址处；</li>
<li>释放旧内存中的数据；</li>
<li>返回指向内内存地址处的指针；</li>
</ul>
<p>当然我们还想做一点事儿让realloc函数更高效一点。当我们有足够的空间的时候，此时并不需要去分配新的空间。因此不同点有：</p>
<ul>
<li>如果大小未发生变化，或者额外可用大小足够使用，那么我们什么也不做；</li>
<li>如果需要收缩块，那么拆分该块；</li>
<li>如果下一个是空闲块而且提供了足够的空间，如果需要的话我们可以合并或者拆分这些块；</li>
</ul>
<p>下面是realloc函数的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void *realloc(void *p, size_t size) &#123;</div><div class="line">    if (NULL == p) &#123;</div><div class="line">        return malloc(size);</div><div class="line">    &#125;</div><div class="line">    size_t s;</div><div class="line">    t_block b, new;</div><div class="line">    void *newp;</div><div class="line">    if (vaild_addr(p)) &#123;</div><div class="line">        s = align4(size);</div><div class="line">        b = get_block(p);</div><div class="line">        if (b-&gt;size &gt; s) &#123;</div><div class="line">            if (b-&gt;size &gt;= s+BLOCK_SZIE+4) &#123;</div><div class="line">                split_block(b, s);</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">            if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free &amp;&amp; (b-&gt;next-&gt;size + b-&gt;size + BLOCK_SZIE) &gt;= s) &#123;</div><div class="line">                fusion(b);</div><div class="line">                if (b-&gt;size - s &gt; BLOCK_SZIE+4) &#123;</div><div class="line">                    split_block(b, s);</div><div class="line">                &#125;</div><div class="line">            &#125;else&#123;</div><div class="line">                newp = malloc(s);</div><div class="line">                if (!newp) &#123;</div><div class="line">                    return NULL;</div><div class="line">                &#125;else&#123;</div><div class="line">                    new = get_block(newp);</div><div class="line">                    copy_block(b, new);</div><div class="line">                    free(p);</div><div class="line">                    return newp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>别忘了realloc(NULL, s)是可以直接提到malloc(s)的。</p>
<h4 id="FreeBSD中reallocf函数"><a href="#FreeBSD中reallocf函数" class="headerlink" title="FreeBSD中reallocf函数"></a>FreeBSD中reallocf函数</h4><p>FreeBSD提供了另外一个realloc函数的实现：<code>reallocf</code>，它会在任何情况下释放输入的指针（即使是再分配失败之后）。我们一样会调用realloc函数，但是只有我们在获得空的指针之后才会调用free函数。下面是具体的实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void *reallocf(void *p, size_t size) &#123;</div><div class="line">    void *ptr = realloc(p, size);</div><div class="line">    if (!p) &#123;</div><div class="line">        free(p);</div><div class="line">    &#125;</div><div class="line">    return ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这儿基本翻译完成，如有错误请及时来联系我，谢谢❤️</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章是对&lt;a href=&quot;https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>细看objc-weak源码</title>
    <link href="http://yoursite.com/2018/05/18/source_code_objc_weak_t/"/>
    <id>http://yoursite.com/2018/05/18/source_code_objc_weak_t/</id>
    <published>2018-05-18T15:55:53.000Z</published>
    <updated>2019-10-28T04:47:08.088Z</updated>
    
    <content type="html"><![CDATA[<p>本文不看其他，只专注于weak的内部结构实现细节和源码解读，看了网上很多的文章都是贴上一篇<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">open source</a>里面的代码，并没有对实现细节进行解释。所以在这篇文章中，主要分为<br>weak_entry_t、weak_table_t的源码解析，weak_entry_t和weak_table_t的相互关系，以及对应的操作函数。</p>
<blockquote>
<p>下文的主要是基于两个对象来说的，一个是被引用的对象，一个是弱引用变量（也就是源代码中大量出现的指向指针的指针）。</p>
</blockquote>
<p> 我说一下我源码阅读的习惯，先把目光放在头文件中，因为头文件能够给我们一个整体基础结构。弄清楚具体的结构之后，然后再跳到实现文件中去看具体的实现细节。<br>先交代一下我的编译环境和源代码版本：</p>
<blockquote>
<p>编译环境：<br>Apple LLVM version 9.1.0 (clang-902.0.39.1)<br>Target: x86_64-apple-darwin17.5.0<br>Thread model: posix<br>InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin<br>源代码版本：<br> <a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="external">objc4-723</a> </p>
</blockquote>
<h2 id="头文件类关系和结构分析"><a href="#头文件类关系和结构分析" class="headerlink" title="头文件类关系和结构分析"></a>头文件类关系和结构分析</h2><p>我先根据头文件画一个基本的UML类图：</p>
<p><img src="/uploads/objc_weak_sroucecode/1.png" alt="UML类图"></p>
<h4 id="DisguisedPtr模板类"><a href="#DisguisedPtr模板类" class="headerlink" title="DisguisedPtr模板类"></a>DisguisedPtr模板类</h4><p>先将视线放在weak_entry_t上面，结构weak_entry_t的第一个成员变量是referent，它是一个<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-private.h" target="_blank" rel="external">DisguisedPtr</a>类模板实例化之后的变量（点开前面的链接吧，不然我讲不清楚，不然你会骂我的），这个成员其实就是保存被引用的对象。<br>DisguisedPtr类里面看起来这个类并不复杂，有一个uintptr_t类型的成员变量，由此DisguisedPtr类的对象所占用的内存空间大小也应该为8字节。<br>public下面主要是构造函数加三大函数中的两个：重载复制运算符，赋值构造函数；由于该类里面并没有涉及到动态new指针变量，所以其析构函数便使用了默认析构函数。除此之外还重载一些其他的操作符。主要看一下私有的两个成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static uintptr_t disguise(T* ptr) &#123;</div><div class="line">  return -(uintptr_t)ptr;</div><div class="line">&#125;</div><div class="line">static T* undisguise(uintptr_t val) &#123;</div><div class="line">  return (T*)-val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>disguise</code>函数是将指针变量强转为uintptr_t的整形变量，具体怎么伪装呢？就是把该指针指向的内存地址（16进制数据比如：0x7ffeefbff4e8）强制转换为无符号长整型的十进制数据。由于其类型是无符号长整型，因此取负数是数据溢出之后取该类型取值范围内较大的长整型值达到伪装的效果（也就是不好去找到原内存地址）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">unsigned long ul_val = 2;</div><div class="line">unsigned long*bitl = &amp;ul_val;</div><div class="line">cout&lt;&lt;&quot;ul_val address: &quot;&lt;&lt;bitl&lt;&lt;endl;///0x7ffeefbff4e8</div><div class="line">///140732920755432 取负数 -&gt; 18446744069408184208</div><div class="line">cout&lt;&lt;&quot;disguise: &quot;&lt;&lt;disguise(bitl)&lt;&lt;endl;</div><div class="line">cout&lt;&lt;&quot;undisguise: &quot;&lt;&lt;undisguise(*bitl)&lt;&lt;endl;/// 0xfffffffffffffffe 1111...1110</div></pre></td></tr></table></figure>
<p>其作用在源文件的注释中也说了，我通俗总结是：对那些比如leak这种内存检测工具进行伪装，然后这些检测工具可能就不好去跟踪被引用的对象。</p>
<h4 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h4><p>现在来看一下union的具体内存分布细节，怎么来解释这个问题呢？奉上<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-weak.h.auto.html" target="_blank" rel="external">objc-weak.h</a>的源码，打开源码配合文章来看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">union &#123;</div><div class="line">        struct &#123;/// 为了方便说明问题，我将该结构取名为：struct1</div><div class="line">            weak_referrer_t *referrers;</div><div class="line">            uintptr_t        out_of_line : 2;</div><div class="line">            uintptr_t        num_refs : PTR_MINUS_1;/// num_refs记录的是实际引用数量</div><div class="line">            uintptr_t        mask;/// 记录当前referrers数组容器的大小</div><div class="line">            uintptr_t        max_hash_displacement;/// 根据hash-key寻找index的最大移动数，这个在后面的append_referrer会讲</div><div class="line">        &#125;;</div><div class="line">        struct &#123;/// 为了方便说明问题，我将该结构取名为：struct2</div><div class="line">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</div><div class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先要有一个概念，union里面的多个成员是共享同一且相同大小的内存空间，在strcut1结构成员中算出其总共所占内存大小为64*4，也就是32个字节。其中我的机器是64位机，我的编译器对于指针类型所占内存大小的ABI实现为64位，而无符号长整型占用的内存大小也为64位。多说一句，在C++中结构和类的内存存储区域好像都是在堆上面，由低地址向高地址生长。<br>基于此来画出inline_referrers和上面第一个结构大致的内存分布样式（关于inline_referrers的元素类型模板类DisguisedPtr所占内存大小在上面讲DisguisedPtr类时提到了）：<br><img src="/uploads/objc_weak_sroucecode/2.png" alt=""><br>在源码中注释也说了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</div><div class="line">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</div><div class="line">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</div><div class="line">// (disguised nil or 0x80..00) or 0b11 (any other address).</div><div class="line">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</div></pre></td></tr></table></figure>
<p>out_of_line_ness是和inline_referrers[1]的低2位是等同的，<code>out_of_line_ness</code>和<code>num_refs</code>使用了位段，一共占用64位（2位和62位）。由于此时已经是结构内存对齐了，所以下一个结构成员mask的内存地址就刚好换行。<br>上面还提到的0x0b10，它应该是经过DisguisedPtr伪装之后得到的值，并不是实际的等于0b10，一个只占两位内存空间的，怎么也存储不了16位的数据。<strong>out_of_line_ness == 0b10</strong>是标记使用out-of-line的状态。关于这个0b10我没有想清楚它的由来，有知道的同学麻烦告知于我！！！<br>继续来看该结构的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</div><div class="line">        : referent(newReferent)</div><div class="line">&#123;</div><div class="line">        inline_referrers[0] = newReferrer;</div><div class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            inline_referrers[i] = nil;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建weak_entry_t实例的时候，默认是使用inline_referrers的方式来管理对象引用的，并把其余的位上的数据清空。<br><code>out_of_line_ness</code>用来判断使用out_of_line的方式来进行引用管理，这个out_of_line_ness的值主要是依据于被引用的对象，其引用变量的个数决定的，具体的逻辑在下文会讲到。<br>再看看struct1的referrers成员，看起来是一个指针变量，更具体的说是存储的引用变量数组的起始地址，而这些引用变量指针指向的地址被DisguisedPtr进行了伪装。</p>
<p>到这里我把weak_entry_t的内存分布讲了一遍（具体的含义在上面代码块中的注释里），然后下面来看一下<code>weak_table_t</code>。</p>
<h4 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h4><p><code>weak_table_t</code>在头文件中看不出什么特别的内容，但是从源码中可以看出，应该是一个基于C的结构，没有使用C++中结构独有的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct weak_table_t &#123;</div><div class="line">    weak_entry_t *weak_entries;</div><div class="line">    size_t    num_entries;/// 和weak_entry_t的num_refs概念类似</div><div class="line">    uintptr_t mask;///和 weak_entry_t的mask概念类似</div><div class="line">    uintptr_t max_hash_displacement;/// 和weak_entry_t的max_hash_displacement概念类似</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同样的，其weak_entries成员也应该是一个数组，存储着weak_entry_t变量的指针。针对该结构头文件中公开的操作函数有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id weak_register_no_lock(weak_table_t *weak_table, id referent, </div><div class="line">                         id *referrer, bool crashIfDeallocating);</div><div class="line">void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer);</div><div class="line">#if DEBUG</div><div class="line">bool weak_is_registered_no_lock(weak_table_t *weak_table, id referent);</div><div class="line">#endif</div><div class="line">void weak_clear_no_lock(weak_table_t *weak_table, id referent);</div></pre></td></tr></table></figure>
<p>这看不了什么具体的内容，所以针对头文件的解读就到这里。下面去实现文件中看看具体的实现，看看网上为什么都在说的基于Hash表的一个存储结构。<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/objc-weak.mm.auto.html" target="_blank" rel="external">源码地址</a>，老规矩，打开这个网页对照着源码来看。</p>
<h2 id="objc-weak具体实现细节"><a href="#objc-weak具体实现细节" class="headerlink" title="objc-weak具体实现细节"></a>objc-weak具体实现细节</h2><p>首先看两个hash函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static inline uintptr_t hash_pointer(objc_object *key);</div><div class="line">static inline uintptr_t w_hash_pointer(objc_object **key);</div></pre></td></tr></table></figure>
<p>它们会根据对象的指针（不管是指针还是指向指针的指针）调用一个fast-hash函数来生成一个key，其原理是基于<a href="http://locklessinc.com/articles/fast_hash/" target="_blank" rel="external">fast_hash</a>，而这个key的作用目前我们无从得知。</p>
<h4 id="grow-refs-and-insert函数"><a href="#grow-refs-and-insert函数" class="headerlink" title="grow_refs_and_insert函数"></a>grow_refs_and_insert函数</h4><p>继续看源码，下面主要来看看一个很重要的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">__attribute__((noinline, used))</div><div class="line">static void grow_refs_and_insert(weak_entry_t *entry, </div><div class="line">                                 objc_object **new_referrer)</div><div class="line">&#123;</div><div class="line">    assert(entry-&gt;out_of_line);</div><div class="line">    /**</div><div class="line">      * #define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</div><div class="line">      * entry-&gt;mask用来记录referrers的数量</div><div class="line">      */</div><div class="line">    size_t old_size = TABLE_SIZE(entry);</div><div class="line">    size_t new_size = old_size ? old_size * 2 : 8;/// 增长一倍的大小</div><div class="line"></div><div class="line">    size_t num_refs = entry-&gt;num_refs;</div><div class="line">    weak_referrer_t *old_refs = entry-&gt;referrers;</div><div class="line">    entry-&gt;mask = new_size - 1;</div><div class="line">    </div><div class="line">    entry-&gt;referrers = (weak_referrer_t *)</div><div class="line">        _calloc_internal(TABLE_SIZE(entry), sizeof(weak_referrer_t));</div><div class="line">    entry-&gt;num_refs = 0;</div><div class="line">    entry-&gt;max_hash_displacement = 0;</div><div class="line">    /// 开始处理数据</div><div class="line">    for (size_t i = 0; i &lt; old_size &amp;&amp; num_refs &gt; 0; i++) &#123;</div><div class="line">        if (old_refs[i] != nil) &#123;</div><div class="line">            append_referrer(entry, old_refs[i]);/// 把老数据复制进新的entry里面</div><div class="line">            num_refs--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Insert</div><div class="line">    append_referrer(entry, new_referrer);/// 给entry插入新的数据</div><div class="line">    if (old_refs) _free_internal(old_refs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于基于C的数组其实都是定长的，为了能够动态地增加新元素就需要不断地去申请新的内存空间，并且还要是连续的内存地址（要是不连续的地址就去使用链表的方式，但是链表的索引明显弱于数组的）。正是因为新动态申请的连续内存空间，这就需要把老数据复制过来，并把需要新增的数据也追加进去，最后释放掉原内存空间：<br><img src="/uploads/objc_weak_sroucecode/3.png" alt=""><br>它其实和C++里面的动态数组的原理一样，为了不频繁地去申请（<code>calloc</code>）新的空间和频繁地数据移动。所以每次2倍增长来增加weak_entry_t的长度。为什么说是C++里面动态数组的做法，在《数据结构与算法实现-C++描述》里有提及这些内容。</p>
<h4 id="append-referrer和remove-referrer"><a href="#append-referrer和remove-referrer" class="headerlink" title="append_referrer和remove_referrer"></a>append_referrer和remove_referrer</h4><p>在grow_refs_and_insert函数中调用了<code>append_referrer</code>函数，这个函数很明显是做插入操作的，默认使用inline的方式来增加新增的weak引用，如果使用inline的方式失败了，则是以outline的方式，并申请对应的存储空间，把entry-&gt;referrers指向新申请的内存地址，把inline_referrers数组里的数据拷贝到new_referrers中，其源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (! entry-&gt;out_of_line) &#123;</div><div class="line">        // Try to insert inline.</div><div class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            if (entry-&gt;inline_referrers[i] == nil) &#123;</div><div class="line">                entry-&gt;inline_referrers[i] = new_referrer;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Couldn&apos;t insert inline. Allocate out of line.</div><div class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</div><div class="line">            _calloc_internal(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</div><div class="line">        // This constructed table is invalid, but grow_refs_and_insert</div><div class="line">        // will fix it and rehash it.</div><div class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            new_referrers[i] = entry-&gt;inline_referrers[I];</div><div class="line">        &#125;</div><div class="line">        entry-&gt;referrers = new_referrers;</div><div class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</div><div class="line">        entry-&gt;out_of_line = REFERRERS_OUT_OF_LINE;</div><div class="line">        entry-&gt;mask = WEAK_INLINE_COUNT-1;</div><div class="line">        entry-&gt;max_hash_displacement = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里就可以看出，当被引用对象的弱引用referrers个数小于WEAK_INLINE_COUNT时，其entry里面是以inline小数组方式来存储这些弱引用变量的，只有当inline_referrers全部装满之后，该entry out_of_line被设置为REFERRERS_OUT_OF_LINE，后续如若有变量继续引用该对象则是以outline的方式存储的。</p>
<blockquote>
<p>union是在被引用变量的referrers个数小于等于WEAK_INLINE_COUNT时，使用inline数组的内存表现形式；当referrers个数超过了WEAK_INLINE_COUNT则以struct1的内存表现形式！</p>
</blockquote>
<p>由于使用inline的方式是使用小数组的方式，但是针对弱引用对象过多，那么它的存取性能就是考虑的一个重点。而散列是一种用于以常数平均时间执行插入、删除和查找的技术。<br>下面这个过程我不是很确定，如有不同的建议希望指出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</div><div class="line">size_t hash_displacement = 0;</div><div class="line">while (entry-&gt;referrers[index] != NULL) &#123;</div><div class="line">        index = (index+1) &amp; entry-&gt;mask;</div><div class="line">        hash_displacement++;</div><div class="line">&#125;</div><div class="line">if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</div><div class="line">        entry-&gt;max_hash_displacement = hash_displacement;</div><div class="line">&#125;</div><div class="line">weak_referrer_t &amp;ref = entry-&gt;referrers[index];</div><div class="line">ref = new_referrer;</div><div class="line">entry-&gt;num_refs++;</div></pre></td></tr></table></figure>
<p>begin是通过引用new_referrer调用散列函数获取一个散列值，这个散列值就是散列表中的元素查找自己所在散列槽的key。<br>从源码可以看出，通过散列值查找元素对应散列槽的方式好像是使用了<strong>线性探测法</strong>。简化上面的代码，配合下方这图来看一下把new_referrer指针查找正确index的过程：<br><img src="/uploads/objc_weak_sroucecode/4.png" alt=""><br>如上图，假设使用<code>w_hash_pointer</code>获取到的key为2，obj1成功插入到散列槽2中，obj2使用<code>w_hash_pointer</code>获取到的key也为2，此时散列槽2已经放入了obj1，那么只有正向地去寻找下一个散列槽，如果为空则放入obj2。<br>回到源码中，在求begin值的时候。把hash值和entry-&gt;mask做了按位与的操作，但是这里为什么要对entry-&gt;mask做一次按位与操作呢？<br>entry-&gt;mask存储着weak_entry_t的referrers数组大小，这样做能保证所得的散列值是小于当前数组的出界的，因为大于referrers数组大小对应的二进制位的高位全部被置为0，从而避免出现数组越界带来的问题。<br>关于出界和入界的概念，可以在《C陷阱与缺陷》中关于一个介绍for循环越界导致的死循环一节，具体的记得不是很清楚了。针对出界这个概念还是蛮重要的，老板们可以去看一看。<br><code>remove_referrer</code>和append_referrer在源码上来看基本没有什么区别，区别只不过是一个赋值，一个置空而已。</p>
<h4 id="weak-table-t的扩容和减容"><a href="#weak-table-t的扩容和减容" class="headerlink" title="weak_table_t的扩容和减容"></a>weak_table_t的扩容和减容</h4><p>针对weak_table_t的扩容和减容源码相对来说比较简单，限于篇幅我没有提供对应的代码，所以在看的时候还麻烦自己打开上面提到的源码地址对照来看。<br>在源码中主要提供了如下函数：</p>
<ul>
<li><p>weak_entry_insert；<br>函数<code>weak_entry_insert</code>和上一节提到的append_referrer是类似的，weak_table_t的内部实现同样也是使用散列表的方式来管理所有的entry变量的。只是weak_entry_insert没有去尝试inline的那一步。</p>
</li>
<li><p>weak_resize；<br>函数<code>weak_resize</code>和上面提到的grow_refs_and_insert函数类似，在调整大小时，都是创建一个新尺寸大小的内存空间，然后将原内存空间的数据移动到新的内存空间。weak_resize只有移动老数据，没有新数据的添加！最后释放掉原内存。</p>
</li>
<li><p>weak_grow_maybe；<br>函数<code>weak_grow_maybe</code>是在原weak_table的entry数量大于了weak_table数组容量的3/4时，便调用weak_resize去扩充容量到原数组容量的2倍。</p>
</li>
<li><p>weak_compact_maybe；<br>函数<code>weak_compact_maybe</code>是用来收缩容量的，当数组的容量内大部分都为空的话，则减容。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (old_size &gt;= 1024  &amp;&amp; old_size / 16 &gt;= weak_table-&gt;num_entries) &#123;</div><div class="line">        weak_resize(weak_table, old_size / 8);</div><div class="line">        // leaves new table no more than 1/2 full</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>weak_entry_remove；<br>函数<code>weak_entry_remove</code>用来weak_table_t的entries里对应的entry</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (entry-&gt;out_of_line()) free(entry-&gt;referrers);</div><div class="line">bzero(entry, sizeof(*entry));</div><div class="line">weak_table-&gt;num_entries--;</div><div class="line">weak_compact_maybe(weak_table);</div></pre></td></tr></table></figure>
<p>sizeof(*entry)获取到了weak_entry_t所占用的内存大小，使用<strong>bzero</strong>是将该内存段全部置为0，使用bzero而不使用memset影响并不大，使用memset需要多传入一个参数来确定需要重置的值。在《Unix网络编程》里创建sockaddr_in结构变量时，把对应内存空间数据清空用到了bzero，并讲了一下和memset的区别，具体内容可以去看看这本书。</p>
<h4 id="头文件暴露的四个函数"><a href="#头文件暴露的四个函数" class="headerlink" title="头文件暴露的四个函数"></a>头文件暴露的四个函数</h4><p>在头文件中暴露了四个外部可用的函数，分别是：<strong>weak_register_no_lock、weak_unregister_no_lock、weak_is_registered_no_lock和weak_clear_no_lock</strong>，根据注释来看主要是针对weak_table_t的添加、删除和清空数据等操作。在这里以下面的代码为基础来讲解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__weak id refer = obj;</div></pre></td></tr></table></figure>
<p>下面再来具体看看这几个函数在干什么？<br><code>weak_register_no_lock</code>源代码中提出，注册一个新的键值对，如果新的弱对象不存在则去新创建一个对应的entry。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!referent  ||  referent-&gt;isTaggedPointer()) return referent_id;</div></pre></td></tr></table></figure>
<p>如果被弱引用指向的对象（obj）是isTaggedPointer，这里便不做相关操作，直接返回弱引用指向的对象（obj）。<br>关于什么是Tagged Pointer，后面我再去细看一下里面的源码。从这里的源码可以看出，如果是TaggedPointer就不做后续操作，因为指针并没有指向真正的内存地址，返回的值则是被引用对象自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">weak_entry_t *entry;</div><div class="line">if ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        append_referrer(entry, referrer);</div><div class="line">&#125;else &#123;</div><div class="line">        weak_entry_t new_entry(referent, referrer);</div><div class="line">        weak_grow_maybe(weak_table);</div><div class="line">        weak_entry_insert(weak_table, &amp;new_entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果存在对应的entry则直接调用append_referrer进行插入。如果不存在，则调用weak_entry_t的构造函数创建一个新的对象，并查看是否需要针对weak_table进行扩容，将新的entry插入到weak_table中。下图是一个为对象增加弱引用，并将引用添加到weak_table中的简易流程：<br><img src="/uploads/objc_weak_sroucecode/5.png" alt=""></p>
<p>现在来看一下<code>weak_unregister_no_lock</code>函数，针对weak_table的移除，必须确保entry已经存在于weak_table中，才会去进行后续的操作，同样把对应的流程图画出来：<br><img src="/uploads/objc_weak_sroucecode/6.png" alt=""><br>最后两个函数是一个是debug状态下用于判断某一entry是否存在于weak_table中，另一个函数则是对特定的被弱引用的对象（obj）的所有引用做清楚操作。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里objc-weak应该算是讲清楚了（天知道我的表达能力怎么样。。。），最后我从外层结构到内层结构来一一总结下：<br>1、weak_table可以存储多个entry，而且它会根据其散列表中entry的个数来伸缩其所占内存大小；<br>2、一个entry表示的是一个被弱引用的对象（上文提到的obj），该变量可以被多个变量弱引用（refer）。所以entry也存在一个散列表，其用来存储对应的弱引用变量的引用。也就是前面源码里面提到的指向指针的指针。<br>3、entry的out_of_line_ness只有在弱引用变量大于<strong>WEAK_INLINE_COUNT</strong>时才会置为<strong>REFERRERS_OUT_OF_LINE</strong>。也就是只有在这时候union才会使用struct1结构内存布局。<br>4、还有就是out_of_line_ness == 0b10没有看懂。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文不看其他，只专注于weak的内部结构实现细节和源码解读，看了网上很多的文章都是贴上一篇&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;open s
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>记一次LFU缓存实现</title>
    <link href="http://yoursite.com/2018/01/17/lfu4cIniOS/"/>
    <id>http://yoursite.com/2018/01/17/lfu4cIniOS/</id>
    <published>2018-01-17T14:52:32.000Z</published>
    <updated>2018-01-17T14:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章大多是我自己的基于iOS开发一个想法过程，实现并不难。不过我并不会贴出全部代码，天知道我组织文章的根据是什么，能看懂都是缘分。<br><a id="more"></a> </p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>讨论缓存时，都会分内存缓存和硬盘缓存，本文主要是基于内存缓存的，但是完全可以稍加改动便可以应用于硬盘缓存中。在做其他文件IO的时，会有很多情况会基于C。基于此，我选择了使用C来实现核心部分。而它的作用是主要用于WebView在内存中的缓存数据。</p>
<p>关于LFU的一些概念之类的东西就不说了，原理实现网上一大堆。基于自己单链表通过栈来实现LFU的方式实现一下，这不一定是最优解，也有可能是最差解。不管怎么说，先通过一个图阐述一下主要的数据结构：<br><img src="http://upload-images.jianshu.io/upload_images/619906-4a7532a55131ca4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈数据变化"></p>
<h3 id="多想一点儿东西"><a href="#多想一点儿东西" class="headerlink" title="多想一点儿东西"></a>多想一点儿东西</h3><p>在看了上图之后，首先的想法就是去把具体算法撸出来。但是在开动写代码之前，我们需要想的东西应该要更多。在面向过程的思想中想开来，使用栈的时候取出操作可以很快速的完成最快可以达到时间复杂度为O(1)，而在维护栈顺序的时候，最坏的时间复杂度为O(N)，其查找和位置更新是在同一个循环中完成的，避免了不必要的时间消耗。</p>
<h3 id="加入到面向对象中"><a href="#加入到面向对象中" class="headerlink" title="加入到面向对象中"></a>加入到面向对象中</h3><p>显然用C来做业务逻辑开发始终有点儿蹩脚，所以得引入到面向对象中。我把这个类取名叫做<code>PPWebFetchCache</code>吧，既然都面向对象了，要不再弄点儿设计模式进去？考虑到易于操作性，对于PPWebFetchCache类，我做了一个单例，当然也可以自己生成一个对象。到了这里下面应该要想的就是对象的属性和操作方法等等事情，但是自己想着就用了一个单例模式这不是表明我设计模式很low吗？不过事实的确是这样，我没有什么好的设计模式拿出来~~~<br>所以我就硬塞了一个简单工厂模式进去。它做什么呢？我想的是“现在只是做LFU，万一哪一天变化来了，让我用写一个LRU的缓存策略，那我不是死得很惨！”，所以我又创建了一个继承于PPWebFetchCache类的<code>PPWebFetchLFUCache</code>，和另一个用于将来实现LRU算法的<code>PPWebFetchLRUCache</code>类。并在最后给父类添加了属性maxMemoryCost、maxMemoryCountLimit和两个操作方法storeCacheInMemory、memoryCacheWithURL。</p>
<h3 id="走进实现细节"><a href="#走进实现细节" class="headerlink" title="走进实现细节"></a>走进实现细节</h3><p>上面说的LFU是针对于某一个URL的使用次数。在思考如何使用最少时间拿到URL对应的数据时，显然散列表最理想的数据结构，而且在iOS中用散列表实现的代表便是<code>Dictionary</code>。所以大致的逻辑是：</p>
<blockquote>
<p>使用NSDictionary来实现URL和数据一对一在内存中的存储。而LFU主要用于管理某一URL的使用次数，淘汰掉使用次数最少的URL，并在内存字典中删除对应的数据。</p>
</blockquote>
<p>PPWebFetchCache对外暴露的接口只有存和取，而具体的加入和删除操作则是在内部通过maxMemoryCost、maxMemoryCountLimit控制实现。</p>
<h3 id="异步环境"><a href="#异步环境" class="headerlink" title="异步环境"></a>异步环境</h3><p>显然在数据存取的时候，我们不应该放在主线程中去做这些事儿。因此我创建串行队列用来执行这些事务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static dispatch_queue_t background_serialQueue()&#123;</div><div class="line">    static dispatch_queue_t queue;</div><div class="line">    if (!queue) &#123;</div><div class="line">        char *const label = &quot;com.example.webprefetchCache&quot;;</div><div class="line">        dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);</div><div class="line">        queue = dispatch_queue_create(label, attr);</div><div class="line">    &#125;</div><div class="line">    return queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void async_inbackground(void(^block)(void))&#123;</div><div class="line">    dispatch_async(background_serialQueue(), block);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要用串行队列？因为在队列内部操作，我不需要关心会出现资源竞争的问题。而在串行队列以外其他队列中来操作单例的相关数据时，我就需要去关心的线程安全的问题。因此我直接使用适用于静态分配的的互斥量<strong>PTHREAD_MUTEX_INITIALIZER</strong>来保证数据的同步操作。反观如果我去使用pthread_mutex_init来动态生成一个互斥量的话，我还要操心什么时候去destroy掉它（当然这里得仔细思考造成死锁的问题）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline pthread_mutex_t mutext_lock(void)&#123;</div><div class="line">    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</div><div class="line">    return lock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void safeProgressWith(void(^block)(void))&#123;</div><div class="line">    pthread_mutex_t lock = mutext_lock();</div><div class="line">    pthread_mutex_lock(&amp;lock);</div><div class="line">    block();</div><div class="line">    pthread_mutex_unlock(&amp;lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在加锁等操作时，尽量让其颗粒度更低。这样可以减少不必要的线程处于waiting状态，也就相应地减少出现低优先级线程饿死的情况发生（尽量减少CPU密集型线程的时间片）。</p>
<h3 id="LFU的具体实现"><a href="#LFU的具体实现" class="headerlink" title="LFU的具体实现"></a>LFU的具体实现</h3><p>LFU只是针对于URL的淘汰策略，淘汰了URL之后，根据该URL到NSDictionary中找出对应的数据进行移除。这里使用链表的方式实现栈结构，其结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct __PPWebLFUFetchInlayerNode_ * _PPWebLFUInlayerNodeRef;</div><div class="line">typedef struct __PPWebLFUFetchInlayerNode_ &#123;</div><div class="line">    char *url;</div><div class="line">    int use_count;</div><div class="line">    _PPWebLFUInlayerNodeRef next;</div><div class="line">&#125;_PPWebLFUFetchInlayerNode;</div></pre></td></tr></table></figure>
<p>在PPWebFetchLFUCache类中保存了一个_PPWebLFUInlayerNodeRef的指针，这个指针指向栈顶：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface PPWebFetchLFUCache:PPWebFetchCache&#123;</div><div class="line">    _PPWebLFUInlayerNodeRef _lfuStack;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>走到这里我们大可以直接使用_lfuStack成员变量来对栈进行相应的操作，但是我们可以更进一步！这里思维跳跃一下，当我们在插入一个节点时如何去判断当前节点是新增节点、还是存在于栈中的节点、抑或是需要删除的结点？<br>如果只是简单的回答“我在插入节点时，先遍历一遍栈看元素是否存在于其中”，这样做毫无意义，而且平添一倍的时间消耗，因为后面的插入操作时，还要去遍历一次找到对应的节点位置。<br>为了能够更好地在同一个循环中处理插入数据，查找数据，删除数据等操作。这里需要在执行C操作时在适当地点给我们回调，让我们有机会在一次循环中做完这些操作。为什么要用回调呢？我们完全可以把删除的相关逻辑放在某一次循环中，这样就需要我们在调用逻辑时传入一些判断条件。这无疑是增加了算法的局限性，从另一点来说，这个算法的适用范围就大大降低了。<br>所以我引入了一个上下文环境，这个环境主要用于包裹相关信息数据和函数指针回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">typedef struct __PPWebLFUFetchCacheContext *PPWebLFUFetchCacheContextRef;</div><div class="line">typedef struct __PPWebLFUFetchCacheContext &#123;</div><div class="line">    _PPWebLFUInlayerNodeRef *node;/// root</div><div class="line">    void *info;/// 一般传入fetchCacher对象</div><div class="line">    void (*appendInStackRootCallback)(void *info, char *const key);/// 栈顶插入回调</div><div class="line">    void (*appendInStackBottomCallback)(void *info, char *const key);/// 栈底插入回调</div><div class="line">    void (*appendInStackCallback)(void *info, char *const key);/// 栈中插入回调</div><div class="line">&#125;PPWebLFUFetchCacheContext;</div><div class="line"></div><div class="line">/// 调用这个方法之后，如果不再需要使用这个指针，需要调用free来释放内存空间</div><div class="line">PPWebLFUFetchCacheContextRef PPWebLFUFetchCacheContextCreate(void *root,</div><div class="line">                                                           void *info,</div><div class="line">                                                           void (* _Nonnull appendInStackRootCallback)(void *info, char *const key),</div><div class="line">                                                           void (* _Nonnull appendInStackBottomCallback)(void *info, char *const key),</div><div class="line">                                                           void (* _Nonnull appendInStackCallback)(void *info, char *const key))&#123;</div><div class="line">    PPWebLFUFetchCacheContextRef ctx = (PPWebLFUFetchCacheContextRef)malloc(sizeof(PPWebLFUFetchCacheContext));</div><div class="line">    ctx-&gt;node = root;</div><div class="line">    ctx-&gt;info = info;</div><div class="line">    ctx-&gt;appendInStackRootCallback = appendInStackRootCallback;</div><div class="line">    ctx-&gt;appendInStackBottomCallback = appendInStackBottomCallback;</div><div class="line">    ctx-&gt;appendInStackCallback = appendInStackCallback;</div><div class="line">    return ctx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于这里为什么选择一个上下文？当我们需要多个回调时，完全没有必要把每一个回调都添加到函数参数中去，我们可以把这些参数包装起来。而且这样包装起来做还有一个优势，就是新增回调场景时就要方便许多！</p>
<h3 id="元素添加"><a href="#元素添加" class="headerlink" title="元素添加"></a>元素添加</h3><p>现在所有的条件都已具备，是时候来处理这些具体的逻辑了。就像是在学红黑树的时候一般都会把它那5个特性先提出来是吧。所以这里需要明确几点特性：</p>
<ul>
<li>1、由链表实现的一个栈，只有一个根节点（上面提到的，包装在上下文中的lfustack）；</li>
<li>2、栈的深度是有限制的；</li>
<li>3、添加和删除操作是基于栈顶；</li>
<li>4、栈内元素的使用次数是从小到大，从上到下生长；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/619906-fe36c11c266d16da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>基于以上，我定义了一个元素添加函数的原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool _PPWebFetchLFUInlayerQueueAdd(PPWebLFUFetchCacheContextRef context,char *const url)</div></pre></td></tr></table></figure>
<p>很明显传入的context是需要在外面创建好的一个指针变量，但是context的具体成员变量我们没有控制，全部传入NULL都可以（因为懒，不想对函数指针做非空判断，所以我把函数指针设置为_Nonnull。。。），这没有什么问题。因此首先要做的就是判断栈是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (!(*(context-&gt;node))) &#123;/// 创建栈顶指针</div><div class="line">  _PPWebLFUInlayerNodeRef node = allocNewNode(url);</div><div class="line">  if (!node) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node);</div><div class="line">  safeProgressWith(^&#123;</div><div class="line">    *_broot = node;</div><div class="line">    (context-&gt;appendInStackRootCallback)(context-&gt;info,url);</div><div class="line">  &#125;);</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中我们使用了context的一个函数指针回调，当在空栈中加入根节点，这是符合该函数指针回调语义的。<br>此时的栈分布情况很简单，但还是画出来更加明显：<br><img src="http://upload-images.jianshu.io/upload_images/619906-a192fab1d454b156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在这之后插入结点时，我们便需要考虑新添加进来的URL是新节点还是在原有节点上增加使用次数。这里我们需要一个循环从根节点开始遍历栈，如果找到了对应的URL，便将其使用次数加一，如果走到栈底还是未能命中对应的URL，则需要以该URL为数据创建一个新节点，并将这个节点作为栈根。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (0 == strcmp(lead-&gt;url, url)) &#123;</div><div class="line">  (context-&gt;node)-&gt;use_count++;</div><div class="line">&#125;else&#123;</div><div class="line">  (context-&gt;appendInStackRootCallback)(context-&gt;info,url);</div><div class="line">  return appendRootNodeInStack((context-&gt;node), url);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面涉及到的函数appendRootNodeInStack主要用于生成一个节点之后，并将该节点设置为根：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">bool appendRootNodeInStack(_PPWebLFUInlayerNodeRef *root ,char *const url)&#123;</div><div class="line">    /// 在栈顶插入</div><div class="line">    _PPWebLFUInlayerNodeRef node = allocNewNode(url);</div><div class="line">    if (!node) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    __block _PPWebLFUInlayerNodeRef *_broot = root;</div><div class="line">    safeProgressWith(^&#123;</div><div class="line">        node-&gt;next = *_broot;</div><div class="line">        *_broot = node;</div><div class="line">    &#125;);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以现在会出现两种情况，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/619906-461de3ace1d81659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这段逻辑代码目前并没有放在循环中来做，它和栈中已经存在四个、五个节点的情况是类似的，但它的情况要简单许多，它只需要处理使用次数更新或者头节点插入的情况，不会涉及到删除（除非你不做缓存）、移位操作。到最后我会把这段代码合并起来，而那正是我设计这套算法的中心思想。</p>
<h3 id="节点移动和删除"><a href="#节点移动和删除" class="headerlink" title="节点移动和删除"></a>节点移动和删除</h3><p>针对节点的移动，需要考虑多个情况，包括：从栈顶移动到栈底、从栈顶移动到栈中某一个位置、从栈中某一个位置移动到栈中另一个位置、从栈中某一个位置移动到栈底、不移动。<br>我把这些情况依次描述到图中，这样看着更直观：<br><img src="http://upload-images.jianshu.io/upload_images/619906-9742abfeab7c4236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前两种情况"><br>下面是后面两种情况：<br><img src="http://upload-images.jianshu.io/upload_images/619906-43cbf19dcca8764c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后两种情况"><br>从上面虚线箭头到实线箭头的变化可以很明显看出来，是复杂了不少。而最后一种无变化的，我就没有列出来。看看前面四种情况变化后的栈元素排列情况，从左到右，从上到下依次是：</p>
<ul>
<li>2-&gt;3-&gt;4-&gt;1;</li>
<li>3-&gt;2-&gt;4-&gt;1;</li>
<li>2-&gt;4-&gt;3-&gt;1;</li>
<li>2-&gt;3-&gt;1-&gt;4;</li>
</ul>
<p>从上面四种情况来看，对于一个节点的移动可以分为两部拆开来看，分别是——<strong>取出、放入</strong>两个过程。我直接把中间的的算法列出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">_PPWebLFUInlayerNodeRef previous = lead;</div><div class="line">_PPWebLFUInlayerNodeRef pivot = NULL;</div><div class="line">_PPWebLFUInlayerNodeRef prepivot = NULL;</div><div class="line">do &#123;</div><div class="line">    if (0 != strcmp(lead-&gt;url, url)) &#123;</div><div class="line">        if (!pivot) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (pivot-&gt;use_count &lt;= lead-&gt;use_count) &#123;</div><div class="line">            break;/// 跳出循环去执行放入</div><div class="line">        &#125;</div><div class="line">        if (*(context-&gt;node)==pivot) &#123;</div><div class="line">            __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node);</div><div class="line">            safeProgressWith(^&#123;</div><div class="line">                *_broot = previous-&gt;next;</div><div class="line">            &#125;);</div><div class="line">        &#125;else&#123;/// 取出</div><div class="line">            prepivot-&gt;next=pivot-&gt;next;</div><div class="line">        &#125;</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">    lead-&gt;use_count++;</div><div class="line">    pivot = lead;</div><div class="line">    prepivot = previous;</div><div class="line">&#125; while ((void)(previous=lead),(void)(lead=lead-&gt;next),lead);</div><div class="line">if (!pivot) &#123;/// 在栈顶插入</div><div class="line">    (context-&gt;appendInStackRootCallback)(context-&gt;info,url);</div><div class="line">    return appendRootNodeInStack((context-&gt;node), url);</div><div class="line">&#125;</div><div class="line">if (!lead) &#123;/// 处理栈底情况</div><div class="line">    previous-&gt;next=pivot;</div><div class="line">    pivot-&gt;next=NULL;</div><div class="line">    (context-&gt;appendInStackBottomCallback)(context-&gt;info,url);</div><div class="line">&#125;else&#123;/// 处理栈中的放入</div><div class="line">    pivot-&gt;next=previous-&gt;next;</div><div class="line">    previous-&gt;next=previous==pivot?lead:pivot;</div><div class="line">    (context-&gt;appendInStackCallback)(context-&gt;info,url);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码把上面提到的if-else判断也一起合并进来了，这里pivot主要是用来记录找到目标URL的哨兵，而prepivot用来记录哨兵前面一个节点（如果使用双向链表完全可以不用这个零时变量）。<br>到这里基本上是把该算法的核心部分说完了，该算法的最坏时间复杂度就是O(N)，这种最坏时间复杂度的情况分别是：新节点插入，栈顶一次直接移动栈底（这个情况是发生在使用次数都为1时，栈顶元素此时+1的情况）。最优的时间复杂度情况是O(1)，直接栈顶数据更新。<br>最后就是节点的删除操作，仅仅只是删除操作时间复杂度肯定是O(1)的。但是事情往往没有这么简单，必须要考虑当前添加进来的元素是到达容量限制的新元素，还是栈里面已经存在的元素呢？难道我们又要去遍历一次栈然后来做删除操作吗？这是完全没有必要的，因为要出现删除节点的情况，肯定是发生在向栈中Push元素时发生。<br>因此我将上面各个情况分为三种大体情况，并为这三种情况提供了三个回调，而这个三个回调都是放在上面的context中：</p>
<ul>
<li>在栈顶插入元素（appendInStackRootCallback）；</li>
<li>处理栈底情况（appendInStackBottomCallback）；</li>
<li>处理中间节点（appendInStackCallback）；</li>
</ul>
<p>基于这：</p>
<blockquote>
<p>我们可以一次循环中完成新增、移动、删除操作！</p>
</blockquote>
<p>上面提到的三个回调，可以通过调用PPWebFetchLFUCache实例方法来看一下一个整体过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (BOOL)insertCacheMap:(NSData *)object forKey:(NSString *)key&#123;</div><div class="line">    PPWebLFUFetchCacheContextRef ctx = PPWebLFUFetchCacheContextCreate(</div><div class="line">                                                                       &amp;_lfuStack,</div><div class="line">                                                                       (__bridge void *)(self),</div><div class="line">                                                                       &amp;progressingAppendInStackRootCallback,</div><div class="line">                                                                       &amp;progressingAppendInStackBottomCallback,</div><div class="line">                                                                       &amp;progressingAppendInStackCallback);</div><div class="line">    bool result = _PPWebFetchLFUInlayerQueueAdd(ctx, (char *)[key UTF8String]);</div><div class="line">    if (result == false) &#123;</div><div class="line">        PPWebLFUFetchCacheContextRelease(&amp;ctx);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    if (![self.cacheMap.allKeys containsObject:key]) &#123;</div><div class="line">        safeProgressWith(^&#123;</div><div class="line">            [self.cacheMap setObject:object forKey:key];</div><div class="line">            self.currentCacheUsage += object.length;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    PPWebLFUFetchCacheContextRelease(&amp;ctx);</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面创建上下文的代码中，第一个参数为保存在PPWebFetchLFUCache单例中的一个成员变量，而info参数主要用来传递self，这里用context时，_lfuStack会被context保留，而_lfuStack又会被PPWebFetchLFUCache单例保留，但是在函数返回之前会对context做release操作，会把对_lfuStack的保留置空，所以不要想着OC里面常出现的引用计数不会降为0的问题。而且也不会出现相互持有的关系。<br>而回调函数中，主要来看progressingAppendInStackRootCallback的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void progressingAppendInStackRootCallback(void *info, char *const key)&#123;</div><div class="line">    PPWebFetchLFUCache *cacher = (__bridge PPWebFetchLFUCache *)(info);</div><div class="line">    if (!cacher) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (cacher.cacheMap.allKeys.count &gt;= kMaxMemoryCountLimit) &#123;</div><div class="line">        [cacher deleteCacheMap];</div><div class="line">        progressingAppendInStackRootCallback(info, key);</div><div class="line">    &#125;else&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我直接把删除函数贴出来，这并没有什么难点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">_PPWebLFUInlayerNodeRef _PPWebFetchLFUInlayerQueueDelete(PPWebLFUFetchCacheContextRef context ,char **url)&#123;</div><div class="line">    if (!(context-&gt;node)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    _PPWebLFUInlayerNodeRef lead = NULL;</div><div class="line">    lead = *(context-&gt;node);</div><div class="line">    __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node);</div><div class="line">    if ((*_broot)-&gt;next) &#123;</div><div class="line">        safeProgressWith(^&#123;</div><div class="line">            *_broot = (*_broot)-&gt;next;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    if (url) &#123;</div><div class="line">         (*url) = (lead-&gt;url);</div><div class="line">    &#125;</div><div class="line">    return lead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面出现的deleteCacheMap方法中会把不再使用的节点free掉。</p>
<h3 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h3><p>上面代码中很多地方都用到了safeProgressWith函数，其实现也在上面列出来了。使用它的目的有两个：<br>第一个、PPWebFetchLFUCache类的操作是可以在多线程异步环境下操作的，所以我必须要保证cacheMap的数据同步；<br>第二个、虽然基于C的操作我都是放在一个串行的队列中进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">async_inbackground(^&#123;</div><div class="line">  BOOL result = [self insertCacheMap:data forKey:url];</div><div class="line">  if (complete) &#123;</div><div class="line">    complete(result);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是_lfuStack成员变量是可以通过hook的方法拿到，并让其在异步环境下去进行修改，这个我没法去控制，但是我要做到在LFU内做到一个同步操作，所以基于跟节点的操作都是在加锁状态下完成的。这里需要注意的就是不要出现互斥锁的嵌套使用，如果使用的是同一个锁变量的话，那肯定会造成死锁的。</p>
<p>完。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章大多是我自己的基于iOS开发一个想法过程，实现并不难。不过我并不会贴出全部代码，天知道我组织文章的根据是什么，能看懂都是缘分。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>来唠嗑一下线程中的一些事儿</title>
    <link href="http://yoursite.com/2017/11/16/talk_about_thread/"/>
    <id>http://yoursite.com/2017/11/16/talk_about_thread/</id>
    <published>2017-11-16T13:55:18.000Z</published>
    <updated>2017-11-16T14:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/619906-b76f26ef4b53a80a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>由于前段时间的工作中，在一个并发编程题中栽了跟头,也因此增加了我对这一方面的理解。下面我会结合例子的方式来阐述一下我的一点儿小理解。<br><a id="more"></a> </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>  对于并发编程可能首先想到的便是和多线程有关，这又需要涉及到线程的概念。维基百科上关于<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">线程</a>的解释，我提取一个我认为比较关键的概念：</p>
<blockquote>
<p>它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
<p>每个线程存在自己的栈和寄存器集合，所以在这种情况下去保证线程相对安全的时候应该要使用<code>violate</code>变量（防止编译器缓存了被多个线程寄存器并发用到的变量，让编译器直接去变量地址获取）。</p>
<p>上面的重点在于“线程是包含于进程中，并且一条线程实际上一段代码的执行流”（代码区是被进程内多个线程共享的）。这里也就不过多深入地去解释了，贴一个我翻译的官方的<a href="https://www.gitbook.com/book/wangwangok/threading-programming-guide-will/details" target="_blank" rel="external">多线程编程</a>文档，并配合有创建线程不同方式的<a href="https://github.com/wangwangok/Thread_programming" target="_blank" rel="external">代码</a>。<br>我之所以专门把这个提出来是因为我在这个知识基础上遇到过一个面试题——“我们使用异步的方式从服务端获取到了我们需要的数据，然后我们如何去更新对应视图？”。如果不去细想的话直接扔出一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    [self post:url aPara:nil completionBlock:^(id responseObject, NSError *error) &#123;</div><div class="line">#if defined(USE_GCD_UPDATE_UI) &amp;&amp; USE_GCD_UPDATE_UI == 1</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">           /// 更新UI</div><div class="line">        &#125;);</div><div class="line">#else</div><div class="line">        /// updateView中更新UI</div><div class="line">        [self performSelectorOnMainThread:@selector(updateView:) withObject:responseObject waitUntilDone:NO];</div><div class="line">#endif</div><div class="line">    &#125;];</div></pre></td></tr></table></figure></p>
<h3 id="为什么在子线程中更新UI是不安全的"><a href="#为什么在子线程中更新UI是不安全的" class="headerlink" title="为什么在子线程中更新UI是不安全的"></a>为什么在子线程中更新UI是不安全的</h3><p>  他会继续追问你，我们为什么必须要把更新UI的任务放在主线程来做？放到子线程不可以吗？对于这个问题我只能用我浅显地认识来解释一下这个问题，因为操作系统相关的东西我几乎忘的差不多了。这里先抛出一个概念——<strong>基于UIKit的控件是线程不安全的</strong>。那么为什么苹果要把UIKit设计为线程不安全？</p>
<p>  最直观的来说，在牺牲性能为代价的前提下，使用同步能够确保代码的正确执行。在大多数情况下使用同步工具都会造成延迟。锁和原子操作通常会涉及到使用内存屏障和内核级的同步来确保代码正确执行。当出现锁竞争的情况下，线程可能会被阻塞从而导致体验上的延迟卡顿。所以我猜测有基于这个原因导致了苹果将UIKit设计成了线程不安全。这就回答了上面提出的“我们为什么必须要把更新UI的任务放在主线程来做？”</p>
<p>下面我通过画图的方式来表达一下在并行状态下UIKit不使用同步工具的情形：<br><img src="http://upload-images.jianshu.io/upload_images/619906-3d6a928e19f97a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>就如上图所示在主线程和子线程的消息队列中同时去修改同一内存空间中的值，如果不添加一个同步操作的话会发生意想不到的事情。Objective-C中的对象是存放在堆区，而堆区和前面我提过的代码区一样是线程共享的。现在我们知道为什么需要我们在主线程中去更新UI。而对于另一个问题：放到子线程不可以吗？或许在<a href="https://github.com/texturegroup/texture" target="_blank" rel="external">AsyncDisplayKit</a>中能够找到子线程处理视图的答案。</p>
<h3 id="子线程是如何实现在主线程中更新UI"><a href="#子线程是如何实现在主线程中更新UI" class="headerlink" title="子线程是如何实现在主线程中更新UI"></a>子线程是如何实现在主线程中更新UI</h3><p>  现在回到最初的问题上来，子线程和主线程是怎样协调工作来更新视图的呢？更新的代码我在上面已经放出来了，但是面试官的目的是想要知道其底层实现，先来看一下官方文档中出现的一个图片：<br><img src="http://upload-images.jianshu.io/upload_images/619906-687aad325b56e9ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如果要完整的讲一下我的理解的话，需要以下这些假设。我们把右边绿色的这一部分当做是子线程，而左边紫色的部分当做是主线程；并且我们有自定义一个输入源（因为我想完整的模拟这个场景，而不是使用系统提供的封闭的输入源），我们要通过该输入源来给主线程的Runloop发送消息（你可能会问为什么要用输入源？我直接发消息不可以吗？不好意思，Runloop就人输入源或者定时器源）。</p>
<p>首先来创建一个自定的输入源，这个输入源负责从子线程给主线程的Runloop发送消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// .h</div><div class="line">@interface RunloopSource : NSObject</div><div class="line">void	runloopsrc_schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode);</div><div class="line">void	runloopsrc_perform(void *info);</div><div class="line">void	runloopsrc_cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode);</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>上诉头文件中的三个函数分别是：  <code>schedule</code>表示注册成功并提供外部给子线程传递数据；<code>perform</code>是子线程通过输入源想要给主线程传输的主要出口；<code>cancel</code>是在我们异步处理完了之后，调用<code>CFRunLoopSourceInvalidate</code>函数告知主线程Runloop该输入源已经完成其职责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">///.m</div><div class="line">- (instancetype)init&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        CFRunLoopSourceContext ctx = &#123;</div><div class="line">            .info = (__bridge void *)(self),</div><div class="line">            .retain = NULL,</div><div class="line">            .release = NULL,</div><div class="line">            .copyDescription = NULL,</div><div class="line">            .equal = NULL,</div><div class="line">            .schedule = runloopsrc_schedule,</div><div class="line">            .perform = runloopsrc_perform,</div><div class="line">            .cancel = runloopsrc_cancel</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">void runloopsrc_schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">void runloopsrc_perform(void *info)&#123;</div><div class="line">    RunloopSource *src = (__bridge RunloopSource *)info;</div><div class="line">    [src sourceFire];/// 接口用c，但是处理数据，看习惯，习惯用OC</div><div class="line">&#125;</div><div class="line"></div><div class="line">void runloopsrc_cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (void)sourceFire&#123;</div><div class="line">    if (self.sourceFire_handle == nil) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    @synchronized (command_data) &#123;</div><div class="line">    /// 处理数据</div><div class="line">    /// 回传给主线程数据</div><div class="line">    /// 在输入源中，也就是这个函数中去给主线程的Runloop发送消息，让其更新界面</div><div class="line">    /// - (void)performSelector:(SEL)aSelector onThread:waitUntilDone:modes:</div><div class="line">    &#125;</div><div class="line">    CFRunLoopSourceInvalidate(runloop_src);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里假设我们已经从<code>- (void)URLSession: dataTask:didReceiveData:;</code>（NSURLSessionDataDelegate协议）获取到了数据，此时在runloopsrc_perform 中调用<code>performSelector</code>方法给主线程Runloop发送消息。现在我们把注意力放在上图左边的紫色部分，可以看出它一直处于一个循环中。如果此时消息队列中存在消息，那么该Runloop会处理消息队列中的消息，如果消息队列为空，那么Runloop应该是处于一个休眠状态。当他收到了由我们从子线程的自定义输入源发来的消息时，他会被唤醒来处理该消息。此时在主线程中去执行更新UI的事件。</p>
<p>对于这一块儿我并没有十足的把握，如果有更好的理解麻烦告知与我，万分感谢。</p>
<h2 id="我所了解的线程小常识"><a href="#我所了解的线程小常识" class="headerlink" title="我所了解的线程小常识"></a>我所了解的线程小常识</h2><p>到这儿了主要就说一点儿我所了解的线程，其中主要包括了线程优先级和调度问题，线程和他寄存器之间的一点儿恩怨！</p>
<h4 id="关于线程优先级和调度"><a href="#关于线程优先级和调度" class="headerlink" title="关于线程优先级和调度"></a>关于线程优先级和调度</h4><p>在多对一的线程模型中，一个内核线程对应了多个用户级线程，其实这时候的并发并不是真正意义上的并发，它应该是基于CPU轮转的方式来调度不同用户级线程，让他们每个都执行一小段时间，做到类似并发的效果。所以后面的线程模型都是基于多对多模型，它既可以实现真实的并发，又可以减少一对一模型中线程切换的消耗。</p>
<p>我们可以给线程设置不同的优先级来改变它们的先后执行顺序，除了我们指定的方式，系统会在以下两种情况下去更改线程优先级：</p>
<ul>
<li>I/O密集型线程会比CPU密集型线程更容易被系统提高优先级。<br>因为I/O密集型线程会经常进入waiting状态，而进入waiting状态说明它的任务花费时间短。而CPU密集型线程则是耗费完时间片之后进入ready状态。</li>
<li>对于I/O密集型线程来说，如果给它分配了较低优先级。而CPU密集型线程分配了较高线程优先级，那么就会造成I/O密集型线程处于“饿死”状态。所以系统会将长时间没有运行线程的优先级提高。</li>
</ul>
<h4 id="编译器优化所带来的问题"><a href="#编译器优化所带来的问题" class="headerlink" title="编译器优化所带来的问题"></a>编译器优化所带来的问题</h4><p>编译器为了能够让CPU在获取数据更快速，它会把一些需要经常访问的数据读取到寄存器中。<a href="http://www.ruanyifeng.com/blog/2013/10/register.html" target="_blank" rel="external">为什么寄存器比内存快？</a>，我的理解是由于寄存器存在于CPU内，内存和CPU之间相隔了一个北桥芯片，而它们是通过PCI总线来连接的，就距离上来说这可能是一个原因（我瞎扯淡）。<br>因为这个优化会产生一些小问题，看下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSThread thread1 = [NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        i++;</div><div class="line">        [lock unlock];</div><div class="line">&#125;];</div><div class="line">NSThread thread2 = [NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        i++;</div><div class="line">        [lock unlock];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>这是线程安全的吗？我只能说不一定，因为这是一个偶然事件。下面我来说一下我理解的这个偶然事件是怎么发生的？</p>
<ul>
<li>【thread1】读取i的值到线程1的寄存器集合R1（R1 = 0）；</li>
<li>【thread1】R1++（由于之后可能还要访问i，所以thread1暂时不会把R1写回到i）；</li>
<li>【thread2】读取i的值到线程2的寄存器集合R2（R2 = 0）；</li>
<li>【thread2】R2++（R1 = 1）；</li>
<li>【thread2】将R2写回i；</li>
<li>【thread1】过了很久之后，将R1写回i（i=1）；</li>
</ul>
<p>很明显这并不是我们想要的结果，这就是由于编译器的优化把值读取到了线程响应的寄存器集合中，改变的根本不是同一块儿内存上的值。所以为了解决这个问题可以使用前面提到的<code>violate</code>变量，以此来告诉编译器不要将该变量读取到寄存器中，而是直接在内存中进行操作。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>文章的最后我们唠叨一下并发这个词儿，关于并发和并行知乎上有一个<a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">回答</a>解释的很通俗易懂。所以针对Apple的<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">并发编程指南</a>，指的是有能力同时去执行多个任务，但并不是指一定要同时执行多个任务。GCD就不说了，大部分时间都是在使用它（因为它在接口使用上易用）。重点来说一下NSOperation，它是即强大又难用。</p>
<p>在开始使用NSOperation之前，我们自己需要清楚“我们要干什么？Apple提供的NSOperation是否满足需求？我们自定义NSOperation子类是基于并行还是串行？等等”。这里提到的并行和串行就不解释了，再解释就是一篇科普文了。<a href="http://nshipster.cn/nsoperation/" target="_blank" rel="external">NSHipster</a>上提到了关于NSOperation：</p>
<blockquote>
<p>NSOperation表示了一个独立的计算单元。作为一个抽象类，它给了它的子类一个十分有用而且线程安全的方式来<strong>建立状态、优先级、依赖性和取消等的模型</strong>。</p>
</blockquote>
<p>所以NSOperation和NSOpertaionQueue不仅仅只是用于网络的情况，当然与之对应的GCD同样可以用于其他事物。试想一下我们是否可以把NSOperation用于一个加载动画。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/619906-b76f26ef4b53a80a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;由于前段时间的工作中，在一个并发编程题中栽了跟头,也因此增加了我对这一方面的理解。下面我会结合例子的方式来阐述一下我的一点儿小理解。&lt;br&gt;
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS中Native的方式集成Vuforia、其源码解读以及自定义模型</title>
    <link href="http://yoursite.com/2017/09/13/ios_nativa_vuforia/"/>
    <id>http://yoursite.com/2017/09/13/ios_nativa_vuforia/</id>
    <published>2017-09-13T12:33:36.000Z</published>
    <updated>2017-09-20T13:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/619906-e5bbef9f60e5ee49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt=""><br>  随着前有Apple在iOS11中提供了ARKit，后有Google推出的ARCore，显然掀起了一股AR热潮（都是一堆废话，说白了就是公司要求做）。<br>  <a id="more"></a><br>  由于Vuforia已经存在较长时间了，相对于EasyAR或者百度AR更为成熟一点儿，所以它成了第一个技术选择。EasyAR和百度的AR——DuMix AR后面再依次去学习。好吧，先开始来学习Vuforia吧！<br>该文章同步发布在<a href="https://wangwangok.github.io" target="_blank" rel="external">我的博客</a>.</p>
<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><p>由于这些步骤相对来说比较基础，我就直接罗列出来。</p>
<ul>
<li><p>1、开发者官网<a href="https://developer.vuforia.com；" target="_blank" rel="external">https://developer.vuforia.com；</a></p>
</li>
<li><p>2、下载ios-sdk和ios-sample，并按照官方文档要求将ios-sample放入到ios-sdk的sample文件夹下</p>
</li>
<li><p>3、在vuforia的开发者官网上的License Manager和Target Manager，添加License-key和database<br><img src="http://upload-images.jianshu.io/upload_images/619906-8b73f5d04a424fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="License-Key"></p>
</li>
<li><p>4、将上一步添加的License-key，放在ios-sample中的代码文件<strong>SampleApplicationSession.mm</strong>中的方法<code>Vuforia::setInitParameters(mVuforiaInitFlags,&quot;&quot;);</code>中。具体步骤见<a href="https://library.vuforia.com/articles/Solution/How-To-add-a-License-Key-to-your-Vuforia-App" target="_blank" rel="external">官网</a>。</p>
  <pre>
Vuforia::setInitParameters(mVuforiaInitFlags,"AT16FIX/////AAAAGVieZ/kg1UkghTnYAz5zXWs8+y5JjeF/NJRcjgVDoCSvsrSt+lWzFMcIVBbQ2YSFRF+6J0GceHoaz8NctXib3cndJEacXmR+1FyO5FhalO7sC4hE9d1/x72qTNDhkPs4rF04JulMYT876Grsnmg9C61oyaDVwBfSpzNZ7gx3NADkkV5q4NQs4ghZwVCdMhj6LVt1YTJcwiuULtDTEgpFZZeW/nC8yiC53hpUFOVxhH++ILx1T65jpY8yDn6ct++3mgVeVotg/5tWXYb5FYqBtJiwU/LJJxhJYqUWyy4pd9dHUJBQojuAE8FoW1DmjokrpDWgjOMMp3am4GjNT04hCg+o0Z3SByYx6VIqfSR9fsXw");
</pre> 
</li>
<li><p>5、将第3步中Target Manager创建的database，传入相关的图片文件。也可以不传，这步可选；<a href="https://library.vuforia.com/articles/Solution/How-To-Work-with-Device-Databases.html" target="_blank" rel="external">怎样使用设备数据</a>。我们在<a href="https://developer.vuforia.com/targetmanager/project/checkDeviceProjectsCreated?dataRequestedForUserId=" target="_blank" rel="external">官方Developer</a>创建，下载对应的Database，在添加图片时，对应的星星数越高表明识别度越高<br><img src="http://upload-images.jianshu.io/upload_images/619906-9a71472177725481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="Target-Manager"><br>解压并将其引入到工程中：<br><img src="http://upload-images.jianshu.io/upload_images/619906-d8ea91265da85cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引入工程"><br>这一步可以不做，因为这只是在给后面打基础而已，如果只是运行demo的话是不需要做这一步的。如果做了这一步，在扫描你对应的图片的时候是没有任何效果的，具体的操作后面。</p>
</li>
<li><p>6、编译运行，由于需要使用到传感器，所以必须使用真机来运行。关于真机运行的相关事项查看apple developer</p>
</li>
</ul>
<h2 id="源码阅读顺序"><a href="#源码阅读顺序" class="headerlink" title="源码阅读顺序"></a>源码阅读顺序</h2><blockquote>
<p>源码说明：<br>Voforia SDK版本：<code>vuforia-sdk-ios-6-5-19</code><br>iOS Samples版本：<code>vuforia-samples-core-ios-6-5-20</code></p>
<p>如果不想看源码相关可直接跳过这部分，直接跟着“收尾”做自定义的tracker和模型（替换Teapot茶壶模型为自己的）</p>
</blockquote>
<p>为何要阅读源码？因为在<strong>Voforia</strong>的官方文档中我没有找到我自己想要的信息。所以我们需要通过阅读源码，来找到怎样才能去修改贴在目标图像中虚拟模型。以sample中<code>ImageTargetsViewController</code>为例来解读！<br>首先查看<code>ImageTargetsViewController.h</code>文件，我们先不看成员变量。先来看属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性类型</th>
<th style="text-align:left">初步作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>eaglView</strong></td>
<td style="text-align:left"><code>ImageTargetsEAGLView*</code></td>
<td style="text-align:left">初步认定为一个展示视图</td>
</tr>
<tr>
<td style="text-align:left"><strong>tapGestureRecognizer</strong></td>
<td style="text-align:left"><code>UITapGestureRecognizer*</code></td>
<td style="text-align:left">一个点击手势</td>
</tr>
<tr>
<td style="text-align:left"><strong>vapp</strong></td>
<td style="text-align:left"><code>SampleApplicationSession*</code></td>
<td style="text-align:left">初步认定为一个会话层（类似于ISO网络七层模型中，在TCP可以归于应用层，也就是说想偷懒可以直接将其代码放入控制器中。个人理解）</td>
</tr>
<tr>
<td style="text-align:left"><strong>showingMenu</strong></td>
<td style="text-align:left"><code>BOOL</code></td>
<td style="text-align:left">一个flag</td>
</tr>
</tbody>
</table>
<p>从上表中出现的属性，我们先来分析一下属性<code>eaglView</code>和<code>vapp</code>。</p>
<h4 id="SampleApplicationSession类"><a href="#SampleApplicationSession类" class="headerlink" title="SampleApplicationSession类"></a>SampleApplicationSession类</h4><p>在<code>ImageTargetsViewController</code>控制器类中，和下面会讲到的<code>ImageTargetsEAGLView</code>都有<code>SampleApplicationSession</code>类型的属性，所以我们有必要先来看看该类。同样的先看头文件，因为头文件能够让我们对于该类有大体的认识，而不拘于类具体的实现细节。<br>  粗略来看，提供了一个初始化方法；一个初始化AR的方法；四个对AR的操作方法（它们不是我们需要的重点，等到需要的时候再来仔细阅读）；以及一个对Camera的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)initWithDelegate:(id&lt;SampleApplicationControl&gt;) delegate;</div><div class="line">- (void) initAR:(int) VuforiaInitFlags orientation:(UIInterfaceOrientation) ARViewOrientation;</div><div class="line">- (bool) startAR:(Vuforia::CameraDevice::CAMERA_DIRECTION) camera error:(NSError **)error;</div><div class="line">- (bool) pauseAR:(NSError **)error;</div><div class="line">- (bool) resumeAR:(NSError **)error;</div><div class="line">- (bool) stopAR:(NSError **)error;</div><div class="line">- (bool) stopCamera:(NSError **)error;</div></pre></td></tr></table></figure></p>
<p>上述的initAR方法是通过异步实现的，当其AR初始化完成之后会调用方法下面会提到的代理方法<code>onInitARDone</code>。顺藤摸瓜，我们来看看该代理，那么该代理所需要处理的事务有哪些呢？这里先将<code>SampleApplicationControl</code>的所有方法先列出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@required</div><div class="line">- (void) onInitARDone:(NSError *)error;</div><div class="line">- (bool) doInitTrackers;</div><div class="line">- (bool) doLoadTrackersData;</div><div class="line">- (bool) doStartTrackers;</div><div class="line">- (bool) doStopTrackers;</div><div class="line">- (bool) doUnloadTrackersData;</div><div class="line">- (bool) doDeinitTrackers;</div><div class="line">- (void)configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;</div><div class="line"></div><div class="line">@optional</div><div class="line">- (void) onVuforiaUpdate: (Vuforia::State *) state;</div></pre></td></tr></table></figure></p>
<p>该代理方法中大多是涉及到的是tracker。通过从初始化方法开始查看方法调用，得出了一个程序执行流程图，<br><img src="http://upload-images.jianshu.io/upload_images/619906-ae15fadf72afc1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-1"><br>我们主动调用<code>initAR</code>方法，其结果会由回调方法<code>onInitARDone</code>反应给开发者。开发者可以用通过调用<code>doInitTrackers</code>来控制是否需要去加载tracker数据，如果可以加载数据则通过调用回调方法<code>doLoadTrackersData</code>来获取数据。关于该类中其他几个方法<code>startAR , pauseAR, resumeAR, stopAR</code>由调用人员主动调用，调用这些方法会触发对应的方法回调。<br>现在我们需要把目光转向<code>ImageTargetsEAGLView</code>类，并去具体的看一下里面的相关细节。</p>
<h4 id="SampleAppRenderer类"><a href="#SampleAppRenderer类" class="headerlink" title="SampleAppRenderer类"></a>SampleAppRenderer类</h4><p>这个类主要是做渲染相关的工作，其源码大多数为OpenGL。所以对于该类我只做具体的作用分析，而不去解释具体的源代码（因为我也不懂），如有需要的话，自行深究吧，哈哈哈😄。这里先将各个方法的作用罗列出来：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">initWithSampleAppRendererControl</td>
<td style="text-align:left">类初始化方法</td>
</tr>
<tr>
<td style="text-align:left">initRendering</td>
<td style="text-align:left">渲染相关的初始化</td>
</tr>
<tr>
<td style="text-align:left">setNearPlane:farPlane:</td>
<td style="text-align:left">配置投影矩阵数据</td>
</tr>
<tr>
<td style="text-align:left">renderFrameVuforia</td>
<td style="text-align:left">由Vuforia调用，渲染数据帧到屏幕</td>
</tr>
<tr>
<td style="text-align:left">renderVideoBackground</td>
<td style="text-align:left">后台渲染视频</td>
</tr>
<tr>
<td style="text-align:left">configureVideoBackgroundWithViewWidth:andHeight:</td>
<td style="text-align:left">视频相关的配置</td>
</tr>
<tr>
<td style="text-align:left">updateRenderingPrimitives</td>
<td style="text-align:left">更新渲染数据</td>
</tr>
</tbody>
</table>
<p>下面具体分析：老规矩，同样先看头文件，我们根据头文件暴露出来的方法一层一层往里剥。该类存在一个协议<code>SampleAppRendererControl</code>，和一个初始化方法<code>initWithSampleAppRendererControl</code>。使用这个方法需要传入一个遵守<code>SampleAppRendererControl</code>协议的类实例，第二个参数来决定<strong>VR/AR</strong>的模式，以及三个用于决定投影矩阵的参数。除了在初始化方法设置投影矩阵的参数，该类提供了一个public方法<code>setNearPlane:farPlane:</code>。进入到.mm文件中查看该初始化方法可以看出，只是对类内部私有属性进行相关的赋值操作以及对硬件设备进行相关的设置吧。<br>  现在来看看方法<code>initRendering</code>，这个方法里面主要是做了一些OpenGLES的东西，我们只需要知道里面做了一些和具体业务逻辑无关的东西就行了。<br>  接下来看<code>renderFrameVuforia</code>的作用是什么？源代码中说的很清楚：使用OpenGL绘制当前帧，<strong>当需要将当前帧渲染到屏幕上时</strong>，Vuforia会定期的在后台线程调用该方法。同样和业务逻辑无关，源码不细看。同样方法<code>renderVideoBackground</code>也是使用OpenGL来做，我们只需要从该方法的名字得知其用途（后台渲染视频）即可。<br>  <code>configureVideoBackgroundWithViewWidth:andHeight:</code>方法从名字就可以知道其作用。<code>updateRenderingPrimitives</code>方法的作用是：当屏幕尺寸发生改变或者是设备朝向改变之后，调用该方法来更新渲染原始数据。<br>  最后需要介绍一下该类很重要的的一个协议方法：<code>renderFrameWithState</code>，该方法被用于获取渲染相关的数据。通过对.mm文件可知，每渲染一次都会调用该方法一次。</p>
<h4 id="ImageTargetsEAGLView类"><a href="#ImageTargetsEAGLView类" class="headerlink" title="ImageTargetsEAGLView类"></a>ImageTargetsEAGLView类</h4><p>该类的头文件所暴露出来的初始化方法<code>- (id)initWithFrame:(CGRect)frame appSession:(SampleApplicationSession *) app</code>，我们以该方法入手来分析。第一个参数为当前视图的大小设置，第二个参数为前面我们讲到过的一个类实例。头文件中余下的方法还有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)finishOpenGLESCommands;</div><div class="line">- (void)freeOpenGLESResources;</div><div class="line"></div><div class="line">- (void) setOffTargetTrackingMode:(BOOL) enabled;</div><div class="line">- (void) configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;</div><div class="line">- (void) updateRenderingPrimitives;</div></pre></td></tr></table></figure></p>
<p>方法<code>finishOpenGLESCommands , freeOpenGLESResources</code>分别对应着结束OpenGL和释放OpenGL的资源。configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives和类SampleAppRenderer公开的方法名一样，这里我猜测它们作用是一样的。<code>setOffTargetTrackingMode:</code>方法作用目前还不是很清晰，需要去.mm文件中详查。<br>  现在进入实现文件中，源码中提到了关于OpenGL线程安全的问题。iOS上的OpenGL ES是线程不安全的，在程序中Vuforia使用下面的方法来保证线程（OpenGL 上下文）安全：</p>
<ul>
<li>a、在主线程中创建OpenGL ES上下文。</li>
<li>b、Vuforia相机开始时，将其位于我们自己EAGLView视图上，并开启renderer线程。</li>
<li>c、Vuforia会在renderer线程上，定期调用我们的renderFrameVuforia（SampleAppRenderer类提到）方法。当第一次调用该方法的时候，<code>defaultFramebuffer</code>并不存在，调用createFramebuffer方法来创建它。createFramebuffer由主线程调用，而与此同时renderer线程会被阻塞。因此确保OpenGL ES上下文不会被并行使用</li>
</ul>
<p>在initWithFrame:appSession:的实现方法中会进行session，OpenGL的context和Renderer的赋值，初始化和绑定工作。而方法configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives在其实现方法中的确只是简单的调用了一下SampleAppRenderer 类的实例方法。<br>  现在主要来看看方法<code>setOffTargetTrackingMode :</code>，它的实现很简单只是对其私有成员变量NO。但是却在协议方法<code>renderFrameWithState</code>中大量的使用。该方法大部分是OpenGL相关的工作，我没有深究下去，只整理出来一个工作流程图：<br><img src="http://upload-images.jianshu.io/upload_images/619906-cfd6bcc49e13644a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-2"><br>目前来看ImageTargetsEAGLView类的主要作用在于保证OpenGL在iOS中达到线程安全，创建buffer和对buffer的管理，提供了对OpenGL的控制，而实际的渲染则由SampleAppRenderer来实现。</p>
<h4 id="ImageTargetsViewController类"><a href="#ImageTargetsViewController类" class="headerlink" title="ImageTargetsViewController类"></a>ImageTargetsViewController类</h4><p>现在将目光回到<code>ImageTargetsViewController</code>类上面来。由于是一个控制器类，所以我直接从.mm文件中着手。根据ViewController的加载顺序来看具体的逻辑，首先查找<code>loadView</code>方法，如果没有则查找<code>viewDidLoad</code>。源码中，loadView方法主要创建了vapp，eaglView以及对vapp初始化了AR相关的事务（其他视图和手势等先忽略，只关心属性vapp,eaglView相关的逻辑），将ViewController的View设置为eaglView。<br>  在loadView中将vapp的代理设置为控制器自身，此时通过上面介绍<strong> SampleApplicationSession</strong>时对应的程序执行流程，将目光放在对应的部分协议方法上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol SampleApplicationControl</div><div class="line">- (void) onInitARDone:(NSError *)error;</div><div class="line">- (bool) doInitTrackers;</div><div class="line">- (bool) doLoadTrackersData;</div><div class="line">- (bool) doStartTrackers;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>从图-1可以看出是由<code>doInitTrackers</code>的返回值来判断是否需要去加载tracker数据(doLoadTrachersData)，最后在onInitARDone方法流程结束。通过这个就确定了我们的源码查看顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/// doInitTrackers --&gt; doLoadTrackersData --&gt; onInitARDone</div></pre></td></tr></table></figure></p>
<p>那么在ImageTargetsViewController类中，其流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-aadd870b1aae0265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-3"><br>自此我们的源码阅读就告一段落，最后我们将要去实现开始提到的目的！</p>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>读到这里，自定义的数据集的切入点在方法<strong><code>doLoadTrackersData</code></strong>方法中，并且要doInitTrackers方法返回YES。如果没有执行“安装步骤”中的第5步的话，现在可以去做了！做完之后添加如下代码到工程中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">///ImageTargetsViewController.mm -&gt; doLoadTrackersData</div><div class="line">dataSetCustom = [self loadObjectTrackerDataSet:@&quot;WillDB_Device.xml&quot;];/// 这个dataset为你自己的名字</div><div class="line">if (dataSetCustom == NULL) &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">if (! [self activateDataSet:dataSetCustom]) &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，扫描对应的图片发现是能够成功扫描对应的图片的。但是系统的图片能出来一个“茶壶”，而我们自己的图片上面什么也没有呢？<br>在这里我不想又去使用这个烦人的“茶壶”OpenGL模型了，我选择的是一个皮卡丘的原型（在文末我会将改造过的demo传到Github可以去那里下载这个原型）。</p>
<h4 id="模型obj到opengl数据的转换"><a href="#模型obj到opengl数据的转换" class="headerlink" title="模型obj到opengl数据的转换"></a>模型obj到opengl数据的转换</h4><p>就目前我知道的来说，在Xcode中无法使用<strong>.obj</strong>的模型数据的。我在网上找到了一个工具<strong><a href="https://github.com/HBehrens/obj2opengl" target="_blank" rel="external">obj2opengl</a></strong>，具体的使用方法见<a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">这里</a>，我还是大体来说一下使用步骤：<br>将下载好的文件放到特定的文件夹中，然后把对应的obj文件和它放在一起，使用终端进入<strong>obj2opengl.pl</strong>文件所在文件夹之后，输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./obj2opengl.pl yourobjfilename</div></pre></td></tr></table></figure></p>
<p>成功后，它会生成一个头文件，这就是通过obj文件生成的纹理坐标代码，在该头文件中有3个数组，这三个数组分别对应着<strong>xxxVerts [], xxxNormals [], xxxTexCoords []</strong>，和一个xxxxNumVerts（xxx为你的obj文件名字），<a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">具体使用说明</a>。</p>
<h4 id="模型替换"><a href="#模型替换" class="headerlink" title="模型替换"></a>模型替换</h4><p>通过前面的源码阅读，我们知道ImageTargetsViewController类是用来加载tracker数据的，SampleAppRenderer类是做渲染相关的数据，SampleApplicationSession类是使用tracker数据并控制AR，最后只剩下一个ImageTargetsEAGLView类。在该类中会做如下操作：</p>
<ul>
<li>1、在textureFilenames数组中，添加一个新的<a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/" target="_blank" rel="external">纹理</a>。这个自己选择一个纹理图片，我是随便选的，所以看起来会很丑。</li>
<li><p>2、在ImageTargetsEAGLView类的头文件中添加一个私有成员变量<strong>pikachuModel</strong>。用它来代替例子中的buildingModel。并在SampleApplication3DModel.h文件中添加方法<code>pikachu_ReWrite</code>，并在SampleApplication3DModel.m文件中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)pikachu_ReWrite&#123;</div><div class="line">#if kUse3DModel == 1</div><div class="line">  _numVertices = XY_PikachuMNumVerts;</div><div class="line">  _vertices = XY_PikachuMVerts;</div><div class="line">  _normals = XY_PikachuMNormals;</div><div class="line">  _texCoords = XY_PikachuMTexCoords;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>3、在ImageTargetsEAGLView.mm的方法<code>loadBuildingsModel</code>中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pikachuModel = [[SampleApplication3DModel alloc] init];</div><div class="line">[pikachuModel pikachu_ReWrite];</div></pre></td></tr></table></figure>
</li>
<li><p>4、将ImageTargetsEAGLView.mm文件中所有的buildingModel替换为<strong>pikachuModel</strong>，最后调节一下变量<strong>kObjectScaleOffTargetTracking</strong>的值，这个值调节由自己决定。</p>
</li>
</ul>
<p>上述的修改灵感大多是来自头文件<strong>Teapot.h</strong>，但是我们使用obj2opengl时生成的文件中并没有Teapot.h中<strong>teapotIndices</strong>对应的数组。相反多了一个无符号的整形变量<code>xxxNumVerts</code>，所以除了上诉的方法以外还有另外一种方法，具体的代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// ImageTargetsEAGLView.mm -&gt; renderFrameWithState方法中</div><div class="line">glVertexPointer(3, GL_FLOAT, 0, XY_PikachuMVerts);</div><div class="line">glNormalPointer(GL_FLOAT, 0, XY_PikachuMNormals);</div><div class="line">glTexCoordPointer(2, GL_FLOAT, 0, XY_PikachuMTexCoords);</div><div class="line"></div><div class="line">glDrawArrays(GL_TRIANGLES, 0, XY_PikachuMNumVerts);</div></pre></td></tr></table></figure></p>
<p>在使用这个方法时其（用obj2opengl生成的头文件的数组中的）数值比例是需要修改的，而且还需要对模型进行翻转。这个方法具体见<a href="https://developer.vuforia.com/forum/faq/android-how-do-i-replace-teapot" target="_blank" rel="external">How do I replace the Teapot</a>和<a href="https://library.vuforia.com/articles/Solution/Working-with-Vuforia-and-OpenGL-ES" target="_blank" rel="external">Replace the teapot model</a>。<br>在修改源码时主要就是在修改方法<code>renderFrameWithState</code>，它在介绍ImageTargetsEAGLView类时在文件的最开头就有提到，它是在每捕捉到一次tracker之后就会运行一次。<br>到这里一个很基本的Vuforia集成，源码的解读以及自定义tracker和模型就算完成了，最后附上Demo<a href="https://github.com/wangwangok/VuforiaSampleOBJC" target="_blank" rel="external">地址</a>。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">obj2opengl</a></li>
<li><a href="https://github.com/HBehrens/obj2opengl" target="_blank" rel="external">obj2opengl Github</a></li>
<li><a href="http://www.songho.ca/opengl/gl_transform.html" target="_blank" rel="external">OpenGL Transformation</a></li>
<li><a href="https://developer.vuforia.com/forum/faq/android-how-do-i-replace-teapot" target="_blank" rel="external">How do I replace the Teapot</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/619906-e5bbef9f60e5ee49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240&quot; alt=&quot;&quot;&gt;&lt;br&gt;  随着前有Apple在iOS11中提供了ARKit，后有Google推出的ARCore，显然掀起了一股AR热潮（都是一堆废话，说白了就是公司要求做）。&lt;br&gt;
    
    </summary>
    
      <category term="AR" scheme="http://yoursite.com/categories/AR/"/>
    
    
      <category term="AR" scheme="http://yoursite.com/tags/AR/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC与C的交互及其内存管理</title>
    <link href="http://yoursite.com/2017/08/01/oc_bridge_c_memory/"/>
    <id>http://yoursite.com/2017/08/01/oc_bridge_c_memory/</id>
    <published>2017-08-01T14:44:07.000Z</published>
    <updated>2017-09-13T14:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/619906-9ef7407a879ddf09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  首先我们从最基本的C中三种链接属性，分别是：外部(external)、内部(internal)、无(none)。我们可以通过关键字<code>extern、static</code>来修改变量的链接属性。<br>  <a id="more"></a><br>  <strong>extern</strong>关键将一个变量声明为外部的链接属性之后，便可以去访问其他文件中同名该变量。<strong>static</strong>关键字在用于代码块外部的变量时是将其设置为内部链接属性，如果是在代码块内部则将该变量声明为静态变量。<br>  然后再来看看C中变量的存储类型。存储类型决定了变量的创建、销毁时机。存储变量的位置一共三个地方：<strong>普通内存、运行时堆栈、硬件寄存器</strong>。结合C中的三种链接属性，具体可以分为：</p>
<ul>
<li><strong>栈区</strong>：代码块中的变量在一般情况下为自动变量（由高地址向低地址生长）</li>
<li><strong>堆区</strong>：由<code>malloc、realloc、calloc</code>等函数动态生成的变量。这些变量我们只能访问其地址，而且当我们不再使用之后需要收到去free掉（由低地址向高地址生长）。</li>
<li><strong>全局区／静态区</strong>：代码块之外声明的变量总是存储于静态内存中（默认的链接属性为external）。未初始化的变量放在一起，已经初始化的紧挨地放着。<br>由于函数实参总是在堆栈中进行传递，所以函数的形参不能设置为static。</li>
<li><strong>常量区</strong>：常量字符串</li>
<li><strong>代码区</strong></li>
</ul>
<blockquote>
<p>在代码块内部声明的变量的缺省存储类型是自动的，即它存储于堆栈中，称为<strong>自动变量</strong>。<br>如果代码块被多次执行，那么自动变量将会重复创建，每一次创建时，它们在内存中的位置可能会不同。</p>
</blockquote>
<p>至于上面提到的寄存器中的变量，因为CPU对于寄存器的读取速度非常快，通常编译器会将使用频率很高的变量将其移到寄存器中。如果寄存器变量在多线程编程时出现了问题，我们可能需要显式将该变量声明为<code>volatile</code>，让编译器不对该变量进行优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 全局静态区</div><div class="line"> */</div><div class="line">int a = 10;  /// external</div><div class="line">extern int b;/// external</div><div class="line">static int c;/// internal</div><div class="line">int d(int e)&#123;/// 函数d 默认为external</div><div class="line">    int f = 15;/// auto 栈区</div><div class="line">    static int g = 20;/// 静态变量 静态区</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int h(int i)&#123;/// 函数h 修改为static，internal</div><div class="line">    register int j;/// 寄存器类型，但是不一定起作用</div><div class="line">    int *k = malloc(sizeof(int));/// 堆区</div><div class="line">    free(k);</div><div class="line">    const int m = 25;/// 常量区</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="C中各个类型变量的内存管理"><a href="#C中各个类型变量的内存管理" class="headerlink" title="C中各个类型变量的内存管理"></a>C中各个类型变量的内存管理</h4><p>C语言中的内存管理与链接属性和所在内存区域都有直接关系。<strong>栈区</strong>的自动变量会在其作用域之后自动进行销毁；<strong>堆区</strong>的中由用户动态的创建的内存，需要手动调用<code>free</code>函数来释放（否则会造成内存泄漏）； <strong>全局区／静态区</strong>中的变量由系统创建和销毁，它们在程序开始运行之前就创建好，静态区的变量在程序运行过程中我们不能去修改； <strong>常量区</strong>程序结束后由系统释放。</p>
<blockquote>
<p>关于堆的一点儿说明：<br>如果我们在使用<code>malloc</code>和<code>free</code>时是无序的话，最终会产生堆碎片。<br>而且被分配的内存是经过对齐的，一般为2的乘方。</p>
</blockquote>
<p>堆的末端由一个称为<strong>break</strong>的指针来标识，当堆管理器需要更多内存时，它可以通过系统调用<code>brk</code>和<code>sbrk</code>来移动break指针。</p>
<hr>
<h2 id="OC与C的交互-bridge"><a href="#OC与C的交互-bridge" class="headerlink" title="OC与C的交互(__bridge)"></a>OC与C的交互(__bridge)</h2><p><img src="http://upload-images.jianshu.io/upload_images/619906-d75d32dc36154952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当oc在和c相关的函数（CoreFoundataion、Runtime）进行交互时，我们需要将OC的类型传递到C中，也需要将C中的数据返回给OC使用。这其中就需要使用它们类型之间的转换。在<code>id</code>类型或者对象变量赋值给<code>void *</code>或者逆向赋值时都需要进行特定的转换，单纯的赋值我们可以使用 <code>__bridge</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSObject *obj = [[NSObject alloc] init];</div><div class="line">void *p_obj = (__bridge void *)(obj);</div><div class="line">NSObject * r_obj = (__bridge NSObject *)(p_obj);</div></pre></td></tr></table></figure>
<p>相对于<code>__bridge</code>，我们可以使用<strong>``</strong>bridge_retained<code>修饰符，它即可以进行转换，也能持有被转换的对象__（上例中的</code>obj ``），因此该对象不会被废弃。其语法形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt;</div></pre></td></tr></table></figure>
<p><strong>bridge中还有个``</strong>bridge_transfer <code>，它的作用和__bridge_retained相反，被转换的变量（上例中的</code>p_obj <code>）所持有的对象（上例中的</code>obj <code>）会在</code>r_obj ``被赋值之后释放掉，其语法形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt;</div></pre></td></tr></table></figure>
<p>把上诉例子进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSObject *obj = [[NSObject alloc] init];</div><div class="line">void *p_obj = (__bridge_retained void *)(obj);</div><div class="line">NSObject * r_obj = (__bridge_transfer NSObject *)(p_obj);</div></pre></td></tr></table></figure>
<p>当我们在C语言的结构中，需要使用OC的类型作为结构成员，除了将OC的类型转换为<code>void *</code>之外，我们可以使用<code>__unsafe_unretained</code>修饰符（这个修饰符会在后面介绍）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/// 在C中使用OC的对象方式</div><div class="line">typedef struct rls_temp_ctx&#123;</div><div class="line">    NSObject __unsafe_unretained *obj;</div><div class="line">    void *target;</div><div class="line">&#125; rls_temp_context;</div><div class="line">/// 在C中传入OC对象</div><div class="line">rls_temp_context tmp_ctxs = &#123;</div><div class="line">    .obj = [NSObject new],</div><div class="line">    .target = (__bridge void *)(self)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是在使用<code>obj</code>时，由于<code>__unsafe_unretained</code>存在悬浮指针的问题，必须要判断该值是否存在。</p>
<hr>
<h2 id="OC内存管理"><a href="#OC内存管理" class="headerlink" title="OC内存管理"></a>OC内存管理</h2><p>前面看了C的内存管理，还看了C和OC的交互，最后就来看看在OC中内存管理应该注意的事项。<br>  现在我们讨论OC的内存管理是基于ARC的，其中对象变量的创建和释放问题和C的内存管理有点儿相似。大多数情况下系统会帮我们进行内存管理，我们只需要明确自己所声明的对象或者变量存在于什么区域（上面提到的内存区域），给它们添加合适的修饰符等等。<br>  大部分情况下，对于栈区、堆区、全局静态区的变量对象和C是相同的，我们可以类比来分析OC中对象或者变量的创建和释放时机。ARC中栈区用autoreleasepool管理的变量和C中的自动变量的内存管理时机很相似。<br>  在OC中使用基于C的函数时，通过<code>malloc</code>等函数声明的变量，都需要我们明确地调用<code>free</code>函数进行释放！抑或在使用CoreFondation、Runtime时，基本上如果遇到了包含有Copy， Create等关键字函数，在使用完成之后都需要手动释放内存。<br>2017-09-13更新：<br>当我们使用Runtime时，运用下面的方法来动态创建一个对象时，被创建的对象不会被释放，但是对应的<code>release</code>方法又是MRC时代的。所以我们可以使用如下方法来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// 创建对象</div><div class="line">id obj = ((id(*)(id,SEL))objc_msgSend)(((id(*)(id,SEL))objc_msgSend)([self class],@selector(alloc)),@selector(init));</div><div class="line">...</div><div class="line">...</div><div class="line">...</div><div class="line">/// 释放对象</div><div class="line">((id(*)(id,SEL))objc_msgSend)(obj,NSSelectorFromString(@&quot;release&quot;));</div></pre></td></tr></table></figure></p>
<h4 id="内存管理关键字"><a href="#内存管理关键字" class="headerlink" title="内存管理关键字"></a>内存管理关键字</h4><p>下面来介绍一下，在Objective-C的ARC中所涉及到的关键字。</p>
<ul>
<li><p>1、<code>__strong</code>为默认值，在声明成员变量和方法参数时也可以使用！</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__strong id obj_var = [[NSObject alloc] init];</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>作用：默认的行为。</strong></p>
<ul>
<li><p>2、<code>__weak</code>是不会持有对象实例，__weak修饰符可以避免循环引用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__weak id obj2 = nil;</div><div class="line">&#123;</div><div class="line">        __strong id obj_var = [[NSObject alloc] init];/// 自己生成对象并持有</div><div class="line">        obj2 = obj_var;/// obj2持有对象的弱引用</div><div class="line">        NSLog(@&quot;__weak %@&quot;,obj2);/// 此时由于在obj_var变量可用域中，obj2此时有值</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;__weak %@&quot;,obj2);/// 由于不在obj_var作用域之外，obj_var被释放。而且obj2是弱引用于obj_var的，所以此时obj2值为空</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>作用：避免循环引用，不持有对象实例</strong></p>
<ul>
<li><p>3、<code>__unsafe_unretained</code>修饰符的变量不属于编译器的内存管理对象。它和__weak类似，不会持有对象实例；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__unsafe_unretained id obj1 = nil;</div><div class="line">&#123;</div><div class="line">/// 在obj_var作用域内，__unsafe_unretained和__weak是一样的</div><div class="line">        __strong id obj_var = [[NSObject alloc] init];</div><div class="line">        obj1 = obj_var;</div><div class="line">        NSLog(@&quot;__unsafe_unretained %@&quot;,obj1);</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;__unsafe_unretained %@&quot;,obj1);/// 此时变量已经被遗弃，成为悬浮指针</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>在使用<code>__unsafe_unretained</code>修饰符时，赋值给<strong>strong修饰符的变量时，需要检查被赋值的对象是否存在（也就是被</strong>unsafe_unretained修饰的变量）</p>
</blockquote>
<p><strong>作用：在iOS4之前__weak的替代品，但是在将其赋值给其他时，最好做非空判断</strong></p>
<ul>
<li><p>4、<code>__autoreleasing</code>修饰符的变量替代调用MRC时代的<code>autorelease</code>方法，该对象会被注册到autoreleasepool中。以下是__autoreleasing修饰符的使用场景：</p>
<p>  1）、在生成对象时，编译器会检查方法名是否是以alloc/new/copy/mutablcopy开始（自己生成自由持有）。如果不是自己生成的则自动将返回值注册到autoreleasepool中。<br>2）、对象作为返回值时，编译器会自动将其注册到autoreleasing中。<br>3）、在使用<strong>weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。<br>4）、</strong>id的指针或者对象的指针(NSObject <strong>/NSError </strong>)在没有显示指定时会被附加上<code>__autoreleasing</code>修饰符__。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">BOOL result = [self performOperationWithError:&amp;error];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最后还是去看看<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">这套题</a>，它的解释对于理解内存的释放很有益处。对于这套题我已经推荐了几次了，哈哈哈。</p>
<h4 id="相关引用"><a href="#相关引用" class="headerlink" title="相关引用"></a>相关引用</h4><ul>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">ARC</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/619906-9ef7407a879ddf09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;  首先我们从最基本的C中三种链接属性，分别是：外部(external)、内部(internal)、无(none)。我们可以通过关键字&lt;code&gt;extern、static&lt;/code&gt;来修改变量的链接属性。&lt;br&gt;
    
    </summary>
    
      <category term="C、OC" scheme="http://yoursite.com/categories/C%E3%80%81OC/"/>
    
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从头认识GCD——相关函数的使用</title>
    <link href="http://yoursite.com/2017/07/29/gcd_func/"/>
    <id>http://yoursite.com/2017/07/29/gcd_func/</id>
    <published>2017-07-29T10:33:38.000Z</published>
    <updated>2017-07-29T10:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/619906-d284587e19456111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  在上一篇文章中，我们对GCD有了基本的认知，知道其中一些简单的类型，和一些简单函数。这本篇文章中，我们将继续学习GCD中我们在日常开发中使用较多的函数，及其使用方法。在本篇会介绍<strong>dispatch_after、dispatch_apply、dispatch_group_t、dispatch_semaphore_t和dispatch_barrier</strong>等相关函数。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a><a id="more"></a> </h2><h3 id="dispatch-after／dispatch-time-t"><a href="#dispatch-after／dispatch-time-t" class="headerlink" title="dispatch_after／dispatch_time_t"></a>dispatch_after／dispatch_time_t</h3><p>我先来说说<code>dispatch_after</code>，从某种意义上来说，它属于任务提交的一种方式。在刚刚接触iOS开发的时候，我一直在想“ 对于<code>dispatch_after</code>它是同步提交代码块还是异步提交的代码块的呢？ ”。后来看到Apple的文档中说到”This function waits until the specified time and then asynchronously adds block to the specified queue”，也就是说它的延迟执行，并不是马上就将代码块就提交到指定的队列中，而是<strong>等到指定的时间通过异步的方式将提其提交到指定的队列中去</strong>。因此从这段话中也可以看出它仅仅是<code>dispatch_async</code>的一种。该函数的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>到这里就需要来系统地说一说<code>dispatch_after</code>函数的第一个参数，一个<code>dispatch_time_t</code>类型的变量。<code>dispatch_time_t</code>实际是<code>uint64_t</code>类型。系统为该类型定义了两个特殊值，分别是<strong>DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER</strong>，其中<code>DISPATCH_TIME_NOW</code>表示值为0，而<code>DISPATCH_TIME_FOREVER</code>表示为无穷大（infinity）。除了这两个特殊值之外，我们可以使用函数<code>dispatch_time()</code>来创建相对于默认时钟的时间；或者使用<code>dispatch_walltime()</code>函数获取绝对时间。<br>对于<code>dispatch_time()</code>函数，第一个参数我们传入DISPATCH_TIME_NOW或者DISPATCH_TIME_FOREVER值。</p>
<blockquote>
<p><code>dispatch_time()</code>函数第二个参数接受的是<strong> 基于纳秒级别的数值 </strong>。</p>
</blockquote>
<p>这时候就需要将具体的数字乘以一个常数，在<a href="https://developer.apple.com/documentation/dispatch/dispatch_time_multiplier_constants?language=objc" target="_blank" rel="external">官方文档</a>中列出了相关的常数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">常数</th>
<th style="text-align:left">意义</th>
<th style="text-align:left">具体数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NSEC_PER_SEC</td>
<td style="text-align:left">表示一秒能转换成多少纳秒</td>
<td style="text-align:left"><code>1000000000ull</code></td>
</tr>
<tr>
<td style="text-align:left">USEC_PER_SEC</td>
<td style="text-align:left">表示一秒能转换成多少微秒</td>
<td style="text-align:left"><code>1000000ull</code></td>
</tr>
<tr>
<td style="text-align:left">NSEC_PER_USEC</td>
<td style="text-align:left">表示一微秒转换成多少纳秒</td>
<td style="text-align:left"><code>1000ull</code></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// 使用相对时间，相对于现在延迟五秒</div><div class="line">dispatch_time_t time_t = dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time_t, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Run&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果我们想要该代码块延迟到某一指定时刻去执行，我们只需要去修改<code>dispatch_after</code>中的<code>dispatch_time_t</code>类型中值，在这里我们使用函数<code>dispatch_walltime</code>来获取绝对的时间戳值。<code>dispatch_walltime()</code>函数的一个参数是<code>struct timespec</code>类型的一个变量，它是一个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_STRUCT_TIMESPEC</div><div class="line">&#123;</div><div class="line">	__darwin_time_t  tv_sec;</div><div class="line">	long  tv_nsec;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>分别为秒和纳秒。<strong>timespec是基于纳秒级别的数值</strong>，关于<code>dispatch_walltime</code>具体是方式之一如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/// 延迟到某一绝对时刻执行</div><div class="line">struct timespec __tp;</div><div class="line">double sec, n_sec;</div><div class="line">n_sec = modf(1500794750.797543543, &amp;sec);</div><div class="line">__tp.tv_sec = sec;</div><div class="line">__tp.tv_nsec = n_sec;</div><div class="line">dispatch_after(dispatch_walltime(&amp;__tp, 0), dispatch_get_main_queue(), ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上诉代码要等到时间戳为<code>1500794750</code>时才会将代码块提交到指定的事件队列中。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p><strong><em>dispatch_apply</em></strong>是<code>dispatch_sync</code>函数配合不同的的<code>dispatch_queue_t</code>队列，来循环执行任务。</p>
<blockquote>
<p>如果在<code>dispatch_apply</code>函数中传入的是一个并发队列，那么block中的任务就可以被并发的调用！相对于一般的for循环来说要高效许多。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, apply_queue, ^(size_t index) &#123;</div><div class="line">        NSLog(@&quot;%zd&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;End&quot;);</div></pre></td></tr></table></figure>
<p>结果如下<code>0, 2, 3, 1, 4, End</code>。但是我们将上面的并发队列改成串行队列之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, apply_queue, ^(size_t index) &#123;</div><div class="line">        NSLog(@&quot;%zd&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;End&quot;);</div></pre></td></tr></table></figure>
<p>返回的结果<code>0, 1, 2, 3, 4, End</code>和正常的for循环没有什么差距。但是不管是在并发的队列还是在串行的队列中，<code>End</code>总是最后才打印的。</p>
<h3 id="dispatch-group-t相关函数"><a href="#dispatch-group-t相关函数" class="headerlink" title="dispatch_group_t相关函数"></a>dispatch_group_t相关函数</h3><p>使用dispatch_group可以把许多操作进行合并。在将多个任务block提交之后，我们可以在dispatch_group中获取到这些操作全部完成的时间（不管是串行执行还是并行执行）。<br>现在我们有一个场景：第一步，我们需要将多个本地资源传递给服务器。我们用<code>dispatch_group</code>相关的技术来实现这个需求。创建一个<code>dispatch_group_t</code>类型的变量实现非常简单，不像其他GCD函数需要一些其他的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div></pre></td></tr></table></figure>
<p>当创建好了dispatch_group之后，我们需要将这些任务进行提交，这里我使用上一节的<code>dispatch_apply</code>来将多个任务放在并发的队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;</div><div class="line">  /// 模拟网络请求</div><div class="line">    NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在大部分的应用中的上传请求，都有一个上传完成的标志。第二步，那么在这个场景中我们如何知道所有图片已经上传成功呢？我们使用同步的方式，用户的交互不起作用，静静地等待上传完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_wait(upload_group, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;Upload Complete&quot;);</div></pre></td></tr></table></figure>
<p><code>dispatch_group</code>的管理是基于计数来做的。<code>dispatch_group_enter</code>会增加该Group内部的任务计数，<code>dispatch_group_leave</code>会减少该Group中未完成的计数，它们两个函数必须配对使用。<br><code>dispatch_group_wait</code>函数和我们在上一篇文中讲到的<code>dispatch_block_wait</code>函数功能类似，只不过<code>dispatch_group_wait</code>是针对多个block的<strong>同步方法</strong>，它会等到Group中所有的任务执行完毕之后才会去继续执行后面的内容。<br>  既然上面提到了<code>dispatch_group_wait</code>函数对应<code>dispatch_block_wait</code>函数，那么很明显应该存在<code>dispatch_block_notify</code>函数对应的Group函数。我们将上面的函数进行稍加改动，将同步的方式改为异步的方式，让用户能够做其他的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Upload Complete&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  其实相对于使用繁琐的<code>dispatch_group_enter、dispatch_group_leave</code>，Apple给我们提供了更为简单的函数<code>dispatch_group_async</code>。我这样做的目的是为了在一开始就能让我们清楚，在Group内部是什么在决定着<code>dispatch_group_wait 、dispatch_group_notify</code>的触发时机，我们还是对上面的例子进行稍加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_async(upload_group, upload_queue, ^&#123;</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Upload Complete&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>很明显对于使用<code>dispatch_group_async</code>给我们带来便利的同时，在灵活性上也就出现缺失，再者就是在用Group做同步的时候使用<code>dispatch_group_enter、dispatch_group_leave</code>是更好的选择！</p>
<h3 id="dispatch-semaphore-t相关函数"><a href="#dispatch-semaphore-t相关函数" class="headerlink" title="dispatch_semaphore_t相关函数"></a>dispatch_semaphore_t相关函数</h3><p>在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来（来自<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99" target="_blank" rel="external">维基百科</a>）。通俗一点儿讲就是说在进程内部有一原子递增和递减的计数器（也就是该数据变量<strong>具有原子性</strong>）。<br>如果触发了某个操作使得信号量小于等于0，那么该操作将会被阻塞，直到其信号量大于0。上面提到过，信号量是基于进程的。所以：</p>
<blockquote>
<p>信号量不依赖于任何队列，它可以在任何线程中使用。</p>
</blockquote>
<p>在GCD中，函数<code>dispatch_semaphore_signal</code>增加信号量计数，如果之前信号量计数小于等于0，该函数会唤醒当前正在等待的线程。相反，函数<code>dispatch_semaphore_wait</code>会减少信号量计数，如果当该信号量计数小于或者等于0之后，会阻塞当前线程，等待其他操作来增加信号量计数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)downloadSync&#123;</div><div class="line">    NSMutableArray *contents = [NSMutableArray array];</div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line">    </div><div class="line">    dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">    dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.download.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">    dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;</div><div class="line">            NSString *cts = [NSString stringWithFormat:@&quot;%zd&quot;,index];</div><div class="line">            NSLog(@&quot;~ %@ ~&quot;,cts);</div><div class="line">            [contents addObject:cts];</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    return contents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在来看看上面这个方法可以正常的返回吗？除了<code>dispatch_semaphore_t</code>相关的代码，我都是直接从上面拷贝下来，没有做任何修改。当我跑起来之后，始终方法<code>downloadSync</code>不会返回，这里很明显的是造成了死锁的问题！由于<code>dispatch_semaphore_wait</code>函数会阻塞当前线程（它此时是处于主线程中），<code>dispatch_group_notify</code>函数的任务线程即为主线程对应的主任务队列。<code>dispatch_semaphore_wait</code>需要等到函数<code>dispatch_semaphore_signal</code>来增加信号量计数之后才会继续执行主线程，而<code>dispatch_group_notify</code>又要在主线程中执行（由于主线程被阻塞）之后才能去调用<code>dispatch_semaphore_signal</code>函数，因此就造成了死锁，程序永远不会继续执行！。<br>解决办法也很简单，将<code>dispatch_semaphore_signal</code>放在一个并行的任务队列中进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_group_notify(upload_group, dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0), ^&#123;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面使用信号量的相关函数，实现了异步转同步的需求。</p>
<h3 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier"></a>dispatch_barrier</h3><p><code>dispatch_barrier</code>的作用是在并发队列中实现同步操作。在并发队列中，任务的提交顺序会影响到执行顺序，当异步提交的任务在<code>dispatch_barrier</code>之后，该任务需要等到<code>dispatch_barrier</code>提交的任务执行完成之后才会开始执行。<br>把上面的话用下面的图通俗的来解释一下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-c458370900934975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用下面的伪代码来实现一下上图中的相关任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_async(task_queue, task_1);</div><div class="line">dispatch_async(task_queue, task_2);</div><div class="line">dispatch_async(task_queue, task_3);</div><div class="line">dispatch_barrier_async(task_queue, task_4);</div><div class="line">dispatch_async(task_queue, task_5);</div></pre></td></tr></table></figure>
<p><strong>函数<code>dispatch_barrier_async</code>中block参数，会被目标队列复制并持有，直到任务完成时被释放</strong>。官方文档中提到：</p>
<blockquote>
<p>目标队列必须是用户手动创建的并发队列，如果传入的是串行队列或者是全局并发队列，那么这个函数就和<code>dispatch_async</code>类似。</p>
</blockquote>
<p><code>dispatch_barrier_sync</code>在做同步操作时和<code>dispatch_barrier_async</code>效果类似，但是它必须得等到block任务完成之后才会返回！而且<code>dispatch_barrier_sync</code>函数的目标线程不会复制和持有block。</p>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>在这篇文章的最后以<code>dispatch_once</code>来做一个结尾，对于<code>dispatch_once</code>我们iOS开发者用的太多了。<strong>该函数在多线程环境下同样也是安全的</strong>，如果是在多线程中进行调用，它会同步地等待block任务执行完成！官方文档中提出：对于<code>dispatch_once</code>函数的</p>
<blockquote>
<p>第一个参数必须是存储在全局区或者静态区的变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t predicate;</div><div class="line">dispatch_once(&amp;predicate, ^&#123;</div><div class="line">  ...        </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>关于dispatch_once更多的文章见<a href="https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html" target="_blank" rel="external">dispatch_once</a>，以及对应的源码<a href="https://github.com/apple/swift-corelibs-libdispatch/blob/master/src/once.c" target="_blank" rel="external">once.c</a>。第三篇文章会在后面放出来，我准备写关于<code>dispatch_source</code>和<code>dispatch_data</code>以及<code>dispatch_io</code>等相关知识。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>根据文中出现顺序</p>
<ul>
<li><a href="https://apple.github.io/swift-corelibs-libdispatch/" target="_blank" rel="external">Apple Dispatch Github</a></li>
<li><a href="https://developer.apple.com/documentation/dispatch/dispatch_time_multiplier_constants?language=objc" target="_blank" rel="external">Dispatch Time Multiplier Constants</a></li>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="external">Elapsed Time</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99" target="_blank" rel="external">信号量</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/619906-d284587e19456111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;  在上一篇文章中，我们对GCD有了基本的认知，知道其中一些简单的类型，和一些简单函数。这本篇文章中，我们将继续学习GCD中我们在日常开发中使用较多的函数，及其使用方法。在本篇会介绍&lt;strong&gt;dispatch_after、dispatch_apply、dispatch_group_t、dispatch_semaphore_t和dispatch_barrier&lt;/strong&gt;等相关函数。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>从头认识GCD——派发队列基础</title>
    <link href="http://yoursite.com/2017/07/29/gcd_basic/"/>
    <id>http://yoursite.com/2017/07/29/gcd_basic/</id>
    <published>2017-07-29T10:33:29.000Z</published>
    <updated>2017-07-29T11:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/619906-27e0e0084cc378cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  本文包括了从最基础的获取任务队列开始，配置任务队列，创建任务，提交任务一步一步地来复习GCD中所涉及到的知识。（建议在PC端浏览）<br>  <a id="more"></a><br>  包括使用较少的<code>dispatch_qos_class_t 、dispatch_block_t</code>等等知识点。<br>  GCD任务队列能够让开发者能够更加专注于同步或者异步任务task，而不用把重点放在创建线程和具体同步和加锁等相关操作。但是如果我们想异步做更加灵活的任务的话（比如后台任务之类的），那选择线程肯定是更好的选择。毕竟操作简单带来就是灵活性的确实嘛！首先先来看看派发队列。<br>  当用户向某一线程提交一个task时，<strong>_dispatch_queue<em>t</em></strong>作为任务队列以用户期望的方式来管理这些task。 管理的任务的方式有两种类型，分别是串行队列(<code>DISPATCH_QUEUE_SERIAL</code>)和并行队列(<code>DISPATCH_QUEUE_CONCURRENT</code>)，它们两个是由宏定义的。 <br></p>
<hr>
<h4 id="一、获取任务队列"><a href="#一、获取任务队列" class="headerlink" title="一、获取任务队列"></a>一、获取任务队列</h4><p>现在问题来了，我们既然知道有这么一个类型了，那我们总要有方式来得到它啊是吧。就目前而言，Apple给我们提供获取该类型变量的方式有三种，分别是：</p>
<ul>
<li><p><strong><em><a href="https://developer.apple.com/documentation/dispatch/1452921-dispatch_get_main_queue?language=objc" target="_blank" rel="external">dispatch_get_main_queue</a></em></strong>：程序主线程的任务队列，这是一个串行队列（<code>DISPATCH_QUEUE_SERIAL</code>）。在程序<code>main()</code>函数被调用之前由系统自动创建。在官方文档中还提到了，我们可以主动去执行被添加到<code>main_queue</code>的任务task（也就是说我们可以主动来调用添加到主线程队列的<strong>block</strong>）。三个方法分别是：<code>dispatch_main()、UIApplicationMain 、CFRunLoopRun()</code>，选用其中一个。我尝试了一下使用<code>dispatch_main()</code>会导致程序中断。</p>
</li>
<li><p><strong><em><a href="https://developer.apple.com/documentation/dispatch/1452927-dispatch_get_global_queue?language=objc" target="_blank" rel="external">dispatch_get_global_queue</a></em></strong>：由系统定义并管理的一个全局并行队列。在获取时，我们需要指定任务队列的系统等级（DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND）。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但是在iOS8以后，使用枚举<code>qos_class_t</code>的值，提供了细粒度更高的全局任务队列，关于QOS在后面统一梳理一下。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>该函数的返回值上使用<code>dispatch_resume、dispatch_suspend</code>无效，</p>
</blockquote>
<ul>
<li><p><strong><em>dispatch_queue_create</em></strong>：除了上诉系统提供的两种类型的任务队列之外，我们还可以自己去创建任务队列。我们可以自己创建串行（<code>DISPATCH_QUEUE_SERIAL</code>）和并行（<code>DISPATCH_QUEUE_CONCURRENT</code>）两种类型的队列，但是它们都有一个变种DISPATCH_QUEUE_SERIAL_INACTIVE, DISPATCH_QUEUE_CONCURRENT_INACTIVE。它们同样会有涉及到QOS的创建方法，后面一起记录一下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上诉三种就是获得任务队列方法，我们在设置<code>dispatch_ge_global_queue</code>的第二个参数时一般设置为<strong><em>0</em></strong>。上面这三种方式是我们在日常开发中，使用并发编程时通过GCD的方式来获取任务队列的方法。<strong>在大部分时间使用并行的任务队列时，<code>global_queue</code>能够基本满足需求；对于我来说创建线程的场景，主要是当我们需要一个串行的任务，但是又不想在主线程去执行时使用</strong>。既然我在上面提到了QOS，下面我们就系统的来认识一下QOS。</p>
<h4 id="二、通过QOS配置队列"><a href="#二、通过QOS配置队列" class="headerlink" title="二、通过QOS配置队列"></a>二、通过QOS配置队列</h4><p>  由于在我们的程序中，存在各种各样的场景，比如用户界面刷新，网络请求，资源下载，缓存存取之类的。为了能够保证程序的高效响应，需要对不同的任务对资源的消耗做出一些调整。<br>此时我们就可以使用QOS来解决不同任务的资源分配问题，QOS可以用于<code>dispatch_queue, NSOperation, NSOperationQueue, NSThread ,pthreads</code>中，这篇文章中主要讲一下在<strong><em>dispatch_queue</em></strong>中的使用场景。</p>
<blockquote>
<p>在官方文档中也说，关于QOS的只能在iOS8以后使用</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">QOS_CLASS</th>
<th style="text-align:left">执行时机</th>
<th style="text-align:center">相关使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>USER_INTERACTIVE</strong></td>
<td style="text-align:left">必须是要及时处理</td>
<td style="text-align:center">等级最高。主要用户用户交互，比如主线程上的刷新用户界面等等。</td>
</tr>
<tr>
<td style="text-align:left"><strong>USER_INITIATED</strong></td>
<td style="text-align:left">需要很快完成工作</td>
<td style="text-align:center">它主要用于比如已经开了一个任务，此时需要立刻执行的场景。意思就是说需要瞬间完成的工作</td>
</tr>
<tr>
<td style="text-align:left">❌ DEFAULT</td>
<td style="text-align:left">——</td>
<td style="text-align:center">这个我们一般不使用，<code>dispatch_get_global_queue</code>就是这一等级。</td>
</tr>
<tr>
<td style="text-align:left"><strong>UTILITY</strong></td>
<td style="text-align:left">可能需要相当长一段时间</td>
<td style="text-align:center">不需要及时响应，比如下载操作之类的，但是用户是可以看见进度之类的</td>
</tr>
<tr>
<td style="text-align:left"><strong>BACKGROUND</strong></td>
<td style="text-align:left">长时间类型任务</td>
<td style="text-align:center">完全是后台执行，用户不知道进度的</td>
</tr>
<tr>
<td style="text-align:left">❌ UNSPECIFIED</td>
<td style="text-align:left">——</td>
<td style="text-align:center">开发人员没有指定，系统根据情况进行选定QOS等级</td>
</tr>
</tbody>
</table>
<p>上诉QOS对应OC参数如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">QOS-Class</th>
<th style="text-align:left">对应OC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">USER_INTERACTIVE</td>
<td style="text-align:left">NSQualityOfServiceUserInteractive</td>
</tr>
<tr>
<td style="text-align:left">USER_INITIATED</td>
<td style="text-align:left">NSQualityOfServiceUserInitiated</td>
</tr>
<tr>
<td style="text-align:left">UTILITY</td>
<td style="text-align:left">NSQualityOfServiceUtility</td>
</tr>
<tr>
<td style="text-align:left">BACKGROUND</td>
<td style="text-align:left">NSQualityOfServiceBackground</td>
</tr>
</tbody>
</table>
<p>在dispatch_queue中，如果我们想要指定QOS的等级的话，我们可以使用函数<a href="https://developer.apple.com/documentation/dispatch/1453028-dispatch_queue_attr_make_with_qo" target="_blank" rel="external">dispatch_queue_attr_make_with_qos_class</a>。在创建任务队列时使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_attr_t attr_qos = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INTERACTIVE, 0);</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, attr_qos);</div></pre></td></tr></table></figure>
<p>因为 <strong>QOS对于<code>dispatch_queue</code>来说是无法变更的属性</strong>，以致于我们无法去更改已存在任务队列的QOS属性。但是我们可以使用<code>dispatch_queue_get_qos_class</code>函数来获取任务队列的QOS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_qos_class_t qos_class = dispatch_queue_get_qos_class(the_queue, 0);</div><div class="line">/// 一般用于 根据已知队列来获取同qos等级的全局任务队列</div><div class="line">dispatch_get_global_queue(dispatch_queue_get_qos_class(the_queue, nil), 0);</div><div class="line">/// 或者是 根据已知的全局任务队列来创建与其qos相等的任务队列</div><div class="line">dispatch_queue_t the_global = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);</div><div class="line">dispatch_queue_t the_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, dispatch_queue_get_qos_class(the_global, 0), 0));</div></pre></td></tr></table></figure>
<p>当我们要获取全局队列时，在此之前可以使用<code>DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>。现在我们可以使用QOS来获取一个全局的并发任务队列，因此我们有必要来了解一下它们之间的差异和共性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">以前</th>
<th style="text-align:left">现在QOS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Main Thread</td>
<td style="text-align:left">QOS_CLASS_USER_INTERACTIVE</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td style="text-align:left">QOS_CLASS_USER_INITIATED</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td style="text-align:left">QOS_CLASS_DEFAULT</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_LOW</td>
<td style="text-align:left">QOS_CLASS_UTILITY</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td style="text-align:left">QOS_CLASS_BACKGROUND</td>
</tr>
</tbody>
</table>
<p>具体使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0);</div></pre></td></tr></table></figure>
<p> 除此之外，我们还可以在<code>dispatch_block</code>中对每一个人任务块来设置Qos等级，这里我先将<code>dispatch_block</code>提出来，后面我会对其进行较为详细的解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t the_block = dispatch_block_create_with_qos_class(0, QOS_CLASS_UTILITY, -8, ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div><div class="line">dispatch_async(the_queue, the_block);///dispatch_sync, dispatch_after等等需要用到dispatch_block的地方</div></pre></td></tr></table></figure>
<h4 id="三、创建任务"><a href="#三、创建任务" class="headerlink" title="三、创建任务"></a>三、创建任务</h4><p>  前面两点说了任务的执行地点和怎样来创建和配置任务的执行地点，但是我们必须得知道任务是什么？怎么创建任务？在GCD中使用block来作为任务提交给特定的任务队列，例如<strong>_dispatch_block<em>t</em></strong>或者直接是一个简单的block。<br>对于<code>dispatch_block_t</code>类型的变量，首先我们得要知道怎么去创建它。首先根据我们的尝试（下面的例子出自<a href="https://developer.apple.com/documentation/dispatch/dispatch_block_t" target="_blank" rel="external">Apple官方</a>），对block进行直接赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t error_block;</div><div class="line">NSInteger x = 0;</div><div class="line">if (x) &#123;</div><div class="line">        error_block = ^void(void)&#123;</div><div class="line">            NSLog(@&quot;TRUE&quot;);</div><div class="line">        &#125;;</div><div class="line">&#125;else&#123;</div><div class="line">        error_block = ^void(void)&#123;</div><div class="line">            NSLog(@&quot;FALSE&quot;);</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line">error_block();/// unsafe</div></pre></td></tr></table></figure>
<p>  官网中解释到：“ 由于该<code>dispatch_block_t</code>变量是在栈内存上声明的，如果执行过该变量作用域之后就有可能导致该变量被释放 ”。到这里我们还是不得不提一下<code>block</code>在MRC和ARC下的区别，我们先看一篇<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">测试</a>，在这篇测试中很明显的一个点便是：“ MRC中有NSStackBlock类型，NSMallocBlock类型，NSGlobalBlock类型同时存在。但是在ARC中不再存在NSStackBlock类型，而是直接声明为NSMallocBlock类型” 。也就是说在ARC中就算是在函数方法中声明的block变量也是被声明为NSMallocBlock类型。<br>  NSMallocBlock类型就不存在上诉官网中提到的变量被提前释放的问题，这一步我并没有去实践，所以上诉结论是否为真，既然官方不建议这么做，那便放弃使用该方法。使用一下两种方式来创建<code>dispatch_block_t</code>变量：</p>
<ul>
<li><strong><em>dispatch_block_create</em></strong></li>
<li><strong><em>dispatch_block_create_with_qos_class</em></strong></li>
</ul>
<p>当我们在使用上诉两种方法来创建<code>dispatch_block_t</code>变量时，遇到的第一个便是<code>dispatch_block_flags_t</code>参数。它是一个枚举类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">枚举类型</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_ASSIGN_CURRENT</strong></td>
<td style="text-align:left">说明该块会被分配在创建该对象的上下文中（直接执行该块对象时推荐使用）</td>
</tr>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_BARRIER</strong></td>
<td style="text-align:left">类似于在做同步操作时的<code>barrier</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_DETACHED</strong></td>
<td style="text-align:left">表明dispatch_block与当前的执行环境属性无关</td>
</tr>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_ENFORCE_QOS_CLASS</strong></td>
<td style="text-align:left">当dispatch_block提交到队列或者直接提交执行做同步操作时，该值是默认值</td>
</tr>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_INHERIT_QOS_CLASS</strong></td>
<td style="text-align:left">异步执行的默认值，优先级低于<code>DISPATCH_BLOCK_ENFORCE_QOS_CLASS</code>。可以用该值来覆盖原来QOS类</td>
</tr>
<tr>
<td style="text-align:left"><strong>DISPATCH_BLOCK_NO_QOS_CLASS</strong></td>
<td style="text-align:left">表明dispatch_block不分配QOS类</td>
</tr>
</tbody>
</table>
<p>来创建<code>dispatch_block</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/// 第一种使用QOS的方式来创建dispatch_block</div><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;RUN&quot;);</div><div class="line">&#125;);</div><div class="line">/// 直接创建dispatch_block</div><div class="line">dispatch_block_create(DISPATCH_BLOCK_NO_QOS_CLASS, ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对于<code>dispatch_block_create_with_qos_class</code>方法中relative_priority的参数的规则是：<code>relative_priority</code>的值需要在0到<code>QOS_MIN_RELATIVE_PRIORITY</code>（-15）之间。<br>  我们<strong>创建的block会被拷贝到堆上，并由<code>dispatch_block_t</code>类型的变量所持有</strong>。创建完成之后，我们可以将其提交到对应的任务队列中（下一节提到的dispatch_async等等函数…），也可以直接去执行（比如：task_block()）。<br>  既然可以直接去输入一个block块，那为什么我们还需要去使用<code>dispatch_block_t</code>？存在即有价值，那么最明显的优势便是：我们可以对该任务块执行<strong>取消操作</strong>！例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;RUN&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), task_block);</div><div class="line">dispatch_block_cancel(task_block);</div></pre></td></tr></table></figure>
<p>但是<strong>如果dispatch_block已经开始执行，便无法取消该任务的执行</strong>。比如下面的例子中，我们对上面的代码进行一点小小的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;RUN&quot;);/// 成功执行</div><div class="line">        /// 模拟一个长时间的耗时任务</div><div class="line">        [NSThread sleepForTimeInterval:3];</div><div class="line">        NSLog(@&quot;End&quot;);/// 成功执行</div><div class="line">&#125;);</div><div class="line">dispatch_async(dispatch_get_main_queue(), task_block);</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        /// 保证dispatch_block_t已经开始执行</div><div class="line">        dispatch_block_cancel(task_block);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这里我们是无法去取消已经执行的块。<code>dispatch_block_testcancel</code>函数的作用是让我们能够知道当前任务块是否已经被取消。</p>
<blockquote>
<p>在调用<code>dispatch_block_cancel</code>函数时，我们必须要确定即将被cancle的块没有捕获任何其他外部变量，如果持有将会造成内存泄漏。</p>
</blockquote>
<p>  除此之外我们来认识一下<strong><em>dispatch_block_wait</em></strong> 函数，它的作用是以同步的方式执行并等待，得等待指定的任务块执行完成之后，抑或者是超时之后然后去执行当前线程的后续任务。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;Start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:3];</div><div class="line">        NSLog(@&quot;End&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dispatch_get_main_queue(), task_block);</div><div class="line">NSLog(@&quot;Before Wait&quot;);</div><div class="line">dispatch_block_wait(task_block, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;After Wait&quot;);</div></pre></td></tr></table></figure>
<p>此时运行并不会得到<code>Start</code>。由于<code>dispatch_block_wait</code>函数是使用的同步的方式，只要是在该线程的执行流中，它不管你是同步提交还是异步提交（这两种提交方式在下面一节马上会讲）的方式，<code>dispatch_block_wait</code>函数如果是在被执行的block之前执行，后续的代码都会被挂起，并不仅仅是<code>dispatch_block_wait</code>函数后的代码，也包括block中的代码。因此也就导致了在同一个任务队列中（都处于main_queue中）的<code>dispatch_block_t</code>永远不会执行。解决办法也很简单，第一种我们先让block执行起来；第二种我们让它们处在不同队列中即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;Start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:3];</div><div class="line">        NSLog(@&quot;End&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_queue_t block_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_async(block_queue, task_block);</div><div class="line">NSLog(@&quot;Before Wait&quot;);</div><div class="line">dispatch_block_wait(task_block, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;After Wait&quot;);</div></pre></td></tr></table></figure>
<p>我们可以利用这个方法来做由异步转同步的需求（后面还会介绍<code>dispatch_semaphore_t</code>，它同样可以达到这个效果）。<br>  最后来看一下函数<strong>_dispatch_block<em>notify</em></strong>，它的作用是当指定的<code>dispatch_block_t</code>变量执行完了之后，通知到给特定的任务队列。在上面的例子中，我们在<code>block_queue</code>中去执行了我们的任务块，但是我们想要在它执行完了以后在<code>main_queue</code>中来执行相关的操作，比如我们需要在<code>main_queue</code>中更新UI界面之类的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123;</div><div class="line">        NSLog(@&quot;Start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:3];</div><div class="line">        NSLog(@&quot;End&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_queue_t block_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_async(block_queue, task_block);</div><div class="line">dispatch_block_notify(task_block, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Notify&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="四、将任务提交到队列"><a href="#四、将任务提交到队列" class="headerlink" title="四、将任务提交到队列"></a>四、将任务提交到队列</h4><p>  在文章的最后，我们来看看怎样把已经创建好的任务提交到特定的任务队列中去！对于提交操作主要涉及到的函数有：<strong>dispatch_async、dispatch_sync、dispatch_block_perform、dispatch_group_async、dispatch_barrier_async、dispatch_barrier_sync</strong>。在这篇文章中先讲前面三个。再后面文章中详解dispatch_group_t、dispatch_barrier时在进行对应的学习。<br>  <code>dispatch_async</code>使用异步地方式去提交任务块，何为异步？异步方法调用它通过使用一种立即返回的异步的变体并提供额外的方法来支持接受完成通知以及完成等待改进长期运行的(同步)方法（出自<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" target="_blank" rel="external">维基百科</a>）。<code>dispatch_sync</code>使用同步的方式取提交任务块。下图是根据我自己的理解来解释了一下异步和同步的差异性。<br></p>
<p><img src="http://upload-images.jianshu.io/upload_images/619906-601bf2002a932ad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步和同步的对比"><br>上诉函数分别有对应的版本，分别是<code>dispatch_async_f、dispatch_sync_f</code>。它们两个和前面的区别在于，这两个函数不使用block的方式，而是使用C函数指针的方式来执行任务。它们中的<strong>context</strong>是以<code>void *</code>类型的变量作为参数，传递给函数指针指向的具体函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/// 异步使用block</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div><div class="line">/// 同步使用block</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div><div class="line">/// 异步使用函数指针</div><div class="line">dispatch_async_f(dispatch_get_main_queue(),  (__bridge void * _Nullable)(self), task_place);</div><div class="line">void task_place(void *data)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">/// 同步使用函数指针</div><div class="line">dispatch_sync_f(block_queue, (__bridge void * _Nullable)(self), task_place);</div><div class="line">void task_place(void *data)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们来看看本应属于<code>dispatch_block_t</code>中应该讲解的函数<code>dispatch_block_perform</code>，但是它作为一个提交任务的函数，放在这里讲我觉得要更为合适一点。它会创建一个<code>dispatch_block_t</code>变量，并在该任务队列中以同步的方式来执行block中的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_block_perform(DISPATCH_BLOCK_BARRIER, ^&#123;</div><div class="line">        NSLog(@&quot;Start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:3];</div><div class="line">        NSLog(@&quot;End&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码以下代码效果一样（取自<a href="https://developer.apple.com/documentation/dispatch/1431048-dispatch_block_perform?language=objc" target="_blank" rel="external">Apple官方文档</a>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t b = dispatch_block_create(flags, block);</div><div class="line">b();</div><div class="line">Block_release(b);</div></pre></td></tr></table></figure>
<p>但是<code>dispatch_block_perform</code>方法可以以更加高效的方式来进行以上步骤，而不需要在对象分配时将block拷贝到指定堆中。<br>  到这里把最基础的部分算是走了一遍，可以说是走了最小的一步，但是本文的目的是力求以清晰地路线把每一步所涉及到的知识深挖严查。在后续的文章中会继续介绍GCD中的其他函数和相关的使用方法。</p>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><p>以文章中出现顺序：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW1" target="_blank" rel="external">Prioritize Work with Quality of Service Classes</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW17" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">Objective-C Blocks Quiz</a></li>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8" target="_blank" rel="external">异步调用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/619906-27e0e0084cc378cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;  本文包括了从最基础的获取任务队列开始，配置任务队列，创建任务，提交任务一步一步地来复习GCD中所涉及到的知识。（建议在PC端浏览）&lt;br&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>最大堆（创建、删除、插入和堆排序）</title>
    <link href="http://yoursite.com/2017/05/09/data_struct_max_heap/"/>
    <id>http://yoursite.com/2017/05/09/data_struct_max_heap/</id>
    <published>2017-05-09T14:20:26.000Z</published>
    <updated>2018-05-18T15:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>  什么是最大堆和最小堆？最大（小）堆是指在树中，存在一个结点而且该结点有儿子结点，该结点的data域值都不小于（大于）其儿子结点的data域值，并且它是一个完全二叉树（不是满二叉树）。<br><a id="more"></a><br>  注意区分选择树，因为<strong><em>选择树（selection tree）</em></strong>概念和最小堆有些类似，他们都有一个特点是<strong><em>“树中的根结点都表示树中的最小元素结点”</em></strong>。同理最大堆的根结点是树中元素最大的。那么来看具体的看一下它长什么样？（最小堆这里省略）<br><img src="http://upload-images.jianshu.io/upload_images/619906-6866218c0158cfdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-1"></p>
<blockquote>
<p>这里需要注意的是：在多个子树中，并不是说其中一个子树的父结点一定大于另一个子树的儿子结点。最大堆是树结构，而且一定要是完全二叉树。</p>
</blockquote>
<h4 id="最大堆ADT"><a href="#最大堆ADT" class="headerlink" title="最大堆ADT"></a>最大堆ADT</h4><p>那么我们在做最大堆的抽象数据类型（ADT）时就需要考虑三个操作：<br>（1）、创建一个最大堆；<br>（2）、最大堆的插入操作；<br>（3）、最大堆的删除操作；<br>最大堆ADT如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Max_Heap &#123;</div><div class="line">  object: 由多个元素组成的完全二叉树，其每个结点都不小于该结点的子结点关键字值</div><div class="line">  functions:</div><div class="line">    其中heap∈Max_Heap,n,max_size∈int,Element为堆中的元素类型，item∈ Element</div><div class="line">    Max_Heap createHeap(max_size)       := 创建一个总容量不大于max_size的空堆</div><div class="line">    void max_heap_insert(heap, item ,n) := 插入一个元素到heap中</div><div class="line">    Element max_heap_delete(heap,n)     := if(heap不为空) &#123;return 被删除的元素 &#125;else&#123;return NULL&#125;</div><div class="line">&#125;</div><div class="line">///其中:=符号组读作“定义为”</div></pre></td></tr></table></figure>
<h4 id="最大堆内存表现形式"><a href="#最大堆内存表现形式" class="headerlink" title="最大堆内存表现形式"></a>最大堆内存表现形式</h4><p>  我们只是简单的定义了最大堆的ADT，为了能够用代码实现它就必须要考虑最大堆的内存表现形式。从最大堆的定义中，我们知道不管是对最大堆做插入还是删除操作，<strong>我们必须要保证插入或者删除完成之后，该二叉树仍然是一个完全二叉树</strong>。基于此，我们就必须要去操作某一个结点的父结点。<br>  第一种方式，我们使用链表的方式来实现，那么我们需要添加一个额外的指针来指向该结点的父结点。此时就包括了左子结点指针、右子结点指针和父结点指针，那么空链的数目有可能是很大的，比如叶子结点的左右子结点指针和根结点的父结点指针，所以不选择这种实现方式（关于用链表实现一般二叉树时处理左右子结点指针的问题在线索二叉树中有提及）。<br>  第二种方式，使用数组实现，在二叉树进行遍历的方法分为：先序遍历、中序遍历、后序遍历和层序遍历。我们可以通过层序遍历的方式将二叉树结点存储在数组中，由于最大堆是完全二叉树不会存在数组的空间浪费。那么来看看层序遍历是怎么做的？对下图的最大堆进行层序遍历：<br><img src="http://upload-images.jianshu.io/upload_images/619906-f1c0ab6c89bc68d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/619906-4ef737815fce2175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="层序遍历流程变化">从这里可以看出最后得到的顺序和上面图中所标的顺序是一样的。<br>  那么对于数组我们怎么操作父结点和左右子结点呢？对于完全二叉树采用顺序存储表示，那么对于任意一个下标为i(1 ≤ i ≤ n)的结点：<br>（1）、父结点为：<strong><em>i / 2（i ≠ 1）</em></strong>，若i = 1，则i是根节点。<br>（2）、左子结点：<strong><em>2i（2i ≤ n）</em></strong>， 若不满足则无左子结点。<br>（3）、右子结点：<strong><em>2i + 1(2i + 1 ≤ n)</em></strong>，若不满足则无右子结点。<img src="http://upload-images.jianshu.io/upload_images/619906-4fc0e1d7aa95f1de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>最终我们选择<strong><em>数组</em></strong>作为最大堆的内存表现形式。</p>
</blockquote>
<p>基本定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define MAX_ELEMENTS 20</div><div class="line">#define HEAP_FULL(n) (MAX_ELEMENTS - 1 == n)</div><div class="line">#define HEAP_EMPTY(n) (!n)</div><div class="line">typedef struct &#123;</div><div class="line">    int key;</div><div class="line">&#125;element;</div><div class="line">element heap[MAX_ELEMENTS];</div></pre></td></tr></table></figure>
<p>下面来看看最大堆的插入、删除和创建这三个最基本的操作。</p>
<h3 id="最大堆的插入"><a href="#最大堆的插入" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h3><p>最大堆的插入操作可以简单看成是<strong>“结点上浮”</strong>。当我们在向最大堆中插入一个结点我们必须满足完全二叉树的标准，那么被插入结点的位置的是固定的。而且要满足父结点关键字值不小于子结点关键字值，那么我们就需要去移动父结点和子结点的相互位置关系。具体的位置变化，可以看看下面我画的一个简单的图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void insert_max_heap(element item ,int *n)&#123;</div><div class="line">    if(HEAP_FULL(*n))&#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    int i = ++(*n);</div><div class="line">    for(;(i != 1) &amp;&amp; (item.key &gt; heap[i/2].key);i = i / 2)&#123;/// i ≠ 1是因为数组的第一个元素并没有保存堆结点</div><div class="line">      heap[i] = heap[i/2];/// 这里其实和递归操作类似，就是去找父结点</div><div class="line">    &#125;</div><div class="line">    heap[i] = item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/619906-5ee33c128001bd5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>由于堆是一棵完全二叉树，存在n个元素，那么他的高度为:<strong><em>log2(n+1)</em></strong>，这就说明代码中的for循环会执行<strong><em>O(log2(n))</em></strong>次。因此插入函数的时间复杂度为：<strong><em>O(log2(n))</em></strong>。</p>
<h3 id="最大堆的删除"><a href="#最大堆的删除" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h3><p><strong>最大堆的删除操作，总是从堆的根结点删除元素</strong>。同样根元素被删除之后为了能够保证该树还是一个完全二叉树，我们需要来移动完全二叉树的最后一个结点，让其继续符合完全二叉树的定义，从这里可以看作是<strong><em>最大堆最后一个结点的下沉</em></strong>操作。例如在下面的最大堆中执行删除操作：<br><img src="http://upload-images.jianshu.io/upload_images/619906-2b9aae16dedbf7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">解答：</div><div class="line">1）、对于最大堆的删除，我们不能自己进行选择删除某一个结点，我们只能删除堆的根结点。因此在图a中，我们删除根结点20；</div><div class="line">2）、当删除根结点20之后明显不是一个完全二叉树，更确切地说被分成了两棵树。</div><div class="line">3）、我们需要移动子树的某一个结点来充当该树的根节点，那么在(15,2,14,10,1)这些结点中移动哪一个呢？显然是移动结点1，如果移动了其他结点（比如14，10）就不再是一个完全二叉树了。</div><div class="line">4）、此时在结点（15，2）中选择较大的一个和1做比较，即15 &gt; 1的，所以15上浮到之前的20的结点处。</div><div class="line">5）、同第4步类似，找出（14，10）之间较大的和1做比较，即14&gt;1的，所以14上浮到原来15所处的结点。</div><div class="line">6）、因为原来14的结点是叶子结点，所以将1放在原来14所处的结点处。</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/619906-cd7ca08102c205b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这图中是用<code>temp</code>分别和图中的<code>max</code>做比较，来看<code>temp</code>是否会下沉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">element delete_max_heap(int *n)&#123;</div><div class="line">  int parent, child;</div><div class="line">  element temp, item;</div><div class="line">  temp = heap[(*n)--];</div><div class="line">  item = heap[1];</div><div class="line">  parent = 1,child=2;</div><div class="line">  for(;child &lt;= *n; child = child * 2)&#123;</div><div class="line">   if( (child &lt; *n) &amp;&amp; heap[child].key &lt; heap[child+1].key)&#123;/// 这一步是为了看当前结点是左子结点大还是右子结点大，然后选择较大的那个子结点</div><div class="line">        child++;</div><div class="line">      &#125;</div><div class="line">      if(temp.key &gt;= heap[child].key)&#123;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">      heap[parent] = heap[child];///这就是上图中第二步和第三步中黄色部分操作</div><div class="line">      parent = child;/// 这其实就是一个递归操作，让parent指向当前子树的根结点</div><div class="line">   &#125;</div><div class="line">  heap[parent] = temp;</div><div class="line">  return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同最大堆的插入操作类似，同样包含n个元素的最大堆，其高度为:<strong><em>log2(n+1)</em></strong>，其时间复杂度为：<strong><em>O(log2(n))</em></strong>。</p>
<blockquote>
<p>总结：由此可以看出，在已经确定的最大堆中做删除操作，被删除的元素是固定的，需要被移动的结点也是固定的，这里我说的被移动的元素是指最初的移动，即最大堆的最后一个元素。移动方式为从最大的结点开始比较。</p>
</blockquote>
<h3 id="最大堆的创建"><a href="#最大堆的创建" class="headerlink" title="最大堆的创建"></a>最大堆的创建</h3><p>为什么要把最大堆的创建放在最后来讲？因为在堆的创建过程中，有两个方法。会分别用到最大堆的插入和最大堆的删除原理。创建最大堆有两种方法：<br>（1）、先创建一个空堆，然后根据元素一个一个去插入结点。由于插入操作的时间复杂度为<strong><em>O(log2(n))</em></strong>，那么n个元素插入进去，总的时间复杂度为<strong><em>O(n * log2(n))</em></strong>。<br>（2）、将这n个元素先顺序放入一个二叉树中形成一个完全二叉树，然后来调整各个结点的位置来满足最大堆的特性。<br>现在我们就来试一试第二种方法来创建一个最大堆：假如我们有12个元素分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;79,66,43,83,30,87,38,55,91,72,49,9&#125;</div></pre></td></tr></table></figure>
<p>将上诉15个数字放入一个二叉树中，确切地说是放入一个完全二叉树中，如下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-f14895940e2c1ded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但是这明显不符合最大堆的定义，所以我们需要让该完全二叉树转换成最大堆！怎么转换成一个最大堆呢？<br>  最大堆有一个特点就是<strong>其各个子树都是一个最大堆</strong>，那么我们就可以从把最小子树转换成一个最大堆，然后依次转换它的父节点对应的子树，直到最后的根节点所在的整个完全二叉树变成最大堆。那么从哪一个子树开始调整？</p>
<blockquote>
<p>我们从该完全二叉树中的最后一个非叶子节点为根节点的子树进行调整，然后依次去找倒数第二个倒数第三个非叶子节点…</p>
</blockquote>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>在做最大堆的创建具体步骤中，我们会用到最大堆删除操作中结点位置互换的原理，<strong><em>即关键字值较小的结点会做下沉操作</em></strong>。</p>
<ul>
<li>1）、就如同上面所说找到二叉树中倒数第一个非叶子结点<code>87</code>，然后看以该非叶子结点为根结点的子树。查看该子树是否满足最大堆要求，很明显目前该子树满足最大堆，所以我们不需要移动结点。<strong><em>该子树最大移动次数为1</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-dfabe32d4e8d1df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>2）、现在来到结点<code>30</code>，明显该子树不满足最大堆。在该结点的子结点较大的为<code>72</code>，所以结点72和结点30进行位置互换。<strong><em>该子树最大移动次数为1</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-15d2b9fc8dde0ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>3）、同样对结点<code>83</code>做类似的操作。<strong><em>该子树最大移动次数为1</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-7405036f2377c8b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>4）、现在来到结点<code>43</code>，该结点的子结点有<code>{87,38,9}</code>，对该子树做同样操作。由于结点43可能是其子树结点中最小的，所以<strong><em>该子树最大移动次数为2</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-ceeb433a5b997243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>5）、结点<code>66</code>同样操作，<strong><em>该子树最大移动次数为2</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-0a942422c933d117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>6）、最后来到根结点<code>79</code>，该二叉树最高深度为4，所以<strong><em>该子树最大移动次数为3</em></strong>。<br><img src="http://upload-images.jianshu.io/upload_images/619906-59de31f16ee7c2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>自此通过上诉步骤创建的最大堆为:<br><img src="http://upload-images.jianshu.io/upload_images/619906-c7887558467cf8c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>所以从上面可以看出，该二叉树总的需要移动结点次数最大为：<strong>10</strong>。</p>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">void create_max_heap(void)&#123;</div><div class="line">    int total = (*heap).key;</div><div class="line">    /// 求倒数第一个非叶子结点</div><div class="line">    int child = 2,parent = 1;</div><div class="line">    for (int node = total/2;node &gt; 0; node--) &#123;</div><div class="line">        parent = node;</div><div class="line">        child = 2*node;</div><div class="line">        int max_node = 2*parent+1;</div><div class="line">        element temp = *(heap + parent);</div><div class="line">        for(;child &lt;= max_node &amp;&amp; max_node &lt;= total; child = child * 2,max_node = 2*parent+1)&#123;</div><div class="line">            if ((*(heap + child)).key &lt; (*(heap + child + 1)).key) &#123;/// 取右子结点</div><div class="line">                child++;</div><div class="line">            &#125;</div><div class="line">            if (temp.key &gt; (*(heap + child)).key) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            *(heap + parent) = *(heap + child);</div><div class="line">            parent = child;</div><div class="line">        &#125;</div><div class="line">        *(heap + parent) = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *</div><div class="line"> * @param heap  最大堆；</div><div class="line"> * @param items 输入的数据源</div><div class="line"> * @return 1成功，0失败</div><div class="line"> */</div><div class="line">int create_binary_tree(element *heap,int items[MAX_ELEMENTS])&#123;</div><div class="line">    int total;</div><div class="line">    if (!items) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    element *temp = heap;</div><div class="line">    heap++;</div><div class="line">    for (total = 1; *items;total++,(heap)++,items = items + 1) &#123;</div><div class="line">        element ele = &#123;*items&#125;;</div><div class="line">        element temp_key = &#123;total&#125;;</div><div class="line">        *temp = temp_key;</div><div class="line">        *heap = ele;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">///函数调用</div><div class="line">int items[MAX_ELEMENTS] = &#123;79,66,43,83,30,87,38,55,91,72,49,9&#125;;</div><div class="line">element *position = heap;</div><div class="line">create_binary_tree(position, items);</div><div class="line">for (int i = 0; (*(heap+i)).key &gt; 0; i++) &#123;</div><div class="line">  printf(&quot;binary tree element is %d\n&quot;,(*(heap + i)).key);</div><div class="line">&#125;</div><div class="line">create_max_heap();</div><div class="line">for (int i = 0; (*(heap+i)).key &gt; 0; i++) &#123;</div><div class="line">  printf(&quot;heap element is %d\n&quot;,(*(heap + i)).key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上诉代码在我机器上能够成功的构建一个最大堆。由于该完全二叉树存在n个元素，那么他的高度为:<strong><em>log2(n+1)</em></strong>，这就说明代码中的for循环会执行<strong><em>O(log2(n))</em></strong>次。因此其时间复杂度为：<strong><em>O(log2(n))</em></strong>。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>  堆排序要比空间复杂度为<strong><em>O(n)</em></strong>的归并排序要慢一些，但是要比空间复杂度为<strong><em>O(1)</em></strong>的归并排序要快！<br>  通过上面<strong>最大堆创建</strong>一节中我们能够创建一个最大堆。出于该最大堆太大，我将其进行缩小以便进行画图演示。<br><img src="http://upload-images.jianshu.io/upload_images/619906-8b1f79e817875e10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>最大堆的排序过程其实是和最大堆的删除操作类似，由于最大堆的删除只能在根结点进行，当将根结点删除完成之后，就是将剩下的结点进行整理让其符合最大堆的标准。</p>
<ul>
<li>1）、把最大堆根结点<code>91</code>“删除”，第一次排序图示：<br><img src="http://upload-images.jianshu.io/upload_images/619906-35b9c48c809f231b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>进过这一次排序之后，<code>91</code>就处在最终的正确位置上，所以我们只需要对余下的最大堆进行操作！这里需要注意一点：</li>
</ul>
<blockquote>
<p>⚠️⚠️⚠️注意，关于对余下进行最大堆操作时：<br>并不需要像创建最大堆时，从倒数第一个非叶子结点开始。因为在我们只是对第一个和最后一个结点进行了交换，所以<strong><em>只有根结点的顺序不满足最大堆的约束，我们只需要对第一个元素进行处理即可</em></strong></p>
</blockquote>
<ul>
<li><p>2）、继续对结点<code>87</code>进行相同的操作：<br><img src="http://upload-images.jianshu.io/upload_images/619906-b14307ce0d5322e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>同样，<code>87</code>的位置确定。</p>
</li>
<li><p>3）、现在我们来确定结点<code>83</code>的位置：<br><img src="http://upload-images.jianshu.io/upload_images/619906-df936cc131e51cf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>4）、经过上诉步骤就不难理解堆排序的原理所在，最后排序结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-9a2dbb64df3a5702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<p>经过上诉多个步骤之后，最终的排序结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[38、43、72、79、83、87、91]</div></pre></td></tr></table></figure>
<p>很明显这是一个正确的从小到大的顺序。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>这里需要对上面的代码进行一些修改！因为在排序中，我们的第0个元素是不用去放一个哨兵的，我们的元素从原来的第一个位置改为从第0个位置开始放置元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">void __swap(element *lhs,element *rhs)&#123;</div><div class="line">    element temp = *lhs;</div><div class="line">    *lhs = *rhs;</div><div class="line">    *rhs = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int create_binarytree(element *heap, int items[MAX_SIZE], int n)&#123;</div><div class="line">    if (n &lt;= 0) return 0;</div><div class="line">    for (int i = 0; i &lt; n; i++,heap++) &#123;</div><div class="line">        element value = &#123;items[i]&#125;;</div><div class="line">        *heap = value;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void adapt_maxheap(element *heap ,int node ,int n)&#123;</div><div class="line">    int parent = node - 1 &lt; 0 ? 0 : node - 1;</div><div class="line">    int child = 2 * parent + 1;/// 因为没有哨兵，所以在数组中的关系由原来的：parent = 2 * child =&gt; parent = 2 * child + 1</div><div class="line">    int max_node = max_node = 2*parent+2 &lt; n - 1 ? 2*parent+2 : n - 1;</div><div class="line">    element temp = *(heap + parent);</div><div class="line">    for (;child &lt;= max_node; parent = child,child = child * 2 + 1,max_node = 2*parent+2 &lt; n - 1 ? 2*parent+2 : n - 1) &#123;</div><div class="line">        if ((heap + child)-&gt;key &lt;= (heap + child + 1)-&gt;key &amp;&amp; child + 1 &lt; n) &#123;</div><div class="line">            child++;</div><div class="line">        &#125;</div><div class="line">        if ((heap + child)-&gt;key &lt; temp.key) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        *(heap + parent) = *(heap + child);</div><div class="line">    &#125;</div><div class="line">    *(heap + parent) = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int create_maxheap(element *heap ,int n)&#123;</div><div class="line"></div><div class="line">    for (int node = n/2; node &gt; 0; node--) &#123;</div><div class="line">        adapt_maxheap(heap, node, n);</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void heap_sort(element *heap ,int n)&#123;</div><div class="line">    ///创建一个最大堆</div><div class="line">    create_maxheap(heap, n);</div><div class="line">    ///进行排序过程</div><div class="line">    int i = n - 1;</div><div class="line">    while (i &gt;= 0) &#123;</div><div class="line">        __swap(heap+0, heap + i);/// 将第一个和最后一个进行交换</div><div class="line">        adapt_maxheap(heap, 0, i--);///将总的元素个数减一，适配成最大堆，这里只需要对首元素进行最大堆的操作</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// 堆排序</div><div class="line">int n = 7;</div><div class="line">int items[7] = &#123;87,79,38,83,72,43,91&#125;;</div><div class="line">element heap[7];</div><div class="line">create_binarytree(heap, items, n);</div><div class="line">heap_sort(heap, n);</div></pre></td></tr></table></figure></p>
<p>在实现堆排序时最需要注意的就是当没有哨兵之后，父结点和左右孩子结点之间的关系发生了变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parent = 2 * child + 1;///左孩子</div><div class="line">parent = 2 * child + 2;///右孩子</div></pre></td></tr></table></figure></p>
<p>关于对排序相关的知识点已经整理完了。其时间复杂度和归并排序的时间时间复杂度是一样的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  什么是最大堆和最小堆？最大（小）堆是指在树中，存在一个结点而且该结点有儿子结点，该结点的data域值都不小于（大于）其儿子结点的data域值，并且它是一个完全二叉树（不是满二叉树）。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈（Stack）和堆（Heap）</title>
    <link href="http://yoursite.com/2017/03/21/stack_heap_with_c/"/>
    <id>http://yoursite.com/2017/03/21/stack_heap_with_c/</id>
    <published>2017-03-21T12:40:24.000Z</published>
    <updated>2017-08-01T13:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>  目前来说我们知道怎么去声明一个基础类型的变量，比如int，float，等等。以及复杂数据类型数组和结构，声明它们的时候C会把这些变量放在栈上。<strong>每个线程都有一个栈，而程序通常只有一个堆</strong>。<br><a id="more"></a> </p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>  什么是栈？它是内存中一块特殊的区域，<strong>用于保存在函数中声明的零时变量</strong>（其中也包括<code>main()</code>函数）。栈是LIFO(Last in First Out 后进先出)的数据结构，进出操作是由CPU来管理和优化的。每当函数声明了一个变量，该变量就会被<strong>推入(Pushed)</strong>栈中。每当函数退出时，所有的变量都会被函数推出栈，并被<strong>释放掉(Free)</strong>。一旦变量被释放，该内存区域就可以被其他栈变量使用。<br>  使用栈的优势是它会为你管理内存，而不需要你手动去分配或者释放内存。更进一步说，由于CPU可以有效地管理栈内存，所以从栈中读写变量是很快的。<br>  理解栈的关键是需要知道函数什么时候退出，此时栈中所有的变量被推出，因此<strong>栈变量是局部的</strong>（也就是局部变量）。C中经常出现的一个错误就是，在函数返回以后去访问函数内部中栈变量。<br>  如果使用太多的栈空间会导致溢出，比如在使用递归的时候，该函数使用了太多的局部变量在递归过程中就有可能造成<strong>栈溢出</strong>。</p>
<blockquote>
<p>总结</p>
<ul>
<li>栈是LIFO数据结构；</li>
<li>CPU管理内存，而不需要手动去管理。正是因为这个原因从栈中读写变量<strong>很快</strong>的；</li>
<li>栈变量是局部的（也就是局部变量）；</li>
<li>栈的容量会随着函数的Push和Pop变化；</li>
</ul>
</blockquote>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>  堆也是内存中一块特定区域，但是CPU并不会自动管理相关的操作，而且它的空间大小会有一定的浮动。在堆上分配内存的时候，在C中使用<code>malloc()</code>和<code>calloc()</code>函数。在不需要堆上这块内存之后，需要使用<code>free()</code>函数释放掉它。<strong>如果不释放的话就会造成内存泄漏</strong>，这块内存就会被闲置。<br>  和栈不同之处在于，<strong>堆内存数据的读写速度会比栈慢</strong>。</p>
<h3 id="栈（Stack）和堆（Heap）的差异"><a href="#栈（Stack）和堆（Heap）的差异" class="headerlink" title="栈（Stack）和堆（Heap）的差异"></a>栈（Stack）和堆（Heap）的差异</h3><h4 id="配置堆栈大小"><a href="#配置堆栈大小" class="headerlink" title="配置堆栈大小"></a>配置堆栈大小</h4><p>  堆的大小在程序启动时分配，数值在不同操作系统中可能有所不同。<br>  在Cocoa中想要修改线程的栈大小的话，可以使用<code>NSThread</code>的实例方法<code>setStackSize:</code>，如果使用POSIX线程技术创建的线程的话，想要设置栈大小的话使用<code>pthread_attr_setstacksize</code>函数。</p>
<blockquote>
<p>⚠️如果要设置栈大小就必须要在创建线程之前完成。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line">// 第一种</div><div class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(backgroudMethod:) object:nil];</div><div class="line">[thread setStackSize:1024];</div><div class="line">[thread start];</div><div class="line"></div><div class="line">/// 第二种</div><div class="line">pthread_attr_t attr;</div><div class="line">pthread_t posix_tread_id;</div><div class="line">int returnVal;</div><div class="line">returnVal = pthread_attr_init(&amp;attr);</div><div class="line">returnVal = pthread_attr_setstacksize(&amp;attr, 1024);/// 在创建线程前设置堆栈大小</div><div class="line">char *data;</div><div class="line">data = &quot;To ensure that a thread knows what work to do&quot;;</div><div class="line">int thread_error = pthread_create(&amp;posix_tread_id, &amp;attr, posix_thread_mainroutine, data);</div></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>  栈是和线程相关联的，意思就是说当线程退出时，栈被回收。而堆通常是在启动程序时分配，当程序退出之后被回收。</p>
<h3 id="什么时候使用栈什么时候使用堆"><a href="#什么时候使用栈什么时候使用堆" class="headerlink" title="什么时候使用栈什么时候使用堆"></a>什么时候使用栈什么时候使用堆</h3><ul>
<li>需要申请较大内存空间（比如struct，array之类的），而且需要该变量存在较长时间，就是将该变量放在<strong>堆</strong>中；</li>
<li>如果需要动态修改struct或者array的大小，将该变量放在<strong>堆</strong>上。使用<code>malloc()，calloc()，realloc()和free()</code>等函数来管理内存；</li>
<li>如果使用相对较小的变量，并且只在函数中使用它们，此时该变量就存在于栈上。这样做会更快而且更简单；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  目前来说我们知道怎么去声明一个基础类型的变量，比如int，float，等等。以及复杂数据类型数组和结构，声明它们的时候C会把这些变量放在栈上。&lt;strong&gt;每个线程都有一个栈，而程序通常只有一个堆&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>动画中关于KVC官方文档翻译</title>
    <link href="http://yoursite.com/2017/03/08/animation_kvc_translate/"/>
    <id>http://yoursite.com/2017/03/08/animation_kvc_translate/</id>
    <published>2017-03-08T12:59:45.000Z</published>
    <updated>2017-03-08T13:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>CoreAnimation让CAAnimation和CALayer都遵守NSKeyValueCoding协议，因此为它们增加了一些默认的keys（对应的value），添加的keyPath中包含了了CGPoint,CGRect,CGSize和CATransform3D类型。<br><a id="more"></a> </p>
<h2 id="1-键值编码兼容的容器类"><a href="#1-键值编码兼容的容器类" class="headerlink" title="1.键值编码兼容的容器类"></a>1.键值编码兼容的容器类</h2><p>CAAnimation和CALayer类就是作为键值编码兼容的容器类，我们可以根据任意的keys来设置对应的value，即便这个key不是CALayer公开的属性，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@&quot;someKey&quot;];</div></pre></td></tr></table></figure></p>
<p>同样也可以通过任意已知的keys来查找对应的values，可以使用下面的代码通过预先设置好的somekey来检索values：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someKeyValue=[theLayer valueForKey:@&quot;someKey&quot;];</div></pre></td></tr></table></figure></p>
<h2 id="2-默认支持的value"><a href="#2-默认支持的value" class="headerlink" title="2.默认支持的value"></a>2.默认支持的value</h2><p>CoreAnimation在键值编码时规定：一个类可以给没有value的key提供一个默认值。CAAnimation和CALayer类都提供了类方法<code>defaultValueForKey</code>。</p>
<blockquote>
<p>对于为key提供了默认value的类，在创建这个类的子类时必须要重写它的<code>defaultValueForKey</code>方法。</p>
</blockquote>
<p>当你在实现这个方法的时候，需要检查key的参数列表，并且返回一个合适的value值，下面提供了一个例子，layer提供了<code>defaultValueForKey:</code>方法，为<code>maskToBounds</code>属性设置默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (id)defaultValueForKey:(NSString *)key&#123;</div><div class="line">   if ([key isEqualToString:@&quot;masksToBounds&quot;])</div><div class="line">      return [NSNumber numberWithBool:YES];</div><div class="line">      return [super defaultValueForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h2><p>当一个key的数据是由一个标量值或者一个C的数据结构时，<strong>你必须要在其被分配到layer之前对其进行封装</strong>。同样的，当要访问这些Type时，也必须检查对象，然后使用合适的方法来打开合适的值。下表显示了Objective-c和c类型封装</p>
<table>
<thead>
<tr>
<th>C type</th>
<th style="text-align:center">输入</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.apple.com/reference/coregraphics/cgpoint" target="_blank" rel="external">CGPoint</a></td>
<td style="text-align:center"><a href="https://developer.apple.com/reference/foundation/nsvalue" target="_blank" rel="external">NSValue</a></td>
</tr>
<tr>
<td><a href="https://developer.apple.com/reference/coregraphics/cgsize" target="_blank" rel="external">CGSize</a></td>
<td style="text-align:center">NSValue</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/reference/coregraphics/cgrect" target="_blank" rel="external">CGRect</a></td>
<td style="text-align:center">NSValue</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/reference/quartzcore/catransform3d" target="_blank" rel="external">CATransform3D</a></td>
<td style="text-align:center">NSValue</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/reference/coregraphics/cgaffinetransform" target="_blank" rel="external">CGAffineTransform</a></td>
<td style="text-align:center"><a href="https://developer.apple.com/reference/foundation/nsaffinetransform" target="_blank" rel="external">NSAffineTransform</a> (OS X only)</td>
</tr>
</tbody>
</table>
<p>不同类型封装的类</p>
<h2 id="4-为KeyPath的提供的结构"><a href="#4-为KeyPath的提供的结构" class="headerlink" title="4.为KeyPath的提供的结构"></a>4.为KeyPath的提供的结构</h2><p>CAAnimation和CALayer类使用KeyPath来访问指定的字段，这功能可以让你在做动画时为特定的KeyPath提供数据。使用<code>setValue:forKeyPath和valueForKeyPath:</code>方法设置，然后用<code>valueForKeyPath:</code>获取相应的值。</p>
<h4 id="1-、CATransform3D-KeyPaths"><a href="#1-、CATransform3D-KeyPaths" class="headerlink" title="(1)、CATransform3D KeyPaths"></a>(1)、CATransform3D KeyPaths</h4><p>你可以使用更强大的KeyPath，查找包含了<code>CATransform3D</code>类型属性的值。在需要指定layer的<code>transforms</code>完整的KeyPath时，我们可以根据下表中提供的数据，使用<code>transform</code>和<code>sublayerTransform</code>的值。例如，我们需要制定绕着layer的z轴旋转时，我就需要指定KeyPath为<code>transform.rotation.z</code>。</p>
<table>
<thead>
<tr>
<th>Field Key Path</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rotation.x</td>
<td style="text-align:center">围绕X轴，旋转值为弧度，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>rotation.y</td>
<td style="text-align:center">围绕y轴，旋转值为弧度，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>rotation.z</td>
<td style="text-align:center">围绕z轴，旋转值为弧度，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>rotation</td>
<td style="text-align:center">围绕z轴，旋转值为弧度，<code>NSNumber</code>类型，它和设置<code>rotation.z</code>一样</td>
</tr>
<tr>
<td>scale.x</td>
<td style="text-align:center">x轴缩放，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>scale.y</td>
<td style="text-align:center">y轴缩放，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>scale.z</td>
<td style="text-align:center">z轴缩放，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>scale</td>
<td style="text-align:center">三个轴缩放的平均值，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>translation.x</td>
<td style="text-align:center">x轴位移，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>translation.y</td>
<td style="text-align:center">y轴位移，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>translation.z</td>
<td style="text-align:center">z轴位移，<code>NSNumber</code>类型</td>
</tr>
<tr>
<td>translation</td>
<td style="text-align:center">x，y上面位移，<code>NSSize</code> 和<code>CGSize</code></td>
</tr>
</tbody>
</table>
<p>下面展示了怎样通过setValue:forKeyPath方法来修改一个layer，这个例子设置了layer在x轴上位移了10个像素点，来显示layer在x轴上的移动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myLayer setValue:[NSNumber numberWithFloat:10.0] forKeyPath:@&quot;transform.translation.x&quot;];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>⚠注意：通过keyPath来设置value值的时候不能像Objective-C里面对属性的赋值，必须配合KeyPath字符串使用setValue:forKeyPath方法来进行赋值。</p>
</blockquote>
<h4 id="2-、CGPoint-KeyPath"><a href="#2-、CGPoint-KeyPath" class="headerlink" title="(2)、CGPoint KeyPath"></a>(2)、CGPoint KeyPath</h4><p>如果当前给的是一个<code>CGPoint</code>类型，则可以根据下表进行设置。例如，当我们想要修改layer的<code>position</code>的x值时，可以在KeyPath中写<code>position.x</code>。</p>
<table>
<thead>
<tr>
<th>Structure Field</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td style="text-align:center">x的分量</td>
</tr>
<tr>
<td>y</td>
<td style="text-align:center">y的分量</td>
</tr>
</tbody>
</table>
<h4 id="3-、CGSize-KeyPath"><a href="#3-、CGSize-KeyPath" class="headerlink" title="(3)、CGSize KeyPath"></a>(3)、CGSize KeyPath</h4><table>
<thead>
<tr>
<th>Structure Field</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td style="text-align:center">size的width值</td>
</tr>
<tr>
<td>height</td>
<td style="text-align:center">size的height值</td>
</tr>
</tbody>
</table>
<h4 id="4-、CGRect-KeyPath"><a href="#4-、CGRect-KeyPath" class="headerlink" title="(4)、CGRect KeyPath"></a>(4)、CGRect KeyPath</h4><p>例如，要更改layer的<code>bounds</code>属性的width值，可以写入关键路径<code>bounds.size.width</code></p>
<table>
<thead>
<tr>
<th>Structure Field</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>origin</td>
<td style="text-align:center">坐标，类型<code>CGPoint</code></td>
</tr>
<tr>
<td>origin.x</td>
<td style="text-align:center">坐标的x值，类型<code>CGFloat</code></td>
</tr>
<tr>
<td>origin.y</td>
<td style="text-align:center">坐标的y值，类型<code>CGFloat</code></td>
</tr>
<tr>
<td>size</td>
<td style="text-align:center">大小，类型<code>CGSize</code></td>
</tr>
<tr>
<td>size.width</td>
<td style="text-align:center">size的width值</td>
</tr>
<tr>
<td>size.height</td>
<td style="text-align:center">size的height值</td>
</tr>
</tbody>
</table>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>翻译这篇文章的目的因为我在做动画中需要每次都差到对应的KeyPath，很麻烦，索性我就将其翻译出来。<br>到目前为止，这片文章大部分翻译算是完成了，看起来很粗糙，能看懂就最好了。</p>
<p>原来地址：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html" target="_blank" rel="external">Key-Value Coding Extensions</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CoreAnimation让CAAnimation和CALayer都遵守NSKeyValueCoding协议，因此为它们增加了一些默认的keys（对应的value），添加的keyPath中包含了了CGPoint,CGRect,CGSize和CATransform3D类型。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Unicode和UTF-8、UTF-16以及UTF-32</title>
    <link href="http://yoursite.com/2017/03/02/unicode/"/>
    <id>http://yoursite.com/2017/03/02/unicode/</id>
    <published>2017-03-02T12:25:38.000Z</published>
    <updated>2017-03-17T15:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/unicode/unicode_1.png" alt=""></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你是iOS开发者，并且在处理NSString字符上遇到了一些问题，强烈建议去看看<a href="https://www.objccn.io/issue-9-1/" target="_blank" rel="external">Objc中国上关于 NSString 与 Unicode</a>。上面介绍了一些关于NSString相关的东西，比如<code>characterAtIndex:</code>返回的可能是包含组合序列（emoji最为常见）等等。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Unicode对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。这是<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">维基百科</a>对Unicode下的定义。<br><a id="more"></a><br>Unicode的实现方式包含了UTF-8、UTF-16（字符用两个字节或者四个字节表示）和UTF-32（用四个字节来表示），下面对面一一进行介绍。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8的最明显的一个特点是<strong>它是变长的，它可以使用1到4个字节表示一个符号，根据不同的符号变化字节长度</strong>。<br>先把<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">阮一峰在《字符编码笔记：ASCII，Unicode和UTF-8》</a>中对UTF-8的编写规则的一个总结放出来。</p>
<blockquote>
<p>️️️UTF-8的编码规则很简单，只有二条：<br>1、对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2、对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</blockquote>
<p>我的解释：第一个字节前面n为设1是为了知道当前字符占用多少字节，而后面字节的前两位为什么要设置为10下面会马上进行解释。<br>现在我们来具体的分析一下Unicode的不同范围：下面中前两个描述是否为ASCII，后两个描述多字节序列</p>
<ul>
<li>U+0000到U+007F（ASCII）<br>从U+0000到U+007F被编码为0x00~0x7F的单字节，这是<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII码</a>的所有字符，一共128个字符，所以Unicode是完全用来容纳ASCII的。<br>对于上面结论中提到的<strong>后面字节的前两位一律设为10</strong>因为必须要大于7F才和ASCII码分开。</li>
<li>大于 U+007F（非 ASCII）<br>所有大于 U+007F 的字符被编码为一串多字节序列，这样就可以区分一串多字节序列是多字节码还是 ASCII 码。</li>
<li>0xFE 和 0xFF 不会被用于 UTF-8 编码中。</li>
<li>多字节序列的第一个字节在0xC0~0xFD中，剩余字节在0x80~0xBF内。<br>这里解释一下为什么第一个是在0xC0~0xFD中，理解这里需要再回去看看上面注意中提到的Unicode编码规则。因为表示的是多字节就表明n是大于1的，所以第一个字节最小的值为：<code>11000000即C0</code>（每四位表示一个十六进制数，这也是为什么在编程的时候喜欢用十六进制数的原因），如果在没有限制的情况下，通过上面的结论我们可以得到第一个字节能表示的最大的数是0xFE（11111110），就是前面7位设置1最后一位设置为0，但是上面一条中提到<strong>不包含FE</strong>，所以第一个字节的最大值为<code>0xFD(11111101)</code>。<br>同理因为<code>后面字节的前两位一律设为10</code>所以多字节除了第一个字节的其他字节最大值为<code>10111111(BF)</code>。</li>
</ul>
<blockquote>
<p>总结<br>UTF-8 编码字符最长可达六个字节</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Unicode 字符:			    UTF-8 码:</div><div class="line">U-00000000 - U-0000007F:	0xxxxxxx      ///表示ASCII</div><div class="line">U-00000080 - U-000007FF:	110xxxxx 10xxxxxx      ///</div><div class="line">U-00000800 - U-0000FFFF:	1110xxxx 10xxxxxx 10xxxxxx</div><div class="line">U-00010000 - U-001FFFFF:	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</div><div class="line">U-00200000 - U-03FFFFFF:	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</div><div class="line">U-04000000 - U-7FFFFFFF:	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</div></pre></td></tr></table></figure>
<p>举个例子：汉字“王”的Unicode码为<code>U+73B8</code>转换为二进制为:<code>0111 0011 1010 1000</code>，”73b8”位于上面的第三类，把转换的16个二进制依次放入（一定是依次放入不管空格的）上诉的x中：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11100111 10001110 10101000</div><div class="line">/// 同样我们来验证一下阮一峰举例的“严”字</div><div class="line">/// 4E25 同样属于上诉的第三类 ，对应的二进制 =&gt; 0100 1110 0010 0101</div><div class="line">/// 11100100 10111000 10100101 得到的结果和他文章中的一样。</div></pre></td></tr></table></figure></p>
<p>到这里我自己觉得应该是把UTF-8的编码方式说清楚了，最后再来一个编码的顺序（很适合于我的方式）</p>
<blockquote>
<p>编码的顺序<br>对于单字节：<br>直接将其转换为八位的二进制就可以了；<br>对于多字节：<br>1.找到Unicode码对应的二进制数据<br>2.查看该Unicode码在分类中属于第几类<br>3.一次填入二进制码</p>
</blockquote>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p><strong>UTF-16</strong>是<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">Unicode</a>字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为”storage format”）的一种实现方式。即把Unicode字符集的抽象<a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E4%BD%8D" target="_blank" rel="external">码位</a>映射为<strong>16位</strong>长的整数（即<a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E5%85%83" target="_blank" rel="external">码元</a>）的序列，用于数据存储或传递。<br>这里需要说明一下<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#.E5.9F.BA.E6.9C.AC.E5.A4.9A.E6.96.87.E7.A7.8D.E5.B9.B3.E9.9D.A2" target="_blank" rel="external">基本多文种平面-BMP</a>和<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#.E7.AC.AC.E4.B8.80.E8.BC.94.E5.8A.A9.E5.B9.B3.E9.9D.A2" target="_blank" rel="external">辅助平面-SMP</a>，在维基百科中每一个平面相关的图片下面都说了”每个写着数字的格子代表256个码点”，即00~FF。例如：位于BMP中<code>00</code>格子中的一个码点表示为:<code>0x00E5</code>。<br>下面同样用一下阮一峰的规则总结：</p>
<blockquote>
<p>基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。</p>
</blockquote>
<p>为了能够区分它本身是一个字符，还是需要跟其他两个字节放在一起解读。在BMP中，从<strong>U+D800</strong>到<strong>U+DFFF</strong>之间BMP的区段是永久保留不映射到字符（从维基百科的图中<code>D8~DF之间表示unallocated code points</code>）。</p>
<h4 id="UTF-16结论-D800-DFFF"><a href="#UTF-16结论-D800-DFFF" class="headerlink" title="UTF-16结论(D800~DFFF)"></a>UTF-16结论(D800~DFFF)</h4><p>具体来说，辅助平面的字符位共有<code>pow(2,20)</code>个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小<code>pow(2,10)</code>），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小<code>pow(2,10)</code>），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HHHH HHHH HHLL LLLL LLLL</div></pre></td></tr></table></figure></p>
<blockquote>
<p>️注意-结论<br>高位：D800~DBFF;<br>低位：DC00~DFFF;</p>
<p>所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。（这里我就直接引用阮一峰的解释，因为他解释很通俗易懂。）</p>
</blockquote>
<p>解释一下这里为什么是<code>pow(2,20)</code>，在基本平面之外有16个辅助平面（即<code>pow(2,4)</code>），而每一个辅助平面<code>pow(2,16)</code>个码位（辅助平面和基本平面一样，每个码位里面都包含了256个码点）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">///辅助平面字符，转码公式。</div><div class="line">H = Math.floor((c-0x10000) / 0x400)+0xD800</div><div class="line">L = (c - 0x10000) % 0x400 + 0xDC00</div></pre></td></tr></table></figure></p>
<p>H为上文提到的高位，L位上文提到的低位。<br>举例说明一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// 对于小于0xFFFF的即基本平面的字符，为两个字节</div><div class="line">U+8D9E = 0x8D9E  ///对应的二进制格式为:10001101 10011110</div><div class="line"></div><div class="line">/// 对出于辅助平面的字符</div><div class="line">/// 对于U+1D306</div><div class="line">H = Math.floor((0x1D306-0x10000) / 0x400)+0xD800 = d834</div><div class="line">L = (0x1D306 - 0x10000) % 0x400 + 0xDC00 = df06</div></pre></td></tr></table></figure></p>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>因为UTF-32对每个字符都使用4<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82" target="_blank" rel="external">字节</a>，就空间而言，是非常没有效率的。特别地，非<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A8%AE%E5%B9%B3%E9%9D%A2" target="_blank" rel="external">基本多文种平面</a>的字符在大部分文件中通常很罕见，以致于它们通常被认为不存在占用空间大小的讨论，使得UTF-32通常会是其它编码的二到四倍。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以当我们在使用字符串的时候，通常使用length的时候，要看他的编码方式，并不是一个字符就代表了一个字节有可能是两个字节、四个字节甚至可能最多能到6个字节都是有可能的，这应该就能理解Swift中对于字符串的处理了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.unicode.org/charts/" target="_blank" rel="external">Unicode代码图表</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a><br><a href="https://blog.igorw.org/2012/08/29/translate-what-is-utf-8/" target="_blank" rel="external">什么是UTF-8</a><br><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解</a><br><a href="http://blog.csdn.net/thl789/article/details/7506133" target="_blank" rel="external"><a href="http://blog.csdn.net/thl789/article/details/7506133" target="_blank" rel="external">Unicode编码及其实现：UTF-16、UTF-8，and more</a></a><br><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="external">UTF-16</a><br><a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="external">UTF-32</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/unicode/unicode_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;如果你是iOS开发者，并且在处理NSString字符上遇到了一些问题，强烈建议去看看&lt;a href=&quot;https://www.objccn.io/issue-9-1/&quot;&gt;Objc中国上关于 NSString 与 Unicode&lt;/a&gt;。上面介绍了一些关于NSString相关的东西，比如&lt;code&gt;characterAtIndex:&lt;/code&gt;返回的可能是包含组合序列（emoji最为常见）等等。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Unicode对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。这是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot;&gt;维基百科&lt;/a&gt;对Unicode下的定义。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Unicode" scheme="http://yoursite.com/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>Swift3 Unsafe[Mutable]Pointer</title>
    <link href="http://yoursite.com/2017/03/02/swift3_pointer/"/>
    <id>http://yoursite.com/2017/03/02/swift3_pointer/</id>
    <published>2017-03-01T16:33:56.000Z</published>
    <updated>2017-03-01T16:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章水准不高，可能因为我自己能力有限，英文水平也就这样，自己能看懂，可能存在误人子弟的可能性，所以如果有人有机会看到了这边文章就当是一个小白的入门级的笔记吧！如果需要更深入的了解请查看文末的参考链接<br><br><a id="more"></a><br>为了将我的PhotoCutter适配Swfit3一看到一大堆的Unsafe[Mutable]Pointer的错误就是脑壳疼！最头疼的事没有找到这方面的中文资料，只有自己来弄了，然后记录一下，现在项目还是用OC，一天不写就生疏,怕以后来自己又忘记了，然后自己纪录一下吧…</p>
<blockquote>
<p>这里我先粗略地介绍：<br>1.我的理解:<code>UnsafeMutablePointer</code>其实就是<code>UnsafePointer</code>的可以变化的类型，但是<code>UnsafePointer</code>又不允许你去改变指针元素<br></p>
<p>2.<code>Unsafe[Mutable]RawPointer</code>:在swift3以前为<code>Unsafe[Mutable]Pointer&lt;Void&gt;</code>,也就是c中的<code>void *</code></p>
<p>3.<code>Unsafe[Mutable]BufferPointer</code>表示一连串的数组指针</p>
</blockquote>
<h4 id="withUnsafePointer-withUnsafeMutablePointer"><a href="#withUnsafePointer-withUnsafeMutablePointer" class="headerlink" title="withUnsafePointer/withUnsafeMutablePointer"></a>withUnsafePointer/withUnsafeMutablePointer</h4><p>比如下面我用c的方式创建和销毁了一个<code>int</code>型的指针<code>a</code>:</p>
<pre>
int \*a = malloc(sizeof(int));
\*a = 10;
free(a)
</pre>
假设在swift中`var a:Int = 10`,现在我们的目的是想创建一个指针a,我们需要将`a`转成`*a`，我们需要怎么做呢？这里可以用到`withUnsafePointer/withUnsafeMutablePointer`<br>
这两个函数会以swift类型和一个block为参数，而这个目的指针就是这个block的参数。也就是说你想将某一个swift类型的参数转换为一个指针result，这个result就是你想获得的指针，也就是下面两个例子中的ptr，希望我这个描述没有把你绕晕！<br>
这里我也以swift.org上面的socket例子来写吧!<br>
<pre>
var addrin = sockaddr_in()
</pre>

<blockquote>
<p>创建UnsafeMutablePointer</p>
</blockquote>
<pre>
withUnsafeMutablePointer(to: &addrin) { ptr in
    //ptr:UnsafeMutablePointer\<sockaddr_in>
}
</sockaddr_in></pre>

<blockquote>
<p>创建UnsafePointer</p>
</blockquote>
<pre>
withUnsafePointer(to: &addrin) { ptr in
    //ptr: UnsafePointer\<sockaddr_in>
}
</sockaddr_in></pre> 

<h4 id="withUnsafeBytes-withUnsafeMutableBytes"><a href="#withUnsafeBytes-withUnsafeMutableBytes" class="headerlink" title="withUnsafeBytes/withUnsafeMutableBytes"></a>withUnsafeBytes/withUnsafeMutableBytes</h4><p>通过<code>withUnsafeBytes/withUnsafeMutableBytes</code>获得的<code>bytes</code>只能在在函数closure里面进行使用，这个函数只相对于<code>Data</code>类型来获取bytes使用！</p>
<pre>
func unsafebytes() {
    guard let data = ".".data(using: .ascii) else{ return }
    data.withUnsafeBytes { (byte:UnsafePointer<cchar>) -> Void in
        print(byte) 
    }
}
unsafebytes()
</cchar></pre>

<h4 id="withMemoryRebound"><a href="#withMemoryRebound" class="headerlink" title="withMemoryRebound"></a>withMemoryRebound</h4><p>我们可以使用<code>withMemoryRebound</code>函数，来将一个类型的指针转换为另外一个类型的指针，使用这个函数的时候也有一些需要注意点，在[UnsafeRawPointer Migration] (1)的介绍中说到:<code>Conversion from UnsafePointer&lt;T&gt; to UnsafePointer&lt;U&gt; has been disallowed</code>，所以只能将<code>UnsafePointer&lt;Int&gt;</code>转换为<code>UnsafeMutablePointer&lt;UInt8&gt;</code>.</p>
<blockquote>
<p>UnsafePointer<int> -&gt; UnsafeMutablePointer<uint8></uint8></int></p>
</blockquote>
<pre>
var a = 10
withUnsafePointer(to: &a) { a_pt in
    a_pt.withMemoryRebound(to: UInt8.self, capacity: 1, { a_pt_uint8 in
           //a_pt_uint8:UnsafeMutablePointer           
    })
}
</pre>

<p>具体的使用场景:<br>在使用socket的时候需要<code>bind</code>或者<code>connect</code>的时候<br>这个函数的具体使用场景在[UnsafeRawPointer Migration] (1)中也有提到。<br><br><code>sockaddr_in －&gt; sockaddr</code></p>
<pre>
var addrin = sockaddr_in()
let sock = socket(PF_INET, SOCK_STREAM, 0)
let result = withUnsafePointer(to: &addrin) {
    $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
        connect(sock, $0, socklen_t(MemoryLayout<sockaddr_in>.stride))
    }
}
</sockaddr_in></pre>


<h4 id="assumingMemoryBound"><a href="#assumingMemoryBound" class="headerlink" title="assumingMemoryBound"></a>assumingMemoryBound</h4><p>将<code>UnsafeRawPointer</code>转换为<code>UnsafePointer&lt;T&gt;</code>类型，也就是swift3之前的<code>UnsafePointer&lt;Void&gt;</code>到<code>UnsafePointer&lt;T&gt;</code>。<br><br>这个和前面提到的函数<code>withMemoryRebound</code>的区别就是:</p>
<blockquote>
<p>assumingMemoryBound可以看成是withMemoryRebound的一个特例，即:<br><br><code>assumingMemoryBound</code>为<code>UnsafePointer&lt;Void&gt;</code>到<code>UnsafePointer&lt;T&gt;</code>，<br><br><code>withMemoryRebound</code>为<code>UnsafePointer&lt;U&gt;</code>到<code>UnsafeMutablePointer&lt;T&gt;</code></p>
</blockquote>
<p>代码示例:<br></p>
<pre>
let strPtr = UnsafeMutablePointer\<cfstring>.allocate(capacity: 1)
let rawPtr = UnsafeRawPointer(strPtr)
let intPtr = rawPtr.assumingMemoryBound(to: Int.self)
</cfstring></pre>


<h4 id="bindMemory"><a href="#bindMemory" class="headerlink" title="bindMemory"></a>bindMemory</h4><p>绑定一个类型\<t>到已经被分配的内存空间，返回一个绑定在<code>self</code>内存上<code>UnsafePointer&lt;T&gt;</code>的指针，需要注意的是这个函数是用于Unsafe[Mutable]RawPointer。<br></t></p>
<pre>
/// - Precondition: The memory is uninitialized.
/// - Postcondition: The memory is bound to 'T' starting at `self` continuing
///   through `self` + `count` * `MemoryLayout<t>.stride`
/// - Warning: Binding memory to a type is potentially undefined if the
///   memory is ever accessed as an unrelated type.
</t></pre>

<table>
<thead>
<tr>
<th>操作</th>
<th>内存状态</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rawptr = allocate()</code></td>
<td>uninitialized</td>
<td>None</td>
</tr>
<tr>
<td><code>tptr = rawptr.bindMemory(T)</code></td>
<td>uninitialized</td>
<td>bound to T</td>
</tr>
<tr>
<td><code>tptr.initialize()</code></td>
<td>initialized</td>
<td>bound to T</td>
</tr>
</tbody>
</table>
<p>从上面的表格结合文档里面对于<code>bindMemory</code>的说明来看，我对于<code>bindMemory</code>的理解就是，使用函数之前这块内存空间是没有被初始化的，使用<code>bindMemory</code>的目的是将<code>T</code>绑定到<code>self</code>后面<code>self</code> + <code>count</code> <em> <code>MemoryLayout&lt;T&gt;.stride</code>长度的的这块内存空间上来。但是绑定上来并不代表初始化了，此时这个内存空间仍然是没有初始化的，所以最后需要调用函数<code>initialize</code>的函数来初始化!<br><br>用这个函数同样可以把`void </em>`的C类型转换为Swift的类型。关于<a href="2">Custom memory allocation</a><br>这个函数的使用可能会有问题…先上一段我自己理解的代码吧</p>
<pre>
let a = 100
let a_rawptr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout\<int>.size, alignedTo: MemoryLayout\<int>.alignment)
let bind_rawptr = a_rawptr.bindMemory(to: Int.self, capacity: MemoryLayout\<int>.stride)
bind_rawptr.initialize(to: a)
</int></int></int></pre>


<h4 id="unsafeBitCast"><a href="#unsafeBitCast" class="headerlink" title="unsafeBitCast"></a>unsafeBitCast</h4><p>返回一个翻译成某一特定类型的值！,<code>这个会破坏Swift的类型系统</code>！<br></p>
<blockquote>
<p>特别注意️:<br>不到万不得已不要使用这个函数</p>
</blockquote>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>PhotoCutter为了适配Swift3，这其中大部分和指针相关的东西需要适配，我开始看到这些也是懵逼的，根本不懂怎么改，只有自己去慢慢学。我的方法可能很差，就目前而言是适配了，下面贴上我的修改的代码吧!</p>
<blockquote>
<p>Swift2.x</p>
</blockquote>
<pre>
options = CFDictionaryCreate(kCFAllocatorDefault,
            UnsafeMutablePointer(UnsafePointer<void>(keys)),
            UnsafeMutablePointer(UnsafePointer<void>(values)),
            2,
            &kcKeysBack,
            &kcValuesBack)
</void></void></pre>

<blockquote>
<p>Swift3.0</p>
</blockquote>
<pre>
fileprivate func buffer<t>(to type:T.Type, source:[T]) -> UnsafeMutablePointer<unsaferawpointer?>{
    var buffer = UnsafeMutablePointer<unsaferawpointer?>.allocate(capacity: source.count)
    for idx in 0..<source.count {="" let="" m_ptr="UnsafeMutableRawPointer.allocate(bytes:" memorylayout<t="">.size, alignedTo: MemoryLayout<t>.alignment)
        let bindptr = m_ptr.bindMemory(to: type, capacity: 1)
        bindptr.initialize(to: source[idx])
         let pty = UnsafeRawPointer(m_ptr)
        buffer.advanced(by: idx).pointee = pty
    }
    return buffer
}
</t></source.count></unsaferawpointer?></unsaferawpointer?></t></pre>

<p>调用:</p>
<pre>
let keys:[CFString] = [
            kCGImageSourceCreateThumbnailWithTransform,
            kCGImageSourceCreateThumbnailFromImageIfAbsent,
            kCGImageSourceThumbnailMaxPixelSize]
var keybuffer = buffer(to: CFString.self, source: keys)
/\*
这之间做你的相关操作
*/
keybuffer.deallocate(capacity: keys.count)
</pre>

<p>到这里我对于swift3指针相关的东西，就告一段落了，文章写的很粗糙，望见谅，明天开始公司要求做持续化集成了，如果你看到这个而且想和我交流的话可以在博客上的微博和我取得联系，因为我是真的不懂博客。。。以后有时间会去学习一下前端相关的东西，练手项目应该就是我这个博客！<br><br>最后还是希望去看看<a href="3">C 语言指针 5 分钟教程</a>。<br><br><br></p>
<p>参考文献:<br><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">Use Swift With Cocoa</a><br><br><a href="https://swift.org/migration-guide/se-0107-migrate.html" target="_blank" rel="external">UnsafeRawPointer Migration Swift.org</a><br><br><a href="http://technology.meronapps.com/2016/09/27/swift-3-0-unsafe-world-2/" target="_blank" rel="external">Swift 3.0 Unsafe World</a><br><br><a href="http://stackoverflow.com/questions/39515173/how-to-use-unsafemutablepointer-in-swift-3" target="_blank" rel="external">StackOverflow Question</a><br><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation" target="_blank" rel="external">Binding memory type</a><br><br><a href="https://onevcat.com/2015/01/swift-pointer/" target="_blank" rel="external">Swift 中的指针使用</a>(这个是之前版本的介绍，就参考一下用unsafeBitCast，同时文章中提到的<a href="3">C 语言指针 5 分钟教程</a>)<br><br><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="external">指针</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章水准不高，可能因为我自己能力有限，英文水平也就这样，自己能看懂，可能存在误人子弟的可能性，所以如果有人有机会看到了这边文章就当是一个小白的入门级的笔记吧！如果需要更深入的了解请查看文末的参考链接&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>创建一个更轻的ViewController</title>
    <link href="http://yoursite.com/2017/03/02/light_viewcontroller/"/>
    <id>http://yoursite.com/2017/03/02/light_viewcontroller/</id>
    <published>2017-03-01T16:26:53.000Z</published>
    <updated>2017-03-01T16:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的项目越来越臃肿，一个控制器的代码量越来越多，业务最繁重的一个控制器代码量已经达到了1000多行！这就导致给控制器瘦身是一定要做的。<br><a id="more"></a><br>说实话这种的是很不好组织语言的，但是还是按照惯例还是在这里来记录一下自己想法经历和结果。</p>
<blockquote>
<p>注意:<br>文中会同时出现Swift代码和objc代码，出现这个的原因是为了演示针对使用AF进行网络请求和数据处理，就用了其他工程的代码来进行演示。<br>样例工程是用Swift写的没有集成AF库，只是模拟了一个网络请求，但是Swift的代码同样适用于objc，这里大多的管理类都是继承自<code>NSObject</code>，希望见谅吧。<br><br></p>
</blockquote>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>现在我们的目的是来分离一个登录页面的Controller。我先把这个界面的效果图放出来</p>
<p><img src="/uploads/light_controller/light_controller_1.png" alt="登录界面"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个页面比较简单，一个简单的输入用户名称和密码，然后登录给出正确还是错误的结果！这里需要简单处理一下用户名密码的输入情况来绝对按钮的颜色的交互情况。<br>我将一个业务场景进行划分可以分为以下5个：</p>
<blockquote>
<p>1.控制器 ——-Controller<br>2.视图 ———ViewOperator<br>3.网络请求—–Request<br>4.数据处理—–DataManager<br>5.协议代理—–Delegate</p>
</blockquote>
<h3 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h3><h6 id="1-控制器-Controller"><a href="#1-控制器-Controller" class="headerlink" title="1.控制器(Controller)"></a>1.控制器(Controller)</h6><p>控制器的职责需要统调<code>视图(ViewOperator)</code>,<code>网络请求(Request)</code>,<code>数据处理(DataManager)</code>,<code>代理协议(Delegate)</code>以及不同控制器之间的联系。</p>
<h6 id="2-视图-ViewOperator"><a href="#2-视图-ViewOperator" class="headerlink" title="2.视图(ViewOperator)"></a>2.视图(ViewOperator)</h6><p>ViewOperator的作用是将控制器里面与视图相关的操作剥离出来。同时也包括了按钮的点击。</p>
<h6 id="3-协议代理-Delegate"><a href="#3-协议代理-Delegate" class="headerlink" title="3.协议代理(Delegate)"></a>3.协议代理(Delegate)</h6><p>剥离出controller中的delegate的回调，比如登录界面UITextField的相关代理操作，也可以是TableView的delegate和dataSource的分离。</p>
<h6 id="4-网络请求-Request"><a href="#4-网络请求-Request" class="headerlink" title="4.网络请求(Request)"></a>4.网络请求(Request)</h6><p>分离控制器中的网络请求部分，比如在一个包含了tableView的界面，数据加载，下拉刷新，上拉加载的相关方法.</p>
<h6 id="5-数据处理-DataManager"><a href="#5-数据处理-DataManager" class="headerlink" title="5.数据处理(DataManager)"></a>5.数据处理(DataManager)</h6><p>在网络请求完成的回调，回调回来的数据是不需要放在网络请求里面去做的，所以将网络请求数据回调放在<code>DataManager</code>中来。数据处理完成是需要给Controller一个数据回调的。</p>
<h3 id="第一步来分离Controller中的视图"><a href="#第一步来分离Controller中的视图" class="headerlink" title="第一步来分离Controller中的视图"></a>第一步来分离Controller中的视图</h3><p>通常视图相关的操作如果都放在Controller会产生很多行的代码的，所以第一步我们需要将控制器和视图相关操作分离出来。<br>在使用StoryBoard来创建一个ViewController时，需要在控制器中拖一些<code>button</code>,<code>label</code>,<code>textfield</code>等等控件，这些控件的定制以及交互等等都要拖出代码进行处理。<br>所以这里我可以给当前控制器的Scene添加一个<code>object</code></p>
<p><img src="/uploads/light_controller/light_controller_2.png" alt="object"><br>然后自定义个<code>LoginViewOperator</code>来继承自<code>NSObject</code>，将这个object的CustomClass改为<code>LoginViewOperator</code>。此时你可以将上诉的控件都拖到这个class里面，比如:</p>
<p><pre><br>public class LoginViewOperator:NSObject{<br>    @IBOutlet var fields: [UITextField]!<br>    @IBOutlet weak var login<em>btn: UIButton!<br>    @IBOutlet weak var indicator: UIActivityIndicatorView!<br>    @IBAction func login(</em> sender: UIButton) {<br>    }<br>}<br></pre>同时我也可以直接将<code>LoginViewOperator</code>拖到Controller中，来让Controller来管理LoginViewOperator `。</p>
<p><pre><br>class LoginViewController {<br>    @IBOutlet var view_operator: LoginViewOperator!<br>}<br></pre><br>如果有自定义视图的话，自定义视图的相关操作可以放在这个类中去做，或者可以给这个视图添加一个<code>helper</code>(<code>CustomViewHelper</code>)通过他来做自定义视图的相关操作</p>
<h3 id="第二步来分离Controller中的代理协议"><a href="#第二步来分离Controller中的代理协议" class="headerlink" title="第二步来分离Controller中的代理协议"></a>第二步来分离Controller中的代理协议</h3><p>加入在一个业务场景中有一个tableView，或者textfield，或者其他的系统的控件等等，和他们打交道肯定需要回调的，把这些放在控制器中也是很占位置的，必须将他们分离出来。<br>在当前场景主要是<code>UITextFieldDelegate</code>的分离，我们需要创建一个类继承自<code>NSObject</code>,并让他遵守<code>UITextFieldDelegate</code>。</p>
<p><pre><br>public class EDLoginTextFieldDelegate:NSObject{<br>   public var textdidChange:((UITextField)-&gt;Void)?<br>}<br>extension EDLoginTextFieldDelegate:UITextFieldDelegate{<br>    public func textFieldDidChange(<em> textField: UITextField){<br>        textdidChange?(textField)<br>    }<br>    public func textFieldShouldReturn(</em> textField: UITextField) -&gt; Bool {<br>        return true<br>    }<br>    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {<br>        return true<br>    }<br>}<br></pre>上面方法中<code>textFieldDidChange</code>是通过在<code>LoginViewOperator</code>中的UITextField添加的target-action的，这个会在接下来讲到。<br>此时在<code>LoginViewOperator</code>新建一个变量<code>delegate</code>:</p>
<p><pre><br>lazy var delegate:EDLoginTextFieldDelegate = EDLoginTextFieldDelegate().then{<br>   //text did change<br>  $0.textdidChange = {[unowned self] in<br>    //在这里处理当textfield在发生变化时，视图需要做出的改变，也就是上面gif中通过判断输入框中是否有值来改变button的alpha和enable的操作<br>  }<br>  //text did end<br>  //text did begin<br>}<br></pre>同时将<code>delegate</code>赋值给UITextField的delegate，修改上面outlet出来的<code>fields</code>变量：</p>
<p><pre><br>@IBOutlet var fields: [UITextField]!{<br>      didSet{<br>        fields.forEach{<br>          $0.delegate = delegate<br>          //给每一个field都添加一个target-action，这个action不要写在<code>LoginViewOperator</code>中，因为这个实际上和delegate是类似的，不是一个视图操作，所以我这里绕了一圈在delegate的textdidChange进行了回调。<br>          $0.addTarget(delegate, action: #selector(delegate.textFieldDidChange(_:)), for: .editingChanged)<br>      }<br>      if let username = User.mine.name{<br>         fields.first?.text = username<br>      }<br>    }<br>  }<br></pre>上面就是我在分离一个<code>UITextFieldDelegate</code>所做的操作。<br>在这里看来额外添加的这个<code>delegate</code>可能多此一举，因为操作相对比较少，但是如果是在tableView中的话，你需要在<code>numberOfSections</code>,<code>numberOfRowsInSection</code>,<code>cellForRowAt</code>以及<code>willDisplayCell</code>中需要写一大堆的逻辑，在这里就会体现出协议代理的分离带来的好处。</p>
<blockquote>
<p>在这里建议：如果在使用数据回调的时候可以使用delegate而不是block，这样就可以把放在controller中的block代码分离到CustomDelegate中来，后面在分离数据处理部分会用到delgate。</p>
</blockquote>
<h3 id="第三步来分离Controller中的网络请求"><a href="#第三步来分离Controller中的网络请求" class="headerlink" title="第三步来分离Controller中的网络请求"></a>第三步来分离Controller中的网络请求</h3><p>这一步我用objc的代码来进行讲解，因为在样例工程是没有涉及到网络请求的，所以我将我们公司项目的中的网络请求部分的分离代码贴出来。<br>同样我们需要创建一个类<code>DailyProhRequst</code>来继承于<code>NSObject</code>，该类分离控制器的网络请求。</p>
<p><pre><br>@interface DailyProhRequst : NSObject<br>@end<br></pre><br>并为<code>DaulyProhRequst</code>添加三个方法:</p>
<blockquote>
<p>下拉加载</p>
</blockquote>
<p><code>+ (NSInteger)headerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code></p>
<blockquote>
<p>上拉刷新的网络操作</p>
</blockquote>
<p><code>+ (NSInteger)footerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code></p>
<blockquote>
<p>简单的数据加载</p>
</blockquote>
<p><code>+ (NSInteger)reloadData:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code><br>如果需要上拉加载下拉刷新数据请求之类的，可以直接调用上面上个方法中的一个，在上面方法中还提到了<code>dataOperator</code>，它是用来整理数据的，这部分放到后面来讲。这三个方法只进行网络并把数据传给<code>dataOperator</code>，request对controller是没有回调的！<br><br>在上面的分离视图部分，我们将登录按钮的<code>@IBAction</code>放在了<code>LoginViewOperator</code>中，我们需要将这个按钮事件回调给控制器。<br>其实严谨来讲，我们是没有必要将按钮的<code>IBAction</code>放在视图中来的，这里是我的失误。<br>所以在控制器中点击按钮进行一个网络请求的操作就是<code>[DailyProhRequst headerRefresh:@{} currentPage:weakSelf.currentPage dataOperator:weakSelf.dataOperator]</code>，网络请求的分离相对来说比较简单。</p>
<h3 id="第四步创建数据操作类来管理数据"><a href="#第四步创建数据操作类来管理数据" class="headerlink" title="第四步创建数据操作类来管理数据"></a>第四步创建数据操作类来管理数据</h3><p>同上面一样适用objc的代码进行讲解。这里数据可以分为网络请求返回的数据和抽取本地db的数据，我主要讲一下通过网络获取数据进行数据处理的数据管理类。<br>首先我们同样需要创建一个类来继承自<code>NSObject</code>，并添加一个方法从<code>Requst</code>中获取原始的网络数据:</p>
<p><pre><br>@interface DailyProhDataOperator : NSObject<br>@end<br></pre>同时我们给DailyProhDataOperator类添加一个获取数据的方法<br><code>- (void)fetchData:(id)responseobject requstFailed:(NSError *)error;</code><br>而且我们的目的是必须要将处理好的数据（可能是你自己定一个数据模型）返回给Controller来更新View（由ViewOperator来更新操作）,所以需要创建一个delegate：</p>
<p><pre><br>@protocol DailyProhDataOperatorHandler <nsobject><br>@end<br></nsobject></pre><br>并给协议添加两个回调方法<br><code>- (void)dataOperatorSuccess:(DailyProhDataModel *)dataSource;</code><br><code>- (void)dataOperatorFailed:(NSError *)error;</code><br>然后给<code>DailyProhDataOperator</code>类添加一个代理属性<br><code>@property (weak ) id&lt;DailyProhDataOperatorHandler&gt; handler;</code><br>并在网络请求分离中的方法中进行修改:</p>
<p><pre> +(NSInteger)reloadData:(NSDictionary <em>)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator </em>)operators{<br>      //在网络请求或者失败的回调中添加数据处理类的入口<br>      //[operators fetchData:responseObject requstFailed:nil];<br>      return 0;<br>}<br></pre>在DataOperator中进行数据处理完成的回调<br><code>[self.handler dataOperatorSuccess:data];</code><br>这个delegate可以通过上面已经讲过的协议代理分离放在CustomDelegate的类中，由CustomDelegate和ViewOperator进行通信来达到根据数据来修改视图的效果。<br><br></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>虽然在样例工程中没有网络请求的部分，但是实际上网络请求在控制器中所占的代码就仅仅一个跳转相关的逻辑的代码而已，所以经过上诉的方式对controller进行瘦身之后，一个完整的功能的登录界面代码量为：</p>
<p><img src="/uploads/light_controller/light_controller_3.png" alt="瘦身的结果"><br>图中的request是我模拟的一个假的网络请求。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上诉的方式可以很大程度上将控制器代码进行缩减，而且指责划分也很明确。最后来说一下他们之间的关系：</p>
<blockquote>
<h6 id="Controller-lt-gt-ViewOperator"><a href="#Controller-lt-gt-ViewOperator" class="headerlink" title="Controller &lt;-&gt; ViewOperator"></a>Controller &lt;-&gt; ViewOperator</h6><p>通过ViewOperator修改视图，Controller相关交互之后通过ViewOperator来进行界面更行</p>
<h6 id="Controller-lt-gt-Delegate"><a href="#Controller-lt-gt-Delegate" class="headerlink" title="Controller  &lt;-&gt; Delegate"></a>Controller  &lt;-&gt; Delegate</h6><p>由delegate来分担Controller中的相关代理协议的工作，包括从delegate拿取数据等等，</p>
<h6 id="Controller-lt-gt-Requst"><a href="#Controller-lt-gt-Requst" class="headerlink" title="Controller &lt;-&gt; Requst"></a>Controller &lt;-&gt; Requst</h6><p>由Controller来发起Requst</p>
<h6 id="Requst-lt-gt-DataOperator"><a href="#Requst-lt-gt-DataOperator" class="headerlink" title="Requst &lt;-&gt; DataOperator"></a>Requst &lt;-&gt; DataOperator</h6><p>DataOperator从Request获取数据，并对数据进行整理</p>
<h6 id="Delegate-lt-gt-DataOperator"><a href="#Delegate-lt-gt-DataOperator" class="headerlink" title="Delegate &lt;-&gt; DataOperator"></a>Delegate &lt;-&gt; DataOperator</h6><p>DataOperator把整理好的数据返回给Delegate</p>
<h6 id="Delegate-lt-gt-ViewOperator"><a href="#Delegate-lt-gt-ViewOperator" class="headerlink" title="Delegate &lt;-&gt; ViewOperator"></a>Delegate &lt;-&gt; ViewOperator</h6><p>Delegate把数据传给ViewOperator之后，由ViewOperator更新视图</p>
</blockquote>
<p>这个只是罗列出了在当前业务逻辑下面他们之间的相互关系，只是为了梳理一下思路，在不同的逻辑下有不同的组合，但是一个业务场景在代码实现层面可以大体分成五种或者更多的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的项目越来越臃肿，一个控制器的代码量越来越多，业务最繁重的一个控制器代码量已经达到了1000多行！这就导致给控制器瘦身是一定要做的。&lt;br&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>BLUEPILL在项目中的实践</title>
    <link href="http://yoursite.com/2017/03/02/bluepill/"/>
    <id>http://yoursite.com/2017/03/02/bluepill/</id>
    <published>2017-03-01T16:17:45.000Z</published>
    <updated>2017-03-01T16:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/bluepill/bluepill_1.png" alt=""><br>  Bluepill借助于<a href="https://github.com/mmmulani/class-dump-o-tron/tree/master/Applications/Xcode.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework/Versions/A/CoreSimulator" target="_blank" rel="external">CoreSimulator</a>解决稳定性和可扩展性问题。使用CoreSimulator实现了将Bluepill从Xcode模拟器中隔离出来，并使Bluepill可并行使用多种模拟器运行测试。这里Xcode模拟器是一种随每次Xcode的更新而不断进化的黑盒。（来自<a href="http://www.infoq.com/cn/news/2017/01/linkedin-bluepill-ios-testing" target="_blank" rel="external">InfoQ介绍bluepill</a>时的一段话）<br><a id="more"></a><br>  在bluepill的<a href="https://github.com/linkedin/bluepill/releases/" target="_blank" rel="external">Release</a>可以下载到的压缩包解压，然后在终端中敲入命令:</p>
<p><pre><br>./bluepill -a ./Sample.app -s ./SampleAppTestScheme.xcscheme -o ./output/<br></pre><br>很简单，对于这最基本的命令，我们只需要有<code>.app</code>和<code>.xcscheme</code>这两个文件，然后将上面下载下来的压缩包解压之后的两个文件放在恰当的位置，应该就可以了。如果真的是这样，这篇文章也就没有存在的价值了，在这篇文章中将要做下面这几件事：</p>
<ul>
<li>Xcode工程项目结构体系；</li>
<li>如何获取上面提到的两个文件并使用上面这个最简单命令跑起来（是否包含了Test，如果没有需要添加Test）；</li>
<li>Xcode中Test的基本操作；</li>
<li>相关参数说明；</li>
</ul>
<blockquote>
<p>当前环境:<br>macOS Sierra 版本 10.12.3<br>Xcode Version 8.2.1<br>在我使用bluepill时，它只能在iOS 10.2环境下运行，查看Xcode支持的模拟器版本:<code>xcrun simctl list runtimes</code></p>
</blockquote>
<h2 id="实践前需要知道的概念"><a href="#实践前需要知道的概念" class="headerlink" title="实践前需要知道的概念"></a>实践前需要知道的概念</h2><p>下面介绍的这几个概念在<a href="https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html#//apple_ref/doc/uid/TP40009328-CH4-SW1" target="_blank" rel="external">Apple Developer</a>都可以找到，我仅仅把我认为比较有用的信息罗列出来一下。更多关于设置和使用方面我在文末列出来了，可以自己查看！</p>
<h4 id="Xcode-Project"><a href="#Xcode-Project" class="headerlink" title="Xcode Project"></a>Xcode Project</h4><p> <code>project</code>包含了需要构建一个应用程序需要的所有的文件，资源和相关信息，而<code>workspace</code>是能够包含多个project的。</p>
<blockquote>
<p>注意<br>一个<code>project</code>是可以包含多个<code>targets</code>的！</p>
</blockquote>
<p>每个<code>project</code>都定义了一个默认的<strong>build settings</strong>。因为每个project包含了多个<code>targets</code>，所以我们可以为每个targets设置不同的build settings（在文档中特别说明了每个targets的build settings是重写了其所属的project的build settings）。</p>
<h4 id="Xcode-Workspace"><a href="#Xcode-Workspace" class="headerlink" title="Xcode Workspace"></a>Xcode Workspace</h4><p><code>Workspace</code>是可以包含任意个<strong>project </strong>的，但是一个project又可以属于多个WorkSpace。对于处于同一个Workspace的不同project，由于workspace中所有project的所有文件都是位于同一个文件目录中，因此<strong>并不需要拷贝它们到每一个project文件夹中</strong>。对于Workspace的这个共同目录，我们是可以自己指定一个构建目录（build directory）的，但是如果指定了构建目录在build project时，这个project所在的所有workspace的构建目录都将覆盖这个指定的构建目录！</p>
<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p><code>target</code>指定了要构建的目标，在bluepill中会包含<code>samepleApp</code>、<code>samepleApp_Test</code>等targets。同时我们可以修改target的<strong>build setting和build phases</strong>，target会继承project的build setting，但是我们为target指定不同的build settings来覆盖project的build setting。</p>
<h4 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h4><p><code>scheme</code>是需要被build的target的集合。可以在Xcode中选择不同的<strong>scheme</strong>来指定当前需要build的target(在Xcode中同时只能选择一个scheme)。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="开荒阶段"><a href="#开荒阶段" class="headerlink" title="开荒阶段"></a>开荒阶段</h3><p>在开荒阶段是没有使用WorkSpace的，一切的基础都是在Project上。</p>
<h6 id="1-创建一个不包含Test和UITest的空项目"><a href="#1-创建一个不包含Test和UITest的空项目" class="headerlink" title="1.创建一个不包含Test和UITest的空项目"></a>1.创建一个不包含Test和UITest的空项目</h6><p>  创建一个文件夹用来保存工程项目和下载的blupill解压出来的两个文件：<strong>bluepill和bp</strong>；<br>  学过C语言的都知道，在使用<code>cc xxx.c</code>文件之后会生成一个<code>.o</code>文件，当然也可以使用<code>cc xxx.c -o selfpill</code>来重命名这个-o文件，使用selfpill文件的命令是：<code>./selfpill</code>（因为c的main的参数就是接收的终端命令），所以我猜测这其实c的一个-o文件，为了使用这两个文件，就需要将上述提到的bluepill和bp和工程项目放在同一个文件夹下。<br>  这一步中我们创建不包含Test和UITest的空项目即不要勾选那两个和test相关的Checkbox，你肯定会疑问为什么要这么做，当我在看<a href="https://github.com/linkedin/bluepill/blob/master/README.md" target="_blank" rel="external">BLUEPILL的README</a>的时候特别指出如果是使用终端进行build(使用xcodebuild，后面我会把这一步放在脚本中)的话需要使用<code>build-for-testing</code>，我猜测应该和test是有关的。所以我先测试一下没有test的情况是否会出错，如果出错，错误是什么？</p>
<h6 id="2-编译这个空项目"><a href="#2-编译这个空项目" class="headerlink" title="2.编译这个空项目"></a>2.编译这个空项目</h6><p>  项目创建好之后编译一下之后第一目的就是在终端中输入上文提到的命令，但是这里有两个疑问：-a的参数<strong>.app</strong>的路径是什么？-s的<strong>.xcscheme</strong>的路径是什么？.app就是前面我们通过编译一次获得的一个文件夹，这个文件夹的地址是<code>/Users/xxxx/Library/Developer/Xcode/DerivedData/</code>在 DerivedData文件夹下找到刚刚创建的项目并点击进去，<strong>.app</strong>文件夹就在<code>Build/Products/Debug-iphonesimulator/</code>，如果你在创建好之后没有编译Products就是一个空文件夹；而<strong>.xcscheme</strong>在<code>工程项目所在文件夹/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme</code>路径中提到的xxx是你在创建项目时的用户名。<br>好了，现在我们可以在终端中数据命令:</p>
<p><pre><code>./bluepill -a /Users/xxx/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/xxx/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -o output</code></pre><br>敲回车之后我这里出现如下报错：</p>
<p><pre><br>ERROR: There is no ‘Plugins’ folder inside your app bundle at:<br>/Users/Wil/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app<br>Perhaps you forgot to ‘build-for-testing’? (Cmd + Shift + U) in Xcode.<br>Also, if you are using XCUITest, check <a href="https://github.com/linkedin/bluepill/issues/16" target="_blank" rel="external">https://github.com/linkedin/bluepill/issues/16</a><br></pre><br>出现这个问题的原因是在.app文件夹下面没有<strong>Plugins</strong>文件夹。就算是按照提示说使用<code>Cmd + Shift + U</code>或者使用<code>xcodebuild build-for-testing</code>仍然是行不通的。走到这里我们有两条路，可以删除当前工程重新建一个包含了Test和UITest的项目，也可以在现有的Project中添加Test和UITest的Targets。我选择第二条，因为在我实际项目在这之前也是没有包含相关Test的。</p>
<h6 id="3-在包含Test的Project中实践"><a href="#3-在包含Test的Project中实践" class="headerlink" title="3.在包含Test的Project中实践"></a>3.在包含Test的Project中实践</h6><p>  现在我们需要在既有Project中添加一个Targets，<code>File/New/Target.../iOS Unit Testing Bundle</code>创建并在<strong>Scheme Menu</strong>中选择<code>New Scheme</code>选中刚刚我们添加的Targets。编译一下（这里可以使用Cmd + Shift + U或者选择Test的scheme并build，也可以使用<code>build-for-testing</code>命令:</p>
<p><pre><code>xcodebuild build-for-testing -project bluepill_sameple/bluepill_sameple.xcodeproj/ -scheme bluepill_sameple -sdk iphonesimulator10.2 -derivedDataPath build/</code></pre><br>进入.app文件夹下查看是否已经有了<code>PlugIns</code>文件夹，如果存在该文件夹则继续执行上一次出错的那个命令，运行成功，到这里已经能够使用最基础的命令。<br>  前面提到可以选择Test的scheme并build，可能会出现一点问题:<code>The scheme &#39;bluepill_samepleTests&#39; is not configured for Running</code>。因为添加了这个Test的Target之后需要编辑一下对应的Scheme使它能够进行Running操作！具体的操作如下所示：</p>
<p><img src="/uploads/bluepill/bluepill_2.png" alt=""><br>设置之后Cmd + B成功运行！</p>
<h3 id="完善阶段"><a href="#完善阶段" class="headerlink" title="完善阶段"></a>完善阶段</h3><h4 id="基本参数解释和使用"><a href="#基本参数解释和使用" class="headerlink" title="基本参数解释和使用"></a>基本参数解释和使用</h4><ul>
<li><strong>-a/-s/-o</strong>:这是三个最基本的参数，在前面使用的时候应该知道如何使用，这里不再进行解释！</li>
<li><strong>-c</strong>:读取一个自定义的<code>config.json</code>文件作为bluepill的运行参数，例如:<pre><code>./bluepill -c config.json</code></pre></li>
<li><strong>-l</strong> :获取在当前project中存在的testcase，它的打印结果是存在于<code>.../bluepill_sameple.app/PlugIns</code>文件夹下面！现在我为了演示多建立了一个Test Target(添加Scheme)然后编译：<br><pre><code>./bluepill -a /Users/用户名/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/用户名/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/Wil.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -l</code></pre>打印结果:<pre><br>bluepill_samepleTests.xctest<br>bluepill_samepleTests_target.xctest</pre>文件夹:<br><img src="/uploads/bluepill/bluepill_3.png" alt=""></li>
<li><strong>-x/-i</strong>:<code>-x</code>在运行bluepill的时候不包含某一个testcase，<code>-i</code>和<code>-x</code>相反，它则是要包含某一个testcase，<code>-x</code>的优先级是大于<code>-i</code>的。<br><pre><br>./bluepill -a xxxx.app -s xxxx.xcscheme -x bluepill_samepleTests.xctest -r ‘iOS 10.2’;<br>./bluepill -a xxxx.app -s xxxx.xcscheme -i bluepill_samepleTests.xctest -r ‘iOS 10.2’;<br></pre>其中关于<code>-x</code>和<code>-i</code>的参数可使用<code>-l</code>命令来获取！</li>
<li><strong>-d/-n</strong>:使用命令：<code>xcrun simctl list devices</code>来获取当前可用的模拟器设备，在得到这些设备之后可以使用<code>-d</code>来指定需要启动的设备！其中<code>-n</code>可以指定同时运行的模拟器数量。比如：<br><pre><br>./bluepill -a xxxx.app -s xxxx.xcscheme -r ‘iOS 10.2’  -d ‘iPhone 5s’;<br></pre>其中命令前面是一样的，这里先省略！<br>对于真机：在<a href="https://github.com/linkedin/bluepill/issues/61" target="_blank" rel="external">bluepill的Issue页面</a>指出blupill不支持真机！</li>
</ul>
<p>目前对于bluepill的实践先到这里，后续还会继续更新遇到的相关问题！</p>
<p><strong>相关链接:</strong></p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/ConfiguringYourApp/ConfiguringYourApp.html" target="_blank" rel="external">Configuring Your Xcode Project</a></li>
<li><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="external">Xcode Build Settings Reference</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/bluepill/bluepill_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;  Bluepill借助于&lt;a href=&quot;https://github.com/mmmulani/class-dump-o-tron/tree/master/Applications/Xcode.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework/Versions/A/CoreSimulator&quot;&gt;CoreSimulator&lt;/a&gt;解决稳定性和可扩展性问题。使用CoreSimulator实现了将Bluepill从Xcode模拟器中隔离出来，并使Bluepill可并行使用多种模拟器运行测试。这里Xcode模拟器是一种随每次Xcode的更新而不断进化的黑盒。（来自&lt;a href=&quot;http://www.infoq.com/cn/news/2017/01/linkedin-bluepill-ios-testing&quot;&gt;InfoQ介绍bluepill&lt;/a&gt;时的一段话）&lt;br&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="BLUEPILL" scheme="http://yoursite.com/tags/BLUEPILL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP持久连接</title>
    <link href="http://yoursite.com/2017/02/27/http_keep_alive/"/>
    <id>http://yoursite.com/2017/02/27/http_keep_alive/</id>
    <published>2017-02-27T15:18:00.000Z</published>
    <updated>2017-02-27T15:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP/1.1允许http设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的http请求重用现存的连接。在事务处理结束之后仍然保持打开状态的TCP连接被称为<strong>持久连接</strong>。持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭。<br>已经打开的连接可以避免慢启动的拥堵适应阶段。以便更快的进行数据传输。<br><a id="more"></a> </p>
<h2 id="持久以及并行连接"><a href="#持久以及并行连接" class="headerlink" title="持久以及并行连接"></a>持久以及并行连接</h2><p>并行连接的缺点: </p>
<ul>
<li>每个事务打开／关闭一个新的连接，会耗费时间和宽带的；</li>
<li>由于TCP慢启动，每条新连接的性能都会有降低；</li>
<li>可打开的并行连接数量实际上是有限的。</li>
</ul>
<p>持久连接降低了时延和建立连接的开销，但是持久连接时可能会累积出大量的空闲连接。所以需要配合使用持久连接和并行连接。</p>
<h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+ keep-alive连接"></a>HTTP/1.0+ keep-alive连接</h2><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>实现了HTTP/1.0 keep-alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>如果服务器愿意为下一条请求将连接保持在打开状态，就在通用首部中包含相同的内容。如果没有包含<code>Connection: Keep-Alive</code>首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。<br><img src="/uploads/md_srouce/http_keep_alive_1.png" alt="HTTP:1.0 keep-alive事务首部的握手过程.png"></p>
<blockquote>
<p>⚠️注意<br>keep-alive首部只是请求将连接保持在活跃状态。在发出keep-alive请求之后，客户端和服务器可以在任意时刻关闭空闲的keep-alive连接，并可以限制keep-alive连接所处理事务的数量。</p>
</blockquote>
<h4 id="通用首部Keep-Alive选项"><a href="#通用首部Keep-Alive选项" class="headerlink" title="通用首部Keep-Alive选项"></a>通用首部<code>Keep-Alive</code>选项</h4><ul>
<li>参数timeout是在Keep-Alive响应首部发送的。它<strong>估计</strong>了服务器希望将连接保持在活跃状态的时间。</li>
<li>参数max是在Keep-Alive响应首部发送的。它<strong>估计</strong>了服务器还希望为多少个事务抱持此连接的活跃状态。</li>
<li>Keep-Alive首部还可支持任意未经处理的属性。语法为：name [=value]</li>
</ul>
<p>Keep-Alive首部只有在提供了<code>Connection:Keep-Alive</code>时才能使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection:Keep-Alive</div><div class="line">Keep-Alive:max=5, timeout=120</div></pre></td></tr></table></figure></p>
<h4 id="Keep-Alive连接的限制和规则"><a href="#Keep-Alive连接的限制和规则" class="headerlink" title="Keep-Alive连接的限制和规则"></a>Keep-Alive连接的限制和规则</h4><ul>
<li>在HTTP1.0中，keep-alive并不是默认使用的。客户端必须发送一个<code>Connection:Keep-Alive</code>请求首部来激活keep-alive连接；</li>
<li>代理或网关必须将报文转发或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。</li>
<li>不应该与无法确定是否支持Connection首部代理服务器建立keep-alive连接，以防止出现哑代理。</li>
</ul>
<h2 id="HTTP-1-1-持久连接-Persistent-Connection"><a href="#HTTP-1-1-持久连接-Persistent-Connection" class="headerlink" title="HTTP/1.1 持久连接(Persistent Connection)"></a>HTTP/1.1 持久连接(Persistent Connection)</h2><p>HTTP/1.1 持久连接在默认情况下是<strong>激活</strong>的，要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显示的添加一个<code>Connection:close</code>首部。不然HTTP/1.1 连接就仍然维持在打开状态。</p>
<blockquote>
<p>⚠️<br>不发送<code>Connection:close</code>并不意味着服务器承诺永远将连接保持在打开状态。</p>
</blockquote>
<h4 id="持久连接的限制和规则"><a href="#持久连接的限制和规则" class="headerlink" title="持久连接的限制和规则"></a>持久连接的限制和规则</h4><ul>
<li>发送了Connection:close请求首部之后，客户端就无法在那条连接上发送更多的请求了。 </li>
<li>如果客户端不想再连接上发送其他请求，就应该在最后一条请求中发送一个Connection:close请求首部。</li>
<li>只有当连接上所有报文的实体主体部分的长度和首部字段<code>Content Length</code>一样（或者用分块传输编码方式），这样连接才能持久保持</li>
<li>HTTP1.1的代理服务器不应该与HTTP1.0客户端建立持久连接。</li>
<li><strong>HTTP1.1设备可以在任意时刻关闭连接</strong>，尽管是出于传输报文的过程中关闭连接。</li>
</ul>
<h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>HTTP1.1允许在持久连接上可选的使用<code>请求管道</code>。这是在keep-alive连接上的进一步性能优化。<br>在响应到达前，可以<strong>将多条请求放入队列中</strong>，这样做可以降低网络的环回时间，提高性能。</p>
<h4 id="管道化连接的几个限制"><a href="#管道化连接的几个限制" class="headerlink" title="管道化连接的几个限制"></a>管道化连接的几个限制</h4><ul>
<li>如果http客户端无法确认连接是持久的，就不应该使用管道；</li>
<li>必须按照与请求相同的顺序回送http响应。</li>
<li>http客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>http客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。</li>
</ul>
<p><img src="/uploads/md_srouce/http_keep_alive_2.png" alt="管道化连接.png"></p>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>在连接管理中需要知道什么时候关闭连接以及如何去关闭连接。</p>
<h4 id="“任意”接触连接"><a href="#“任意”接触连接" class="headerlink" title="“任意”接触连接"></a>“任意”接触连接</h4><p><strong>所有的HTTP客户端、服务器或者代理都可以在任意时刻关闭一条TCP传输连接</strong>。通常会在一条报文结束时关闭连接。</p>
<blockquote>
<p>但是，服务器永远都无法确定在它关闭“空闲”连接那时候，在客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现连接错误的请求。</p>
</blockquote>
<h4 id="Content-Length及截尾操作"><a href="#Content-Length及截尾操作" class="headerlink" title="Content-Length及截尾操作"></a>Content-Length及截尾操作</h4><p>每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主题的尺寸。<br>客户端或者代理受到一条随连接关闭而结束的http响应，且实际传输的实体长度与<code>Content-Length</code>并不匹配，接收端就应该质疑长度的正确性。<br>如果接收端是缓存代理，接收端就不应该缓存这条响应。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”Content-Length。</p>
<h4 id="连接关闭容限，重试以及幂等性"><a href="#连接关闭容限，重试以及幂等性" class="headerlink" title="连接关闭容限，重试以及幂等性"></a>连接关闭容限，重试以及幂等性</h4><p>如果客户端执行事务的过程中，传输连接关闭了，<strong>那么除非事务处理会带来一些副作用，否则客户端就应该重新打开连接</strong>，并重试。</p>
<h6 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h6><p>如果一个事务，不管是执行一次还是多次，得到的结果都是相同的，那么这个事务就是幂等的。</p>
<blockquote>
<p>GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都是的。</p>
</blockquote>
<p>客户端不应该用管道化的方式传送非幂等请求(就是说比如POST请求不应该使用管道化方式)。</p>
<h4 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h4><p>TCP连接都是双向的。tcp连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。<br><img src="/uploads/md_srouce/http_keep_alive_3.png" alt="tcp双向的连接.png"></p>
<h6 id="完全关闭和半关闭"><a href="#完全关闭和半关闭" class="headerlink" title="完全关闭和半关闭"></a>完全关闭和半关闭</h6><p>应用程序可以关闭tcp输入和输出信道中的任意一个，或者将两者都关闭了。</p>
<blockquote>
<p>套接字调用<code>close()</code>会将tcp连接的输入和输出信道都关闭，这就是<strong>完全关闭</strong>。<br>用<code>shutdown()</code>单独关闭输入或者输出信道，被称为<strong>半关闭</strong>。</p>
</blockquote>
<h6 id="TCP关闭及重置错误"><a href="#TCP关闭及重置错误" class="headerlink" title="TCP关闭及重置错误"></a>TCP关闭及重置错误</h6><p>总之，<strong>关闭连接的输出信道总是很安全的</strong>。连接另一端的对等实体会在其缓冲区中读出所有数据之后收到一条通知，说明流结束了。<br><strong>关闭连接的输入信道比较危险</strong>，除非你知道另一端不打算再发送其他数据。如果另一端向你已关闭的输入信道发送数据，操作系统会向另一端的机器回送一条TCP“<strong>连接被对端重置</strong>”。</p>
<blockquote>
<p>大部分操作系统都会将这种情况作为严重错误来处理，<strong>删除对端还未读去的所有缓存数据</strong>。但是这样做对于管道化来说简直就是噩梦，因为:比如你已经在一条持久连接上发送了10条管道式请求，响应已经收到了，正在操作系统的缓存区中存着。但是你发送了第11条请求，但是服务器认为你使用这条连接的时间太长，决定将其关闭，这个重置信息会清空你的缓冲区。</p>
</blockquote>
<h6 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h6><p>实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据之后，连接就会被完全关闭，而不会有重置风险。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP/1.1允许http设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的http请求重用现存的连接。在事务处理结束之后仍然保持打开状态的TCP连接被称为&lt;strong&gt;持久连接&lt;/strong&gt;。持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭。&lt;br&gt;已经打开的连接可以避免慢启动的拥堵适应阶段。以便更快的进行数据传输。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
