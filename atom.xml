<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌云壮志幾多愁</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-02T12:48:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王望</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unicode和UTF-8、UTF-16以及UTF-32</title>
    <link href="http://yoursite.com/2017/03/02/unicode/"/>
    <id>http://yoursite.com/2017/03/02/unicode/</id>
    <published>2017-03-02T12:25:38.000Z</published>
    <updated>2017-03-02T12:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/unicode/unicode_1.png" alt=""><br>Unicode对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。这是<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">维基百科</a>对Unicode下的定义。<br><a id="more"></a><br>Unicode的实现方式包含了UTF-8、UTF-16（字符用两个字节或者四个字节表示）和UTF-32（用四个字节来表示），下面对面一一进行介绍。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8的最明显的一个特点是<strong>它是变长的，它可以使用1到4个字节表示一个符号，根据不同的符号变化字节长度</strong>。<br>先把<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">阮一峰在《字符编码笔记：ASCII，Unicode和UTF-8》</a>中对UTF-8的编写规则的一个总结放出来。</p>
<blockquote>
<p>️️️UTF-8的编码规则很简单，只有二条：<br>1、对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2、对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</blockquote>
<p>我的解释：第一个字节前面n为设1是为了知道当前字符占用多少字节，而后面字节的前两位为什么要设置为10下面会马上进行解释。<br>现在我们来具体的分析一下Unicode的不同范围：下面中前两个描述是否为ASCII，后两个描述多字节序列</p>
<ul>
<li>U+0000到U+007F（ASCII）<br>从U+0000到U+007F被编码为0x00~0x7F的单字节，这是<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII码</a>的所有字符，一共128个字符，所以Unicode是完全用来容纳ASCII的。<br>对于上面结论中提到的<strong>后面字节的前两位一律设为10</strong>因为必须要大于7F才和ASCII码分开。</li>
<li>大于 U+007F（非 ASCII）<br>所有大于 U+007F 的字符被编码为一串多字节序列，这样就可以区分一串多字节序列是多字节码还是 ASCII 码。</li>
<li>0xFE 和 0xFF 不会被用于 UTF-8 编码中。</li>
<li>多字节序列的第一个字节在0xC0~0xFD中，剩余字节在0x80~0xBF内。<br>这里解释一下为什么第一个是在0xC0~0xFD中，理解这里需要再回去看看上面注意中提到的Unicode编码规则。因为表示的是多字节就表明n是大于1的，所以第一个字节最小的值为：<code>11000000即C0</code>（每四位表示一个十六进制数，这也是为什么在编程的时候喜欢用十六进制数的原因），如果在没有限制的情况下，通过上面的结论我们可以得到第一个字节能表示的最大的数是0xFE（11111110），就是前面7位设置1最后一位设置为0，但是上面一条中提到<strong>不包含FE</strong>，所以第一个字节的最大值为<code>0xFD(11111101)</code>。<br>同理因为<code>后面字节的前两位一律设为10</code>所以多字节除了第一个字节的其他字节最大值为<code>10111111(BF)</code>。</li>
</ul>
<blockquote>
<p>总结<br>UTF-8 编码字符最长可达六个字节</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Unicode 字符:			    UTF-8 码:</div><div class="line">U-00000000 - U-0000007F:	0xxxxxxx      ///表示ASCII</div><div class="line">U-00000080 - U-000007FF:	110xxxxx 10xxxxxx      ///</div><div class="line">U-00000800 - U-0000FFFF:	1110xxxx 10xxxxxx 10xxxxxx</div><div class="line">U-00010000 - U-001FFFFF:	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</div><div class="line">U-00200000 - U-03FFFFFF:	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</div><div class="line">U-04000000 - U-7FFFFFFF:	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</div></pre></td></tr></table></figure>
<p>举个例子：汉字“王”的Unicode码为<code>U+73B8</code>转换为二进制为:<code>0111 0011 1010 1000</code>，”73b8”位于上面的第三类，把转换的16个二进制依次放入（一定是一次放入不管空格的）上诉的x中：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11100111 10001110 10101000</div><div class="line">/// 同样我们来验证一下阮一峰举例的“严”字</div><div class="line">/// 4E25 同样属于上诉的第三类 ，对应的二进制 =&gt; 0100 1110 0010 0101</div><div class="line">/// 11100100 10111000 10100101 得到的结果和他文章中的一样。</div></pre></td></tr></table></figure></p>
<p>到这里我自己觉得应该是把UTF-8的编码方式说清楚了，最后再来一个编码的顺序（很适合于我的方式）</p>
<blockquote>
<p>编码的顺序<br>对于单字节：<br>直接将其转换为八位的二进制就可以了；<br>对于多字节：<br>1.找到Unicode码对应的二进制数据<br>2.查看该Unicode码在分类中属于第几类<br>3.一次填入二进制码</p>
</blockquote>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p><strong>UTF-16</strong>是<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">Unicode</a>字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为”storage format”）的一种实现方式。即把Unicode字符集的抽象<a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E4%BD%8D" target="_blank" rel="external">码位</a>映射为<strong>16位</strong>长的整数（即<a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E5%85%83" target="_blank" rel="external">码元</a>）的序列，用于数据存储或传递。<br>这里需要说明一下<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#.E5.9F.BA.E6.9C.AC.E5.A4.9A.E6.96.87.E7.A7.8D.E5.B9.B3.E9.9D.A2" target="_blank" rel="external">基本多文种平面-BMP</a>和<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#.E7.AC.AC.E4.B8.80.E8.BC.94.E5.8A.A9.E5.B9.B3.E9.9D.A2" target="_blank" rel="external">辅助平面-SMP</a>，在维基百科中每一个平面相关的图片下面都说了”每个写着数字的格子代表256个码点”，即00~FF。例如：位于BMP中<code>00</code>格子中的一个码点表示为:<code>0x00E5</code>。<br>下面同样用一下阮一峰的规则总结：</p>
<blockquote>
<p>基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。</p>
</blockquote>
<p>为了能够区分它本身是一个字符，还是需要跟其他两个字节放在一起解读。在BMP中，从<strong>U+D800</strong>到<strong>U+DFFF</strong>之间BMP的区段是永久保留不映射到字符（从维基百科的图中<code>D8~DF之间表示unallocated code points</code>）。</p>
<h4 id="UTF-16结论-D800-DFFF"><a href="#UTF-16结论-D800-DFFF" class="headerlink" title="UTF-16结论(D800~DFFF)"></a>UTF-16结论(D800~DFFF)</h4><p>具体来说，辅助平面的字符位共有<code>pow(2,20)</code>个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小<code>pow(2,10)</code>），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小<code>pow(2,10)</code>），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HHHH HHHH HHLL LLLL LLLL</div></pre></td></tr></table></figure></p>
<blockquote>
<p>️注意-结论<br>高位：D800~DBFF;<br>低位：DC00~DFFF;</p>
<p>所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。（这里我就直接引用阮一峰的解释，因为他解释很通俗易懂。）</p>
</blockquote>
<p>解释一下这里为什么是<code>pow(2,20)</code>，在基本平面之外有16个辅助平面（即<code>pow(2,4)</code>），而每一个辅助平面<code>pow(2,16)</code>个码位（辅助平面和基本平面一样，每个码位里面都包含了256个码点）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">///辅助平面字符，转码公式。</div><div class="line">H = Math.floor((c-0x10000) / 0x400)+0xD800</div><div class="line">L = (c - 0x10000) % 0x400 + 0xDC00</div></pre></td></tr></table></figure></p>
<p>H为上文提到的高位，L位上文提到的低位。<br>举例说明一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/// 对于小于0xFFFF的即基本平面的字符，为两个字节</div><div class="line">U+8D9E = 0x8D9E  ///对应的二进制格式为:10001101 10011110</div><div class="line"></div><div class="line">/// 对出于辅助平面的字符</div><div class="line">/// 对于U+1D306</div><div class="line">H = Math.floor((0x1D306-0x10000) / 0x400)+0xD800 = d834</div><div class="line">L = (0x1D306 - 0x10000) % 0x400 + 0xDC00 = df06</div></pre></td></tr></table></figure></p>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>因为UTF-32对每个字符都使用4<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82" target="_blank" rel="external">字节</a>，就空间而言，是非常没有效率的。特别地，非<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A8%AE%E5%B9%B3%E9%9D%A2" target="_blank" rel="external">基本多文种平面</a>的字符在大部分文件中通常很罕见，以致于它们通常被认为不存在占用空间大小的讨论，使得UTF-32通常会是其它编码的二到四倍。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以当我们在使用字符串的时候，通常使用length的时候，要看他的编码方式，并不是一个字符就代表了一个字节有可能是两个字节、四个字节甚至可能最多能到6个字节都是有可能的，这应该就能理解Swift中对于字符串的处理了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.unicode.org/charts/" target="_blank" rel="external">Unicode代码图表</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a><br><a href="https://blog.igorw.org/2012/08/29/translate-what-is-utf-8/" target="_blank" rel="external">什么是UTF-8</a><br><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">Unicode与JavaScript详解</a><br><a href="http://blog.csdn.net/thl789/article/details/7506133" target="_blank" rel="external"><a href="http://blog.csdn.net/thl789/article/details/7506133" target="_blank" rel="external">Unicode编码及其实现：UTF-16、UTF-8，and more</a></a><br><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="external">UTF-16</a><br><a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="external">UTF-32</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/unicode/unicode_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Unicode对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。这是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot;&gt;维基百科&lt;/a&gt;对Unicode下的定义。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Unicode" scheme="http://yoursite.com/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>Swift3 Unsafe[Mutable]Pointer</title>
    <link href="http://yoursite.com/2017/03/02/swift3_pointer/"/>
    <id>http://yoursite.com/2017/03/02/swift3_pointer/</id>
    <published>2017-03-01T16:33:56.000Z</published>
    <updated>2017-03-01T16:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章水准不高，可能因为我自己能力有限，英文水平也就这样，自己能看懂，可能存在误人子弟的可能性，所以如果有人有机会看到了这边文章就当是一个小白的入门级的笔记吧！如果需要更深入的了解请查看文末的参考链接<br><br><a id="more"></a><br>为了将我的PhotoCutter适配Swfit3一看到一大堆的Unsafe[Mutable]Pointer的错误就是脑壳疼！最头疼的事没有找到这方面的中文资料，只有自己来弄了，然后记录一下，现在项目还是用OC，一天不写就生疏,怕以后来自己又忘记了，然后自己纪录一下吧…</p>
<blockquote>
<p>这里我先粗略地介绍：<br>1.我的理解:<code>UnsafeMutablePointer</code>其实就是<code>UnsafePointer</code>的可以变化的类型，但是<code>UnsafePointer</code>又不允许你去改变指针元素<br></p>
<p>2.<code>Unsafe[Mutable]RawPointer</code>:在swift3以前为<code>Unsafe[Mutable]Pointer&lt;Void&gt;</code>,也就是c中的<code>void *</code></p>
<p>3.<code>Unsafe[Mutable]BufferPointer</code>表示一连串的数组指针</p>
</blockquote>
<h4 id="withUnsafePointer-withUnsafeMutablePointer"><a href="#withUnsafePointer-withUnsafeMutablePointer" class="headerlink" title="withUnsafePointer/withUnsafeMutablePointer"></a>withUnsafePointer/withUnsafeMutablePointer</h4><p>比如下面我用c的方式创建和销毁了一个<code>int</code>型的指针<code>a</code>:</p>
<pre>
int \*a = malloc(sizeof(int));
\*a = 10;
free(a)
</pre>
假设在swift中`var a:Int = 10`,现在我们的目的是想创建一个指针a,我们需要将`a`转成`*a`，我们需要怎么做呢？这里可以用到`withUnsafePointer/withUnsafeMutablePointer`<br>
这两个函数会以swift类型和一个block为参数，而这个目的指针就是这个block的参数。也就是说你想将某一个swift类型的参数转换为一个指针result，这个result就是你想获得的指针，也就是下面两个例子中的ptr，希望我这个描述没有把你绕晕！<br>
这里我也以swift.org上面的socket例子来写吧!<br>
<pre>
var addrin = sockaddr_in()
</pre>

<blockquote>
<p>创建UnsafeMutablePointer</p>
</blockquote>
<pre>
withUnsafeMutablePointer(to: &addrin) { ptr in
    //ptr:UnsafeMutablePointer\<sockaddr_in>
}
</sockaddr_in></pre>

<blockquote>
<p>创建UnsafePointer</p>
</blockquote>
<pre>
withUnsafePointer(to: &addrin) { ptr in
    //ptr: UnsafePointer\<sockaddr_in>
}
</sockaddr_in></pre> 

<h4 id="withUnsafeBytes-withUnsafeMutableBytes"><a href="#withUnsafeBytes-withUnsafeMutableBytes" class="headerlink" title="withUnsafeBytes/withUnsafeMutableBytes"></a>withUnsafeBytes/withUnsafeMutableBytes</h4><p>通过<code>withUnsafeBytes/withUnsafeMutableBytes</code>获得的<code>bytes</code>只能在在函数closure里面进行使用，这个函数只相对于<code>Data</code>类型来获取bytes使用！</p>
<pre>
func unsafebytes() {
    guard let data = ".".data(using: .ascii) else{ return }
    data.withUnsafeBytes { (byte:UnsafePointer<cchar>) -> Void in
        print(byte) 
    }
}
unsafebytes()
</cchar></pre>

<h4 id="withMemoryRebound"><a href="#withMemoryRebound" class="headerlink" title="withMemoryRebound"></a>withMemoryRebound</h4><p>我们可以使用<code>withMemoryRebound</code>函数，来将一个类型的指针转换为另外一个类型的指针，使用这个函数的时候也有一些需要注意点，在[UnsafeRawPointer Migration] (1)的介绍中说到:<code>Conversion from UnsafePointer&lt;T&gt; to UnsafePointer&lt;U&gt; has been disallowed</code>，所以只能将<code>UnsafePointer&lt;Int&gt;</code>转换为<code>UnsafeMutablePointer&lt;UInt8&gt;</code>.</p>
<blockquote>
<p>UnsafePointer<int> -&gt; UnsafeMutablePointer<uint8></uint8></int></p>
</blockquote>
<pre>
var a = 10
withUnsafePointer(to: &a) { a_pt in
    a_pt.withMemoryRebound(to: UInt8.self, capacity: 1, { a_pt_uint8 in
           //a_pt_uint8:UnsafeMutablePointer           
    })
}
</pre>

<p>具体的使用场景:<br>在使用socket的时候需要<code>bind</code>或者<code>connect</code>的时候<br>这个函数的具体使用场景在[UnsafeRawPointer Migration] (1)中也有提到。<br><br><code>sockaddr_in －&gt; sockaddr</code></p>
<pre>
var addrin = sockaddr_in()
let sock = socket(PF_INET, SOCK_STREAM, 0)
let result = withUnsafePointer(to: &addrin) {
    $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
        connect(sock, $0, socklen_t(MemoryLayout<sockaddr_in>.stride))
    }
}
</sockaddr_in></pre>


<h4 id="assumingMemoryBound"><a href="#assumingMemoryBound" class="headerlink" title="assumingMemoryBound"></a>assumingMemoryBound</h4><p>将<code>UnsafeRawPointer</code>转换为<code>UnsafePointer&lt;T&gt;</code>类型，也就是swift3之前的<code>UnsafePointer&lt;Void&gt;</code>到<code>UnsafePointer&lt;T&gt;</code>。<br><br>这个和前面提到的函数<code>withMemoryRebound</code>的区别就是:</p>
<blockquote>
<p>assumingMemoryBound可以看成是withMemoryRebound的一个特例，即:<br><br><code>assumingMemoryBound</code>为<code>UnsafePointer&lt;Void&gt;</code>到<code>UnsafePointer&lt;T&gt;</code>，<br><br><code>withMemoryRebound</code>为<code>UnsafePointer&lt;U&gt;</code>到<code>UnsafeMutablePointer&lt;T&gt;</code></p>
</blockquote>
<p>代码示例:<br></p>
<pre>
let strPtr = UnsafeMutablePointer\<cfstring>.allocate(capacity: 1)
let rawPtr = UnsafeRawPointer(strPtr)
let intPtr = rawPtr.assumingMemoryBound(to: Int.self)
</cfstring></pre>


<h4 id="bindMemory"><a href="#bindMemory" class="headerlink" title="bindMemory"></a>bindMemory</h4><p>绑定一个类型\<t>到已经被分配的内存空间，返回一个绑定在<code>self</code>内存上<code>UnsafePointer&lt;T&gt;</code>的指针，需要注意的是这个函数是用于Unsafe[Mutable]RawPointer。<br></t></p>
<pre>
/// - Precondition: The memory is uninitialized.
/// - Postcondition: The memory is bound to 'T' starting at `self` continuing
///   through `self` + `count` * `MemoryLayout<t>.stride`
/// - Warning: Binding memory to a type is potentially undefined if the
///   memory is ever accessed as an unrelated type.
</t></pre>

<table>
<thead>
<tr>
<th>操作</th>
<th>内存状态</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rawptr = allocate()</code></td>
<td>uninitialized</td>
<td>None</td>
</tr>
<tr>
<td><code>tptr = rawptr.bindMemory(T)</code></td>
<td>uninitialized</td>
<td>bound to T</td>
</tr>
<tr>
<td><code>tptr.initialize()</code></td>
<td>initialized</td>
<td>bound to T</td>
</tr>
</tbody>
</table>
<p>从上面的表格结合文档里面对于<code>bindMemory</code>的说明来看，我对于<code>bindMemory</code>的理解就是，使用函数之前这块内存空间是没有被初始化的，使用<code>bindMemory</code>的目的是将<code>T</code>绑定到<code>self</code>后面<code>self</code> + <code>count</code> <em> <code>MemoryLayout&lt;T&gt;.stride</code>长度的的这块内存空间上来。但是绑定上来并不代表初始化了，此时这个内存空间仍然是没有初始化的，所以最后需要调用函数<code>initialize</code>的函数来初始化!<br><br>用这个函数同样可以把`void </em>`的C类型转换为Swift的类型。关于<a href="2">Custom memory allocation</a><br>这个函数的使用可能会有问题…先上一段我自己理解的代码吧</p>
<pre>
let a = 100
let a_rawptr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout\<int>.size, alignedTo: MemoryLayout\<int>.alignment)
let bind_rawptr = a_rawptr.bindMemory(to: Int.self, capacity: MemoryLayout\<int>.stride)
bind_rawptr.initialize(to: a)
</int></int></int></pre>


<h4 id="unsafeBitCast"><a href="#unsafeBitCast" class="headerlink" title="unsafeBitCast"></a>unsafeBitCast</h4><p>返回一个翻译成某一特定类型的值！,<code>这个会破坏Swift的类型系统</code>！<br></p>
<blockquote>
<p>特别注意️:<br>不到万不得已不要使用这个函数</p>
</blockquote>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>PhotoCutter为了适配Swift3，这其中大部分和指针相关的东西需要适配，我开始看到这些也是懵逼的，根本不懂怎么改，只有自己去慢慢学。我的方法可能很差，就目前而言是适配了，下面贴上我的修改的代码吧!</p>
<blockquote>
<p>Swift2.x</p>
</blockquote>
<pre>
options = CFDictionaryCreate(kCFAllocatorDefault,
            UnsafeMutablePointer(UnsafePointer<void>(keys)),
            UnsafeMutablePointer(UnsafePointer<void>(values)),
            2,
            &kcKeysBack,
            &kcValuesBack)
</void></void></pre>

<blockquote>
<p>Swift3.0</p>
</blockquote>
<pre>
fileprivate func buffer<t>(to type:T.Type, source:[T]) -> UnsafeMutablePointer<unsaferawpointer?>{
    var buffer = UnsafeMutablePointer<unsaferawpointer?>.allocate(capacity: source.count)
    for idx in 0..<source.count {="" let="" m_ptr="UnsafeMutableRawPointer.allocate(bytes:" memorylayout<t="">.size, alignedTo: MemoryLayout<t>.alignment)
        let bindptr = m_ptr.bindMemory(to: type, capacity: 1)
        bindptr.initialize(to: source[idx])
         let pty = UnsafeRawPointer(m_ptr)
        buffer.advanced(by: idx).pointee = pty
    }
    return buffer
}
</t></source.count></unsaferawpointer?></unsaferawpointer?></t></pre>

<p>调用:</p>
<pre>
let keys:[CFString] = [
            kCGImageSourceCreateThumbnailWithTransform,
            kCGImageSourceCreateThumbnailFromImageIfAbsent,
            kCGImageSourceThumbnailMaxPixelSize]
var keybuffer = buffer(to: CFString.self, source: keys)
/\*
这之间做你的相关操作
*/
keybuffer.deallocate(capacity: keys.count)
</pre>

<p>到这里我对于swift3指针相关的东西，就告一段落了，文章写的很粗糙，望见谅，明天开始公司要求做持续化集成了，如果你看到这个而且想和我交流的话可以在博客上的微博和我取得联系，因为我是真的不懂博客。。。以后有时间会去学习一下前端相关的东西，练手项目应该就是我这个博客！<br><br>最后还是希望去看看<a href="3">C 语言指针 5 分钟教程</a>。<br><br><br></p>
<p>参考文献:<br><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">Use Swift With Cocoa</a><br><br><a href="https://swift.org/migration-guide/se-0107-migrate.html" target="_blank" rel="external">UnsafeRawPointer Migration Swift.org</a><br><br><a href="http://technology.meronapps.com/2016/09/27/swift-3-0-unsafe-world-2/" target="_blank" rel="external">Swift 3.0 Unsafe World</a><br><br><a href="http://stackoverflow.com/questions/39515173/how-to-use-unsafemutablepointer-in-swift-3" target="_blank" rel="external">StackOverflow Question</a><br><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation" target="_blank" rel="external">Binding memory type</a><br><br><a href="https://onevcat.com/2015/01/swift-pointer/" target="_blank" rel="external">Swift 中的指针使用</a>(这个是之前版本的介绍，就参考一下用unsafeBitCast，同时文章中提到的<a href="3">C 语言指针 5 分钟教程</a>)<br><br><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" target="_blank" rel="external">指针</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章水准不高，可能因为我自己能力有限，英文水平也就这样，自己能看懂，可能存在误人子弟的可能性，所以如果有人有机会看到了这边文章就当是一个小白的入门级的笔记吧！如果需要更深入的了解请查看文末的参考链接&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>创建一个更轻的ViewController</title>
    <link href="http://yoursite.com/2017/03/02/light_viewcontroller/"/>
    <id>http://yoursite.com/2017/03/02/light_viewcontroller/</id>
    <published>2017-03-01T16:26:53.000Z</published>
    <updated>2017-03-01T16:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的项目越来越臃肿，一个控制器的代码量越来越多，业务最繁重的一个控制器代码量已经达到了1000多行！这就导致给控制器瘦身是一定要做的。<br><a id="more"></a><br>说实话这种的是很不好组织语言的，但是还是按照惯例还是在这里来记录一下自己想法经历和结果。</p>
<blockquote>
<p>注意:<br>文中会同时出现Swift代码和objc代码，出现这个的原因是为了演示针对使用AF进行网络请求和数据处理，就用了其他工程的代码来进行演示。<br>样例工程是用Swift写的没有集成AF库，只是模拟了一个网络请求，但是Swift的代码同样适用于objc，这里大多的管理类都是继承自<code>NSObject</code>，希望见谅吧。<br><br></p>
</blockquote>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>现在我们的目的是来分离一个登录页面的Controller。我先把这个界面的效果图放出来</p>
<p><img src="/uploads/light_controller/light_controller_1.png" alt="登录界面"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个页面比较简单，一个简单的输入用户名称和密码，然后登录给出正确还是错误的结果！这里需要简单处理一下用户名密码的输入情况来绝对按钮的颜色的交互情况。<br>我将一个业务场景进行划分可以分为以下5个：</p>
<blockquote>
<p>1.控制器 ——-Controller<br>2.视图 ———ViewOperator<br>3.网络请求—–Request<br>4.数据处理—–DataManager<br>5.协议代理—–Delegate</p>
</blockquote>
<h3 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h3><h6 id="1-控制器-Controller"><a href="#1-控制器-Controller" class="headerlink" title="1.控制器(Controller)"></a>1.控制器(Controller)</h6><p>控制器的职责需要统调<code>视图(ViewOperator)</code>,<code>网络请求(Request)</code>,<code>数据处理(DataManager)</code>,<code>代理协议(Delegate)</code>以及不同控制器之间的联系。</p>
<h6 id="2-视图-ViewOperator"><a href="#2-视图-ViewOperator" class="headerlink" title="2.视图(ViewOperator)"></a>2.视图(ViewOperator)</h6><p>ViewOperator的作用是将控制器里面与视图相关的操作剥离出来。同时也包括了按钮的点击。</p>
<h6 id="3-协议代理-Delegate"><a href="#3-协议代理-Delegate" class="headerlink" title="3.协议代理(Delegate)"></a>3.协议代理(Delegate)</h6><p>剥离出controller中的delegate的回调，比如登录界面UITextField的相关代理操作，也可以是TableView的delegate和dataSource的分离。</p>
<h6 id="4-网络请求-Request"><a href="#4-网络请求-Request" class="headerlink" title="4.网络请求(Request)"></a>4.网络请求(Request)</h6><p>分离控制器中的网络请求部分，比如在一个包含了tableView的界面，数据加载，下拉刷新，上拉加载的相关方法.</p>
<h6 id="5-数据处理-DataManager"><a href="#5-数据处理-DataManager" class="headerlink" title="5.数据处理(DataManager)"></a>5.数据处理(DataManager)</h6><p>在网络请求完成的回调，回调回来的数据是不需要放在网络请求里面去做的，所以将网络请求数据回调放在<code>DataManager</code>中来。数据处理完成是需要给Controller一个数据回调的。</p>
<h3 id="第一步来分离Controller中的视图"><a href="#第一步来分离Controller中的视图" class="headerlink" title="第一步来分离Controller中的视图"></a>第一步来分离Controller中的视图</h3><p>通常视图相关的操作如果都放在Controller会产生很多行的代码的，所以第一步我们需要将控制器和视图相关操作分离出来。<br>在使用StoryBoard来创建一个ViewController时，需要在控制器中拖一些<code>button</code>,<code>label</code>,<code>textfield</code>等等控件，这些控件的定制以及交互等等都要拖出代码进行处理。<br>所以这里我可以给当前控制器的Scene添加一个<code>object</code></p>
<p><img src="/uploads/light_controller/light_controller_2.png" alt="object"><br>然后自定义个<code>LoginViewOperator</code>来继承自<code>NSObject</code>，将这个object的CustomClass改为<code>LoginViewOperator</code>。此时你可以将上诉的控件都拖到这个class里面，比如:</p>
<p><pre><br>public class LoginViewOperator:NSObject{<br>    @IBOutlet var fields: [UITextField]!<br>    @IBOutlet weak var login<em>btn: UIButton!<br>    @IBOutlet weak var indicator: UIActivityIndicatorView!<br>    @IBAction func login(</em> sender: UIButton) {<br>    }<br>}<br></pre>同时我也可以直接将<code>LoginViewOperator</code>拖到Controller中，来让Controller来管理LoginViewOperator `。</p>
<p><pre><br>class LoginViewController {<br>    @IBOutlet var view_operator: LoginViewOperator!<br>}<br></pre><br>如果有自定义视图的话，自定义视图的相关操作可以放在这个类中去做，或者可以给这个视图添加一个<code>helper</code>(<code>CustomViewHelper</code>)通过他来做自定义视图的相关操作</p>
<h3 id="第二步来分离Controller中的代理协议"><a href="#第二步来分离Controller中的代理协议" class="headerlink" title="第二步来分离Controller中的代理协议"></a>第二步来分离Controller中的代理协议</h3><p>加入在一个业务场景中有一个tableView，或者textfield，或者其他的系统的控件等等，和他们打交道肯定需要回调的，把这些放在控制器中也是很占位置的，必须将他们分离出来。<br>在当前场景主要是<code>UITextFieldDelegate</code>的分离，我们需要创建一个类继承自<code>NSObject</code>,并让他遵守<code>UITextFieldDelegate</code>。</p>
<p><pre><br>public class EDLoginTextFieldDelegate:NSObject{<br>   public var textdidChange:((UITextField)-&gt;Void)?<br>}<br>extension EDLoginTextFieldDelegate:UITextFieldDelegate{<br>    public func textFieldDidChange(<em> textField: UITextField){<br>        textdidChange?(textField)<br>    }<br>    public func textFieldShouldReturn(</em> textField: UITextField) -&gt; Bool {<br>        return true<br>    }<br>    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {<br>        return true<br>    }<br>}<br></pre>上面方法中<code>textFieldDidChange</code>是通过在<code>LoginViewOperator</code>中的UITextField添加的target-action的，这个会在接下来讲到。<br>此时在<code>LoginViewOperator</code>新建一个变量<code>delegate</code>:</p>
<p><pre><br>lazy var delegate:EDLoginTextFieldDelegate = EDLoginTextFieldDelegate().then{<br>   //text did change<br>  $0.textdidChange = {[unowned self] in<br>    //在这里处理当textfield在发生变化时，视图需要做出的改变，也就是上面gif中通过判断输入框中是否有值来改变button的alpha和enable的操作<br>  }<br>  //text did end<br>  //text did begin<br>}<br></pre>同时将<code>delegate</code>赋值给UITextField的delegate，修改上面outlet出来的<code>fields</code>变量：</p>
<p><pre><br>@IBOutlet var fields: [UITextField]!{<br>      didSet{<br>        fields.forEach{<br>          $0.delegate = delegate<br>          //给每一个field都添加一个target-action，这个action不要写在<code>LoginViewOperator</code>中，因为这个实际上和delegate是类似的，不是一个视图操作，所以我这里绕了一圈在delegate的textdidChange进行了回调。<br>          $0.addTarget(delegate, action: #selector(delegate.textFieldDidChange(_:)), for: .editingChanged)<br>      }<br>      if let username = User.mine.name{<br>         fields.first?.text = username<br>      }<br>    }<br>  }<br></pre>上面就是我在分离一个<code>UITextFieldDelegate</code>所做的操作。<br>在这里看来额外添加的这个<code>delegate</code>可能多此一举，因为操作相对比较少，但是如果是在tableView中的话，你需要在<code>numberOfSections</code>,<code>numberOfRowsInSection</code>,<code>cellForRowAt</code>以及<code>willDisplayCell</code>中需要写一大堆的逻辑，在这里就会体现出协议代理的分离带来的好处。</p>
<blockquote>
<p>在这里建议：如果在使用数据回调的时候可以使用delegate而不是block，这样就可以把放在controller中的block代码分离到CustomDelegate中来，后面在分离数据处理部分会用到delgate。</p>
</blockquote>
<h3 id="第三步来分离Controller中的网络请求"><a href="#第三步来分离Controller中的网络请求" class="headerlink" title="第三步来分离Controller中的网络请求"></a>第三步来分离Controller中的网络请求</h3><p>这一步我用objc的代码来进行讲解，因为在样例工程是没有涉及到网络请求的，所以我将我们公司项目的中的网络请求部分的分离代码贴出来。<br>同样我们需要创建一个类<code>DailyProhRequst</code>来继承于<code>NSObject</code>，该类分离控制器的网络请求。</p>
<p><pre><br>@interface DailyProhRequst : NSObject<br>@end<br></pre><br>并为<code>DaulyProhRequst</code>添加三个方法:</p>
<blockquote>
<p>下拉加载</p>
</blockquote>
<p><code>+ (NSInteger)headerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code></p>
<blockquote>
<p>上拉刷新的网络操作</p>
</blockquote>
<p><code>+ (NSInteger)footerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code></p>
<blockquote>
<p>简单的数据加载</p>
</blockquote>
<p><code>+ (NSInteger)reloadData:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;</code><br>如果需要上拉加载下拉刷新数据请求之类的，可以直接调用上面上个方法中的一个，在上面方法中还提到了<code>dataOperator</code>，它是用来整理数据的，这部分放到后面来讲。这三个方法只进行网络并把数据传给<code>dataOperator</code>，request对controller是没有回调的！<br><br>在上面的分离视图部分，我们将登录按钮的<code>@IBAction</code>放在了<code>LoginViewOperator</code>中，我们需要将这个按钮事件回调给控制器。<br>其实严谨来讲，我们是没有必要将按钮的<code>IBAction</code>放在视图中来的，这里是我的失误。<br>所以在控制器中点击按钮进行一个网络请求的操作就是<code>[DailyProhRequst headerRefresh:@{} currentPage:weakSelf.currentPage dataOperator:weakSelf.dataOperator]</code>，网络请求的分离相对来说比较简单。</p>
<h3 id="第四步创建数据操作类来管理数据"><a href="#第四步创建数据操作类来管理数据" class="headerlink" title="第四步创建数据操作类来管理数据"></a>第四步创建数据操作类来管理数据</h3><p>同上面一样适用objc的代码进行讲解。这里数据可以分为网络请求返回的数据和抽取本地db的数据，我主要讲一下通过网络获取数据进行数据处理的数据管理类。<br>首先我们同样需要创建一个类来继承自<code>NSObject</code>，并添加一个方法从<code>Requst</code>中获取原始的网络数据:</p>
<p><pre><br>@interface DailyProhDataOperator : NSObject<br>@end<br></pre>同时我们给DailyProhDataOperator类添加一个获取数据的方法<br><code>- (void)fetchData:(id)responseobject requstFailed:(NSError *)error;</code><br>而且我们的目的是必须要将处理好的数据（可能是你自己定一个数据模型）返回给Controller来更新View（由ViewOperator来更新操作）,所以需要创建一个delegate：</p>
<p><pre><br>@protocol DailyProhDataOperatorHandler <nsobject><br>@end<br></nsobject></pre><br>并给协议添加两个回调方法<br><code>- (void)dataOperatorSuccess:(DailyProhDataModel *)dataSource;</code><br><code>- (void)dataOperatorFailed:(NSError *)error;</code><br>然后给<code>DailyProhDataOperator</code>类添加一个代理属性<br><code>@property (weak ) id&lt;DailyProhDataOperatorHandler&gt; handler;</code><br>并在网络请求分离中的方法中进行修改:</p>
<p><pre> +(NSInteger)reloadData:(NSDictionary <em>)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator </em>)operators{<br>      //在网络请求或者失败的回调中添加数据处理类的入口<br>      //[operators fetchData:responseObject requstFailed:nil];<br>      return 0;<br>}<br></pre>在DataOperator中进行数据处理完成的回调<br><code>[self.handler dataOperatorSuccess:data];</code><br>这个delegate可以通过上面已经讲过的协议代理分离放在CustomDelegate的类中，由CustomDelegate和ViewOperator进行通信来达到根据数据来修改视图的效果。<br><br></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>虽然在样例工程中没有网络请求的部分，但是实际上网络请求在控制器中所占的代码就仅仅一个跳转相关的逻辑的代码而已，所以经过上诉的方式对controller进行瘦身之后，一个完整的功能的登录界面代码量为：</p>
<p><img src="/uploads/light_controller/light_controller_3.png" alt="瘦身的结果"><br>图中的request是我模拟的一个假的网络请求。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上诉的方式可以很大程度上将控制器代码进行缩减，而且指责划分也很明确。最后来说一下他们之间的关系：</p>
<blockquote>
<h6 id="Controller-lt-gt-ViewOperator"><a href="#Controller-lt-gt-ViewOperator" class="headerlink" title="Controller &lt;-&gt; ViewOperator"></a>Controller &lt;-&gt; ViewOperator</h6><p>通过ViewOperator修改视图，Controller相关交互之后通过ViewOperator来进行界面更行</p>
<h6 id="Controller-lt-gt-Delegate"><a href="#Controller-lt-gt-Delegate" class="headerlink" title="Controller  &lt;-&gt; Delegate"></a>Controller  &lt;-&gt; Delegate</h6><p>由delegate来分担Controller中的相关代理协议的工作，包括从delegate拿取数据等等，</p>
<h6 id="Controller-lt-gt-Requst"><a href="#Controller-lt-gt-Requst" class="headerlink" title="Controller &lt;-&gt; Requst"></a>Controller &lt;-&gt; Requst</h6><p>由Controller来发起Requst</p>
<h6 id="Requst-lt-gt-DataOperator"><a href="#Requst-lt-gt-DataOperator" class="headerlink" title="Requst &lt;-&gt; DataOperator"></a>Requst &lt;-&gt; DataOperator</h6><p>DataOperator从Request获取数据，并对数据进行整理</p>
<h6 id="Delegate-lt-gt-DataOperator"><a href="#Delegate-lt-gt-DataOperator" class="headerlink" title="Delegate &lt;-&gt; DataOperator"></a>Delegate &lt;-&gt; DataOperator</h6><p>DataOperator把整理好的数据返回给Delegate</p>
<h6 id="Delegate-lt-gt-ViewOperator"><a href="#Delegate-lt-gt-ViewOperator" class="headerlink" title="Delegate &lt;-&gt; ViewOperator"></a>Delegate &lt;-&gt; ViewOperator</h6><p>Delegate把数据传给ViewOperator之后，由ViewOperator更新视图</p>
</blockquote>
<p>这个只是罗列出了在当前业务逻辑下面他们之间的相互关系，只是为了梳理一下思路，在不同的逻辑下有不同的组合，但是一个业务场景在代码实现层面可以大体分成五种或者更多的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的项目越来越臃肿，一个控制器的代码量越来越多，业务最繁重的一个控制器代码量已经达到了1000多行！这就导致给控制器瘦身是一定要做的。&lt;br&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>BLUEPILL在项目中的实践</title>
    <link href="http://yoursite.com/2017/03/02/bluepill/"/>
    <id>http://yoursite.com/2017/03/02/bluepill/</id>
    <published>2017-03-01T16:17:45.000Z</published>
    <updated>2017-03-01T16:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/bluepill/bluepill_1.png" alt=""><br>  Bluepill借助于<a href="https://github.com/mmmulani/class-dump-o-tron/tree/master/Applications/Xcode.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework/Versions/A/CoreSimulator" target="_blank" rel="external">CoreSimulator</a>解决稳定性和可扩展性问题。使用CoreSimulator实现了将Bluepill从Xcode模拟器中隔离出来，并使Bluepill可并行使用多种模拟器运行测试。这里Xcode模拟器是一种随每次Xcode的更新而不断进化的黑盒。（来自<a href="http://www.infoq.com/cn/news/2017/01/linkedin-bluepill-ios-testing" target="_blank" rel="external">InfoQ介绍bluepill</a>时的一段话）<br><a id="more"></a><br>  在bluepill的<a href="https://github.com/linkedin/bluepill/releases/" target="_blank" rel="external">Release</a>可以下载到的压缩包解压，然后在终端中敲入命令:</p>
<p><pre><br>./bluepill -a ./Sample.app -s ./SampleAppTestScheme.xcscheme -o ./output/<br></pre><br>很简单，对于这最基本的命令，我们只需要有<code>.app</code>和<code>.xcscheme</code>这两个文件，然后将上面下载下来的压缩包解压之后的两个文件放在恰当的位置，应该就可以了。如果真的是这样，这篇文章也就没有存在的价值了，在这篇文章中将要做下面这几件事：</p>
<ul>
<li>Xcode工程项目结构体系；</li>
<li>如何获取上面提到的两个文件并使用上面这个最简单命令跑起来（是否包含了Test，如果没有需要添加Test）；</li>
<li>Xcode中Test的基本操作；</li>
<li>相关参数说明；</li>
</ul>
<blockquote>
<p>当前环境:<br>macOS Sierra 版本 10.12.3<br>Xcode Version 8.2.1<br>在我使用bluepill时，它只能在iOS 10.2环境下运行，查看Xcode支持的模拟器版本:<code>xcrun simctl list runtimes</code></p>
</blockquote>
<h2 id="实践前需要知道的概念"><a href="#实践前需要知道的概念" class="headerlink" title="实践前需要知道的概念"></a>实践前需要知道的概念</h2><p>下面介绍的这几个概念在<a href="https://developer.apple.com/library/content/featuredarticles/XcodeConcepts/Concept-Targets.html#//apple_ref/doc/uid/TP40009328-CH4-SW1" target="_blank" rel="external">Apple Developer</a>都可以找到，我仅仅把我认为比较有用的信息罗列出来一下。更多关于设置和使用方面我在文末列出来了，可以自己查看！</p>
<h4 id="Xcode-Project"><a href="#Xcode-Project" class="headerlink" title="Xcode Project"></a>Xcode Project</h4><p> <code>project</code>包含了需要构建一个应用程序需要的所有的文件，资源和相关信息，而<code>workspace</code>是能够包含多个project的。</p>
<blockquote>
<p>注意<br>一个<code>project</code>是可以包含多个<code>targets</code>的！</p>
</blockquote>
<p>每个<code>project</code>都定义了一个默认的<strong>build settings</strong>。因为每个project包含了多个<code>targets</code>，所以我们可以为每个targets设置不同的build settings（在文档中特别说明了每个targets的build settings是重写了其所属的project的build settings）。</p>
<h4 id="Xcode-Workspace"><a href="#Xcode-Workspace" class="headerlink" title="Xcode Workspace"></a>Xcode Workspace</h4><p><code>Workspace</code>是可以包含任意个<strong>project </strong>的，但是一个project又可以属于多个WorkSpace。对于处于同一个Workspace的不同project，由于workspace中所有project的所有文件都是位于同一个文件目录中，因此<strong>并不需要拷贝它们到每一个project文件夹中</strong>。对于Workspace的这个共同目录，我们是可以自己指定一个构建目录（build directory）的，但是如果指定了构建目录在build project时，这个project所在的所有workspace的构建目录都将覆盖这个指定的构建目录！</p>
<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p><code>target</code>指定了要构建的目标，在bluepill中会包含<code>samepleApp</code>、<code>samepleApp_Test</code>等targets。同时我们可以修改target的<strong>build setting和build phases</strong>，target会继承project的build setting，但是我们为target指定不同的build settings来覆盖project的build setting。</p>
<h4 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h4><p><code>scheme</code>是需要被build的target的集合。可以在Xcode中选择不同的<strong>scheme</strong>来指定当前需要build的target(在Xcode中同时只能选择一个scheme)。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="开荒阶段"><a href="#开荒阶段" class="headerlink" title="开荒阶段"></a>开荒阶段</h3><p>在开荒阶段是没有使用WorkSpace的，一切的基础都是在Project上。</p>
<h6 id="1-创建一个不包含Test和UITest的空项目"><a href="#1-创建一个不包含Test和UITest的空项目" class="headerlink" title="1.创建一个不包含Test和UITest的空项目"></a>1.创建一个不包含Test和UITest的空项目</h6><p>  创建一个文件夹用来保存工程项目和下载的blupill解压出来的两个文件：<strong>bluepill和bp</strong>；<br>  学过C语言的都知道，在使用<code>cc xxx.c</code>文件之后会生成一个<code>.o</code>文件，当然也可以使用<code>cc xxx.c -o selfpill</code>来重命名这个-o文件，使用selfpill文件的命令是：<code>./selfpill</code>（因为c的main的参数就是接收的终端命令），所以我猜测这其实c的一个-o文件，为了使用这两个文件，就需要将上述提到的bluepill和bp和工程项目放在同一个文件夹下。<br>  这一步中我们创建不包含Test和UITest的空项目即不要勾选那两个和test相关的Checkbox，你肯定会疑问为什么要这么做，当我在看<a href="https://github.com/linkedin/bluepill/blob/master/README.md" target="_blank" rel="external">BLUEPILL的README</a>的时候特别指出如果是使用终端进行build(使用xcodebuild，后面我会把这一步放在脚本中)的话需要使用<code>build-for-testing</code>，我猜测应该和test是有关的。所以我先测试一下没有test的情况是否会出错，如果出错，错误是什么？</p>
<h6 id="2-编译这个空项目"><a href="#2-编译这个空项目" class="headerlink" title="2.编译这个空项目"></a>2.编译这个空项目</h6><p>  项目创建好之后编译一下之后第一目的就是在终端中输入上文提到的命令，但是这里有两个疑问：-a的参数<strong>.app</strong>的路径是什么？-s的<strong>.xcscheme</strong>的路径是什么？.app就是前面我们通过编译一次获得的一个文件夹，这个文件夹的地址是<code>/Users/xxxx/Library/Developer/Xcode/DerivedData/</code>在 DerivedData文件夹下找到刚刚创建的项目并点击进去，<strong>.app</strong>文件夹就在<code>Build/Products/Debug-iphonesimulator/</code>，如果你在创建好之后没有编译Products就是一个空文件夹；而<strong>.xcscheme</strong>在<code>工程项目所在文件夹/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme</code>路径中提到的xxx是你在创建项目时的用户名。<br>好了，现在我们可以在终端中数据命令:</p>
<p><pre><code>./bluepill -a /Users/xxx/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/xxx/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -o output</code></pre><br>敲回车之后我这里出现如下报错：</p>
<p><pre><br>ERROR: There is no ‘Plugins’ folder inside your app bundle at:<br>/Users/Wil/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app<br>Perhaps you forgot to ‘build-for-testing’? (Cmd + Shift + U) in Xcode.<br>Also, if you are using XCUITest, check <a href="https://github.com/linkedin/bluepill/issues/16" target="_blank" rel="external">https://github.com/linkedin/bluepill/issues/16</a><br></pre><br>出现这个问题的原因是在.app文件夹下面没有<strong>Plugins</strong>文件夹。就算是按照提示说使用<code>Cmd + Shift + U</code>或者使用<code>xcodebuild build-for-testing</code>仍然是行不通的。走到这里我们有两条路，可以删除当前工程重新建一个包含了Test和UITest的项目，也可以在现有的Project中添加Test和UITest的Targets。我选择第二条，因为在我实际项目在这之前也是没有包含相关Test的。</p>
<h6 id="3-在包含Test的Project中实践"><a href="#3-在包含Test的Project中实践" class="headerlink" title="3.在包含Test的Project中实践"></a>3.在包含Test的Project中实践</h6><p>  现在我们需要在既有Project中添加一个Targets，<code>File/New/Target.../iOS Unit Testing Bundle</code>创建并在<strong>Scheme Menu</strong>中选择<code>New Scheme</code>选中刚刚我们添加的Targets。编译一下（这里可以使用Cmd + Shift + U或者选择Test的scheme并build，也可以使用<code>build-for-testing</code>命令:</p>
<p><pre><code>xcodebuild build-for-testing -project bluepill_sameple/bluepill_sameple.xcodeproj/ -scheme bluepill_sameple -sdk iphonesimulator10.2 -derivedDataPath build/</code></pre><br>进入.app文件夹下查看是否已经有了<code>PlugIns</code>文件夹，如果存在该文件夹则继续执行上一次出错的那个命令，运行成功，到这里已经能够使用最基础的命令。<br>  前面提到可以选择Test的scheme并build，可能会出现一点问题:<code>The scheme &#39;bluepill_samepleTests&#39; is not configured for Running</code>。因为添加了这个Test的Target之后需要编辑一下对应的Scheme使它能够进行Running操作！具体的操作如下所示：</p>
<p><img src="/uploads/bluepill/bluepill_2.png" alt=""><br>设置之后Cmd + B成功运行！</p>
<h3 id="完善阶段"><a href="#完善阶段" class="headerlink" title="完善阶段"></a>完善阶段</h3><h4 id="基本参数解释和使用"><a href="#基本参数解释和使用" class="headerlink" title="基本参数解释和使用"></a>基本参数解释和使用</h4><ul>
<li><strong>-a/-s/-o</strong>:这是三个最基本的参数，在前面使用的时候应该知道如何使用，这里不再进行解释！</li>
<li><strong>-c</strong>:读取一个自定义的<code>config.json</code>文件作为bluepill的运行参数，例如:<pre><code>./bluepill -c config.json</code></pre></li>
<li><strong>-l</strong> :获取在当前project中存在的testcase，它的打印结果是存在于<code>.../bluepill_sameple.app/PlugIns</code>文件夹下面！现在我为了演示多建立了一个Test Target(添加Scheme)然后编译：<br><pre><code>./bluepill -a /Users/用户名/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/用户名/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/Wil.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -l</code></pre>打印结果:<pre><br>bluepill_samepleTests.xctest<br>bluepill_samepleTests_target.xctest</pre>文件夹:<br><img src="/uploads/bluepill/bluepill_3.png" alt=""></li>
<li><strong>-x/-i</strong>:<code>-x</code>在运行bluepill的时候不包含某一个testcase，<code>-i</code>和<code>-x</code>相反，它则是要包含某一个testcase，<code>-x</code>的优先级是大于<code>-i</code>的。<br><pre><br>./bluepill -a xxxx.app -s xxxx.xcscheme -x bluepill_samepleTests.xctest -r ‘iOS 10.2’;<br>./bluepill -a xxxx.app -s xxxx.xcscheme -i bluepill_samepleTests.xctest -r ‘iOS 10.2’;<br></pre>其中关于<code>-x</code>和<code>-i</code>的参数可使用<code>-l</code>命令来获取！</li>
<li><strong>-d/-n</strong>:使用命令：<code>xcrun simctl list devices</code>来获取当前可用的模拟器设备，在得到这些设备之后可以使用<code>-d</code>来指定需要启动的设备！其中<code>-n</code>可以指定同时运行的模拟器数量。比如：<br><pre><br>./bluepill -a xxxx.app -s xxxx.xcscheme -r ‘iOS 10.2’  -d ‘iPhone 5s’;<br></pre>其中命令前面是一样的，这里先省略！<br>对于真机：在<a href="https://github.com/linkedin/bluepill/issues/61" target="_blank" rel="external">bluepill的Issue页面</a>指出blupill不支持真机！</li>
</ul>
<p>目前对于bluepill的实践先到这里，后续还会继续更新遇到的相关问题！</p>
<p><strong>相关链接:</strong></p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/ConfiguringYourApp/ConfiguringYourApp.html" target="_blank" rel="external">Configuring Your Xcode Project</a></li>
<li><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="external">Xcode Build Settings Reference</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/bluepill/bluepill_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;  Bluepill借助于&lt;a href=&quot;https://github.com/mmmulani/class-dump-o-tron/tree/master/Applications/Xcode.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework/Versions/A/CoreSimulator&quot;&gt;CoreSimulator&lt;/a&gt;解决稳定性和可扩展性问题。使用CoreSimulator实现了将Bluepill从Xcode模拟器中隔离出来，并使Bluepill可并行使用多种模拟器运行测试。这里Xcode模拟器是一种随每次Xcode的更新而不断进化的黑盒。（来自&lt;a href=&quot;http://www.infoq.com/cn/news/2017/01/linkedin-bluepill-ios-testing&quot;&gt;InfoQ介绍bluepill&lt;/a&gt;时的一段话）&lt;br&gt;
    
    </summary>
    
      <category term="实战" scheme="http://yoursite.com/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="BLUEPILL" scheme="http://yoursite.com/tags/BLUEPILL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP持久连接</title>
    <link href="http://yoursite.com/2017/02/27/http_keep_alive/"/>
    <id>http://yoursite.com/2017/02/27/http_keep_alive/</id>
    <published>2017-02-27T15:18:00.000Z</published>
    <updated>2017-02-27T15:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP/1.1允许http设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的http请求重用现存的连接。在事务处理结束之后仍然保持打开状态的TCP连接被称为<strong>持久连接</strong>。持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭。<br>已经打开的连接可以避免慢启动的拥堵适应阶段。以便更快的进行数据传输。<br><a id="more"></a> </p>
<h2 id="持久以及并行连接"><a href="#持久以及并行连接" class="headerlink" title="持久以及并行连接"></a>持久以及并行连接</h2><p>并行连接的缺点: </p>
<ul>
<li>每个事务打开／关闭一个新的连接，会耗费时间和宽带的；</li>
<li>由于TCP慢启动，每条新连接的性能都会有降低；</li>
<li>可打开的并行连接数量实际上是有限的。</li>
</ul>
<p>持久连接降低了时延和建立连接的开销，但是持久连接时可能会累积出大量的空闲连接。所以需要配合使用持久连接和并行连接。</p>
<h2 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+ keep-alive连接"></a>HTTP/1.0+ keep-alive连接</h2><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>实现了HTTP/1.0 keep-alive连接的客户端可以通过包含<code>Connection: Keep-Alive</code>首部请求将一条连接保持在打开状态。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>如果服务器愿意为下一条请求将连接保持在打开状态，就在通用首部中包含相同的内容。如果没有包含<code>Connection: Keep-Alive</code>首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。<br><img src="/uploads/md_srouce/http_keep_alive_1.png" alt="HTTP:1.0 keep-alive事务首部的握手过程.png"></p>
<blockquote>
<p>⚠️注意<br>keep-alive首部只是请求将连接保持在活跃状态。在发出keep-alive请求之后，客户端和服务器可以在任意时刻关闭空闲的keep-alive连接，并可以限制keep-alive连接所处理事务的数量。</p>
</blockquote>
<h4 id="通用首部Keep-Alive选项"><a href="#通用首部Keep-Alive选项" class="headerlink" title="通用首部Keep-Alive选项"></a>通用首部<code>Keep-Alive</code>选项</h4><ul>
<li>参数timeout是在Keep-Alive响应首部发送的。它<strong>估计</strong>了服务器希望将连接保持在活跃状态的时间。</li>
<li>参数max是在Keep-Alive响应首部发送的。它<strong>估计</strong>了服务器还希望为多少个事务抱持此连接的活跃状态。</li>
<li>Keep-Alive首部还可支持任意未经处理的属性。语法为：name [=value]</li>
</ul>
<p>Keep-Alive首部只有在提供了<code>Connection:Keep-Alive</code>时才能使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection:Keep-Alive</div><div class="line">Keep-Alive:max=5, timeout=120</div></pre></td></tr></table></figure></p>
<h4 id="Keep-Alive连接的限制和规则"><a href="#Keep-Alive连接的限制和规则" class="headerlink" title="Keep-Alive连接的限制和规则"></a>Keep-Alive连接的限制和规则</h4><ul>
<li>在HTTP1.0中，keep-alive并不是默认使用的。客户端必须发送一个<code>Connection:Keep-Alive</code>请求首部来激活keep-alive连接；</li>
<li>代理或网关必须将报文转发或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。</li>
<li>不应该与无法确定是否支持Connection首部代理服务器建立keep-alive连接，以防止出现哑代理。</li>
</ul>
<h2 id="HTTP-1-1-持久连接-Persistent-Connection"><a href="#HTTP-1-1-持久连接-Persistent-Connection" class="headerlink" title="HTTP/1.1 持久连接(Persistent Connection)"></a>HTTP/1.1 持久连接(Persistent Connection)</h2><p>HTTP/1.1 持久连接在默认情况下是<strong>激活</strong>的，要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显示的添加一个<code>Connection:close</code>首部。不然HTTP/1.1 连接就仍然维持在打开状态。</p>
<blockquote>
<p>⚠️<br>不发送<code>Connection:close</code>并不意味着服务器承诺永远将连接保持在打开状态。</p>
</blockquote>
<h4 id="持久连接的限制和规则"><a href="#持久连接的限制和规则" class="headerlink" title="持久连接的限制和规则"></a>持久连接的限制和规则</h4><ul>
<li>发送了Connection:close请求首部之后，客户端就无法在那条连接上发送更多的请求了。 </li>
<li>如果客户端不想再连接上发送其他请求，就应该在最后一条请求中发送一个Connection:close请求首部。</li>
<li>只有当连接上所有报文的实体主体部分的长度和首部字段<code>Content Length</code>一样（或者用分块传输编码方式），这样连接才能持久保持</li>
<li>HTTP1.1的代理服务器不应该与HTTP1.0客户端建立持久连接。</li>
<li><strong>HTTP1.1设备可以在任意时刻关闭连接</strong>，尽管是出于传输报文的过程中关闭连接。</li>
</ul>
<h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>HTTP1.1允许在持久连接上可选的使用<code>请求管道</code>。这是在keep-alive连接上的进一步性能优化。<br>在响应到达前，可以<strong>将多条请求放入队列中</strong>，这样做可以降低网络的环回时间，提高性能。</p>
<h4 id="管道化连接的几个限制"><a href="#管道化连接的几个限制" class="headerlink" title="管道化连接的几个限制"></a>管道化连接的几个限制</h4><ul>
<li>如果http客户端无法确认连接是持久的，就不应该使用管道；</li>
<li>必须按照与请求相同的顺序回送http响应。</li>
<li>http客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>http客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。</li>
</ul>
<p><img src="/uploads/md_srouce/http_keep_alive_2.png" alt="管道化连接.png"></p>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>在连接管理中需要知道什么时候关闭连接以及如何去关闭连接。</p>
<h4 id="“任意”接触连接"><a href="#“任意”接触连接" class="headerlink" title="“任意”接触连接"></a>“任意”接触连接</h4><p><strong>所有的HTTP客户端、服务器或者代理都可以在任意时刻关闭一条TCP传输连接</strong>。通常会在一条报文结束时关闭连接。</p>
<blockquote>
<p>但是，服务器永远都无法确定在它关闭“空闲”连接那时候，在客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现连接错误的请求。</p>
</blockquote>
<h4 id="Content-Length及截尾操作"><a href="#Content-Length及截尾操作" class="headerlink" title="Content-Length及截尾操作"></a>Content-Length及截尾操作</h4><p>每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主题的尺寸。<br>客户端或者代理受到一条随连接关闭而结束的http响应，且实际传输的实体长度与<code>Content-Length</code>并不匹配，接收端就应该质疑长度的正确性。<br>如果接收端是缓存代理，接收端就不应该缓存这条响应。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”Content-Length。</p>
<h4 id="连接关闭容限，重试以及幂等性"><a href="#连接关闭容限，重试以及幂等性" class="headerlink" title="连接关闭容限，重试以及幂等性"></a>连接关闭容限，重试以及幂等性</h4><p>如果客户端执行事务的过程中，传输连接关闭了，<strong>那么除非事务处理会带来一些副作用，否则客户端就应该重新打开连接</strong>，并重试。</p>
<h6 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h6><p>如果一个事务，不管是执行一次还是多次，得到的结果都是相同的，那么这个事务就是幂等的。</p>
<blockquote>
<p>GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都是的。</p>
</blockquote>
<p>客户端不应该用管道化的方式传送非幂等请求(就是说比如POST请求不应该使用管道化方式)。</p>
<h4 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h4><p>TCP连接都是双向的。tcp连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。<br><img src="/uploads/md_srouce/http_keep_alive_3.png" alt="tcp双向的连接.png"></p>
<h6 id="完全关闭和半关闭"><a href="#完全关闭和半关闭" class="headerlink" title="完全关闭和半关闭"></a>完全关闭和半关闭</h6><p>应用程序可以关闭tcp输入和输出信道中的任意一个，或者将两者都关闭了。</p>
<blockquote>
<p>套接字调用<code>close()</code>会将tcp连接的输入和输出信道都关闭，这就是<strong>完全关闭</strong>。<br>用<code>shutdown()</code>单独关闭输入或者输出信道，被称为<strong>半关闭</strong>。</p>
</blockquote>
<h6 id="TCP关闭及重置错误"><a href="#TCP关闭及重置错误" class="headerlink" title="TCP关闭及重置错误"></a>TCP关闭及重置错误</h6><p>总之，<strong>关闭连接的输出信道总是很安全的</strong>。连接另一端的对等实体会在其缓冲区中读出所有数据之后收到一条通知，说明流结束了。<br><strong>关闭连接的输入信道比较危险</strong>，除非你知道另一端不打算再发送其他数据。如果另一端向你已关闭的输入信道发送数据，操作系统会向另一端的机器回送一条TCP“<strong>连接被对端重置</strong>”。</p>
<blockquote>
<p>大部分操作系统都会将这种情况作为严重错误来处理，<strong>删除对端还未读去的所有缓存数据</strong>。但是这样做对于管道化来说简直就是噩梦，因为:比如你已经在一条持久连接上发送了10条管道式请求，响应已经收到了，正在操作系统的缓存区中存着。但是你发送了第11条请求，但是服务器认为你使用这条连接的时间太长，决定将其关闭，这个重置信息会清空你的缓冲区。</p>
</blockquote>
<h6 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h6><p>实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据之后，连接就会被完全关闭，而不会有重置风险。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP/1.1允许http设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的http请求重用现存的连接。在事务处理结束之后仍然保持打开状态的TCP连接被称为&lt;strong&gt;持久连接&lt;/strong&gt;。持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭。&lt;br&gt;已经打开的连接可以避免慢启动的拥堵适应阶段。以便更快的进行数据传输。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《C和指针Note》之数组和指针</title>
    <link href="http://yoursite.com/2017/02/22/c_and_pointer_note_case4/"/>
    <id>http://yoursite.com/2017/02/22/c_and_pointer_note_case4/</id>
    <published>2017-02-22T15:55:26.000Z</published>
    <updated>2017-02-22T16:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录指针和数组直接的关系!<br><a id="more"></a><br>当前C语言环境:</p>
<pre>
Apple LLVM version 8.0.0 (clang-800.0.38)
Target: x86_64-apple-darwin15.6.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
</pre>

<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>数组名的值是一个指针常量，也是数组第一个元素的地址。</p>
<blockquote>
<p>注意⚠️<br>数组具有确定的数量的元素，而指针只是一个标量值，<strong><em>只有数组名在表达式中使用时，编译器才会为他参数一个指针常量(意思就是你不能修改这个指针的值)</em></strong>。</p>
</blockquote>
<p>指针常量所指向的是内存中数组的起始位置，如果修改这个指针常量，唯一可行的操作就是把整个数组移动到内存的其他位置，但是在程序完成链接之后，内存中数组的位置是固定的，所以当程序运行时，在想移动数组就晚了。</p>
<h5 id="数组名不作为指针常量来表示的两种场景"><a href="#数组名不作为指针常量来表示的两种场景" class="headerlink" title="数组名不作为指针常量来表示的两种场景"></a>数组名不作为指针常量来表示的两种场景</h5><blockquote>
<p>注意：这里说的是<strong>不作为</strong>指针常量。</p>
</blockquote>
<ul>
<li>1.数组名作为sizeof操作符：<br>sizeof返回整个数组所占用的字节，而不是每个元素所占用的字节，也不是指向数组的指针的长度。</li>
<li>2.数组名用于单目操作符&amp;时：<br>返回一个指向数组的指针，而不是一个指向指针常量的指针。</li>
</ul>
<pre>
int a[10];
int *c;
c = &a[0];c = a;//这里赋值的是一个指针的拷贝。
</pre>

<h3 id="下标引用和指针-间接取值操作"><a href="#下标引用和指针-间接取值操作" class="headerlink" title="下标引用和指针(间接取值操作)"></a>下标引用和指针(间接取值操作)</h3><p><code>array[3]，*(array + 3)</code>出了优先级之外，下标引用和间接访问完全相同。</p>
<p><pre><br>int array[10];<br>int *ap = array + 2;<br></pre></p>
<ul>
<li>1.<code>ap</code>:这是一个指针地址，所以该表达式和<code>&amp;array[2]</code>或者<code>array+2</code>相同。</li>
<li>2.<code>*ap</code>:间接访问，与<code>array[2]</code>和<code>*(array + 2)</code>相同。</li>
<li>3.<code>ap[6]</code>:C的下标引用和间接访问表达式是一样的，所以ap[6]和<code>*(ap + 6)</code>相同，与<code>array[8]</code>和<code>*(array + 8)</code>相同。</li>
<li>4.<code>ap + 6</code>:ap为一个指针地址，地址向后偏移6，则<code>ap + 6</code>和<code>&amp;array[8]</code>，<code>array + 8</code>相同。</li>
<li>5.<code>*(ap + 6)</code>:上面说过<code>ap+6</code>为一个地址，由此可以得出<code>*(ap+6)</code>为间接求得地址对应的值，它和<code>array[8]</code>和<code>*(array+8)</code>相同，其实它和<code>2&gt;.</code>类似。</li>
<li>–&gt;6.<code>ap[-1]</code>:使用-1的偏移量使得道它前一个元素，也就是<code>array[1]</code>或者<code>*(array + 2 - 1)</code>。</li>
</ul>
<p>上面说这么多，其实只要抓住：当前表示的地址，元素还是间接获取操作就可以了。</p>
<blockquote>
<p>注意⚠️:<br>上面提到的<strong>“C的下标引用和间接访问表达式是一样的”</strong>。</p>
</blockquote>
<h6 id="思考题"><a href="#思考题" class="headerlink" title="思考题:"></a>思考题:</h6><p><code>2[array]</code>，这个表达式中的array是上文中的array。在这个上下文环境中，<code>2[array]</code>表达的意思是什么：</p>
<h6 id="解答"><a href="#解答" class="headerlink" title="解答:"></a>解答:</h6><p>因为前面我一直在强调，下标引用和间接表达式求值是相同的，所以:</p>
<ul>
<li>第一步：我们可以把<code>2[array]</code>改写成<code>*(2 + array)</code></li>
<li>第二步:由于加法运算符的两个操作数是可以交换位置的，所以把上面的表达式改写为:<code>*(array + 2)</code>;<br>也就是说<code>2[array]</code>其实和<code>array[2]</code>是相等的。</li>
</ul>
<h6 id="关于指针间接操作符和下标操作的比较"><a href="#关于指针间接操作符和下标操作的比较" class="headerlink" title="关于指针间接操作符和下标操作的比较"></a>关于指针间接操作符和下标操作的比较</h6><blockquote>
<p>相对于指针的间接访问和下标操作，在可读性方面下标的方式更好，但是在执行效率上面<strong><em>下标不会比指针更有效率，但是指针有时候比下标效率更高</em></strong>。</p>
</blockquote>
<p>具体的效率比较为:</p>
<ul>
<li>1.当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。</li>
<li>2.声明为寄存器变量的指针通常比用于静态内存和堆栈中的指针效率更高。<br>关于如何将变量声明为寄存器变量，我们可以使用<code>register</code>关键字来声明，比如:<code>register int *p1;</code>，<code>register</code>：这个关键字请求编译器尽可能的将变量存在CPU 内部寄存器中而不是通过内存寻址访问以提高效率。<strong>register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址运算符“&amp;”来获取register 变量的地址。</strong></li>
<li>3.像&amp;array[2]或者array+2这种在运行时求值的常量表达式代价很高。</li>
</ul>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>数组的初始化需要一系列的值，例如：</p>
<p><pre><br>int array[5] = {1,2,3,4,5};//如果在初始化的时候，初始化的个数比数组的大小小的话，空余的元素将会被赋值为0。<br>int array[] =  {1,2,3,4,5};//如果在声明中没有给出数组的长度，编译器会把数组的长度设置为刚好能够容易所有初始值的长度。<br></pre>对于<strong>静态数组</strong>：存储于静态内存的数组只初始化一次，当程序执行时，静态数组已经初始化完毕。如果数组没有被初始化，数组元素的初始值将会自动设置为0。<br>对于<strong>自动变量</strong>：由于自动变量位于运行时堆栈，所以自动变量在缺省的情况下是未被初始化的。<br>所以这里需要思考的是：当数组的初始化在一个函数中，程序在每次进入该函数的时候，是否值得每次都对该数组重新进行初始化。如果不需要的的话，我们可以把该数组声明为<code>static</code>。</p>
<p>######指定初始化器(c99)<br>只初始化数组中的指定元素，方法是：在初始化列表中使用带方括号的下标指明待初始化的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int array[5] = &#123;[5] = 23&#125;;//把array[5]初始化为23</div></pre></td></tr></table></figure></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>如<code>int xy[3][2]</code>数组维数不止一个的称为<code>多维数组</code>。<br>数组<code>xy[3][2]</code>在内存中的存储顺序为:</p>
<p><pre><code>(0,0) (0,1)  (1,0) (1,1)  (2,0) (2,1)//多维数组中的元素存储顺序按照最右边的下标率先变化的原则，称为<strong>行主序</strong>。</code></pre>关于是把第一个下标(上面定义的数组<code>xy</code>中的3)解释为行还是解释为列，都可以的，只要你在使用这个数组的时候使用同一种就可以。如果你把第一个下标解释为行第二个下标解释为列，那么当你按照存储顺序逐个访问数组元素时，所获得的元素是按行排列的，相反则是按列排列的。</p>
<h3 id="数组名和下标"><a href="#数组名和下标" class="headerlink" title="数组名和下标"></a>数组名和下标</h3><p><code>int xy[3][2]</code>，数组名<code>xy</code>是一个指向包涵2个整型元素的数组的指针（指向数组的指针）。<br>下面我们来看看数组的下标和指针之间的关系:</p>
<ul>
<li>1.<code>xy</code>:在三个包含两个整型元素的数组中，<code>xy</code>为指向第一个子数组。（注意：这是指针，说明了指向）</li>
<li>2.<code>xy + 1</code>:在三个包含两个整型元素的数组中，<code>xy</code>为指向第二个子数组，+1是根据包含2个整型元素的数组长度进行调整的，所以是指向第二个子数组。（注意：同上，这是指针，说明了指向）</li>
<li>3.<code>*(xy + 1)</code>:获取指向第二个子数组的指针，通过间接操作符得到这个子数组，或者可以把该表达式写为<code>xy[1]</code>（即表示的是第二个子数组）。</li>
<li>4.<code>*(xy + 1) ＋ 1</code>：在第三点中我们取得了第二个子数组，记得我们在上面讲一维数组的时候，获取数组第n个元素的地址的办法是:<code>array + n</code>或者<code>&amp;array[n]</code>，在和<code>*(xy + 1) ＋ 1</code>进行对比之后不难发现，其表达的意思就是获取第二个子数组中第2个元素（因为数组下标是从0开始）的地址或者可以把该表达式写为<code>xy[1] ＋ 1</code>（注意：同上，这是指针，是一个地址）</li>
<li>5.<code>*(*(xy + 1) + 1)</code>：由间接操作符，获得第4点中的指针指向的具体元素。同上我们可以写为:<code>*(xy[1] + 1)</code>，进一步改写<code>xy[1][1]</code>;</li>
</ul>
<h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p><pre><br>int vector[10];<br>int matrix[3][4];<br>int *vp = vector;<br>int (*mp)[10] = matrix;//下标引用的优先级是高于间接引用的，所以我们需要在间接引用这里手动加上括号才行<br></pre>所以<code>mp</code>是一个指向整型数组的指针，<code>vp</code>是指向整型变量的指针。</p>
<blockquote>
<p>这里需要注意一下：<br>一定不要把指向数组的指针和指针数组浓混了，那个确保算术优先级的括号是很重要的，<code>int (*mp)[10]</code>代表的是指向数组的指针，而<code>int *mp[10]</code>表示的是指针数组。</p>
</blockquote>
<p>当数组作为函数的参数的时候，多维数组和一维数组相同，<strong>都是用指针作为参数进行传递，这个指针是指向数组第一个元素的指针</strong>。</p>
<h6 id="一维数组作为函数参数的函数声明形式"><a href="#一维数组作为函数参数的函数声明形式" class="headerlink" title="一维数组作为函数参数的函数声明形式"></a>一维数组作为函数参数的函数声明形式</h6><p>实参：<code>int vectors[10];</code><br>函数声明:<code>void vector(int *vec);</code>或者<code>void vector (int vet[])</code></p>
<h6 id="多维数组作为函数参数的函数声明形式"><a href="#多维数组作为函数参数的函数声明形式" class="headerlink" title="多维数组作为函数参数的函数声明形式"></a>多维数组作为函数参数的函数声明形式</h6><p>实参：<code>int matrixs[3][10];</code><br>函数声明:<code>void matrix(int (*mat)[10])</code>;或者void matrix(int mat[][10]);<code>void matrix(int mat[][10]);</code><br>这里的关键在于编译器必须知道第二个及以后各维的长度才能对各下标进行求值，因此在原型中必须声明这个维的长度</p>
<h6 id="关于多维数组初始化"><a href="#关于多维数组初始化" class="headerlink" title="关于多维数组初始化"></a>关于多维数组初始化</h6><ul>
<li><p>第一种方式:<br><pre><code>int xy[3][2] = {1,2,3,4,5,6};</code></pre>这种就是在声明变量的时候就在后面跟着一长串的初始数据。</p>
</li>
<li><p>第二种方式:<br><pre><br>int xy[3][2];<br>xy[0][0] = 1;<br>xy[0][1] = 2;<br>…<br>xy[2][0] = 5<br>xy[2][1] = 6;</pre>这和第一种的差别就在于，这一种是对数组元素一个一个的去赋值，这种存储顺序是以最右边下标率先变化的（前面注释提到的行主序）。</p>
</li>
<li><p>第三种方式:<br>因为多维数组可以看成是每个元素由一个子数组组成，所以我们可以按照一个子数组为一个个体来初始化。<br><pre><br>int xy[3][2] = {<br>{1,2},<br>{3,4},<br>{5,6}<br>};<br></pre>这样看起来和第一种的方式是有点类似的。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>1 .数组变量是const指针，所以是不能被赋值的；</li>
<li>2.如果指针指向的不是一片连续的空间，那么对地址进行加操作（或者减操作）是没有意义；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录指针和数组直接的关系!&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="指针" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《C和指针Note》之指针</title>
    <link href="http://yoursite.com/2017/02/22/c_and_pointer_note_case3/"/>
    <id>http://yoursite.com/2017/02/22/c_and_pointer_note_case3/</id>
    <published>2017-02-22T15:40:39.000Z</published>
    <updated>2017-02-22T16:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>指针。<br><a id="more"></a><br>当前C语言环境:</p>
<pre>
Apple LLVM version 8.0.0 (clang-800.0.38)
Target: x86_64-apple-darwin15.6.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
</pre>

<h3 id="粗略的总结一下知识点"><a href="#粗略的总结一下知识点" class="headerlink" title="粗略的总结一下知识点"></a>粗略的总结一下知识点</h3><ul>
<li>1.变量标识符与内存位置之间的关联并不是硬件提供的，而是编译器为我们提供的，<strong>硬件仍然通过地址访问内存位置。</strong></li>
<li>2.数组中的元素存储于连续的内存地址中。</li>
<li>3.<code>NULL</code>指针作为一个不指向任何东西的特殊指针。<strong>在对指针进行解引用操作之前，必须确保它不是<code>NULL</code>指针</strong>(因为对一个NULL指针进行解引用是非法操作)。</li>
<li>4.指针的指针中，<em>操作符具有从右向左的结合性，所以这个表达式相当于`</em>(*c)`，所以可以从里向外求值。<br>对于如下代码中:<pre>int a = 10;
int *b = &a;
int **c = &b;</pre>

</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th style="text-align:center">相当的表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>b</td>
<td style="text-align:center">&amp;a</td>
</tr>
<tr>
<td>*b</td>
<td style="text-align:center">12,a</td>
</tr>
<tr>
<td>c</td>
<td style="text-align:center">&amp;b</td>
</tr>
<tr>
<td>*c</td>
<td style="text-align:center">&amp;a,b</td>
</tr>
<tr>
<td>**c</td>
<td style="text-align:center">12,a,*b</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意⚠️<br>在指针没有被初始化之前，一定不要对这个指针变量使用间接操作符。</p>
</blockquote>
<h3 id="习题练习纪录"><a href="#习题练习纪录" class="headerlink" title="习题练习纪录"></a>习题练习纪录</h3><ul>
<li>1.字符串查找相关，两个字符串中找出第一个相同的字符串。<br>解答:<pre>
char *find_char(char const *source,char const *chars){
  if (source == NULL || chars == NULL) {
      return NULL;
  }
  char const *f_p = chars;
  do {
      do {
          if (*source == *chars) {
              char *result = (char *)source;
              char *cp;
              *cp = *result;
              return cp;
          }
      } while (*chars++ != '\0');
      chars = f_p;
  } while (*source++ != '\0');
  return NULL;
}
</pre>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指针。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="指针" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《C和指针Note》之操作符和表达式</title>
    <link href="http://yoursite.com/2017/02/22/c_and_pointer_note_case2/"/>
    <id>http://yoursite.com/2017/02/22/c_and_pointer_note_case2/</id>
    <published>2017-02-22T15:18:03.000Z</published>
    <updated>2017-02-22T15:35:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇主要记录操作符和表达式相关的只是！<br><a id="more"></a><br>当前C语言环境:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Apple LLVM version 8.0.0 (clang-800.0.38)</div><div class="line">Target: x86_64-apple-darwin15.6.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</div></pre></td></tr></table></figure></p>
<h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>左移操作符<code>&lt;&lt;</code>,右移操作符<code>&gt;&gt;</code>;而且位移的操作数必须是<strong><em>整数类型</em></strong>。其中右移操作符存在两种情况：算术移位和逻辑移位；这里主要来说一说算术移位。</p>
<h6 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h6><p>左边移入的位用0填充</p>
<h6 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h6><p>算术移位也就是说会考虑到符号位，即左边移入的位由原值的符号位决定，如果符号位为1则移入的位为1，符号位为0则移入的位为0；<br>对于移位操作，还必须知道数字在计算机中是以二进制的形式存在的，而且负数的表示形式还稍有不同。</p>
<blockquote>
<p>负数在计算机中的二进制表示形式</p>
<p>假设在当前计算机中，int型占8位。比如要知道数字<code>-10</code>在计算机的表现形式，第一步：数字<code>10</code>的二进制值为00001010，第二步用100000000来减去00001010。得到的就是<code>-10</code>在二进制中的表现形式为:11110110。更多关于负数补码的介绍<a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="external">阮一峰的网络日志－－关于2的补码</a></p>
</blockquote>
<p>这里我举例说明一下移位操作:</p>
<p><pre><code><br>int uint = 10; //00001010<br>int sint = -10;//11110110<br>printf(“%d\n”,uint &gt;&gt; 2);//00000010<br>printf(“%d\n”,sint &gt;&gt; 2);//11111101<br></code></pre>在当前环境下：</p>
<p><pre><code><br>Apple LLVM version 8.0.0 (clang-800.0.38)<br>Target: x86_64-apple-darwin15.6.0<br>Thread model: posix<br>InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin<br></code></pre>打印的结果分别为<code>2</code>和<code>-3</code>,所以从这里看出来编译器对于左移操作是<strong><em>算术移位</em></strong>。</p>
<h3 id="和–操作符"><a href="#和–操作符" class="headerlink" title="++和–操作符"></a>++和–操作符</h3><p>对于这两个操作符的计算就很简单了，还是来举例说明一下:</p>
<p><pre><br>int a,b,c,d;<br>a = b = 10;<br>c = ++a;<br>d = b++;<br></pre>但是需要来理解这其中的原理:</p>
<blockquote>
<p>++和–操作符原理<br>抽象的说，前缀和后缀形式的增值操作符都复制一份变量值的拷贝，这些操作符的结果不是被他们所修改的变量，而是变量值的拷贝。</p>
</blockquote>
<h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符将多个表达式分隔开，这些表达式从左向右逐个进行求值，__整个逗号表达式的值就是最后那个表达式的值。</p>
<p><pre><br>int (^f1)(int) = ^(int value){<br>  return value + 1;<br>};<br>int (^f2)(int) = ^(int value){<br>  return value + 2;<br>};<br>int (^f3)(int,int) = ^(int a,int b){<br>  return a + b;<br>};<br>int x,a,b,c;<br>x = 0;<br>//从这里开始<br>a = f1(x);<br>b = f2(x + a);<br>for (c = f3(a,b); c &lt; 10; c = f3(a,b)) {<br>  printf(“while statements c is:%d\n”,c);<br>  a = f1(++x);<br>  b = f2(x + a);<br>}<br>//到这里结束，这其中的代码将会被修改<br></pre>上面为原始的代码片段，现在我们需要使用逗号操作符来简化上面的代码，同时我选择用<code>while</code>循环来代替<code>for</code>循环。</p>
<p><pre><br>while (a = f1(x),b = f2(x + a),c = f3(a,b),++x,c &lt; 10) {<br>  printf(“while statements c is:%d\n”,c);<br>}<br></pre>现在，循环中用于获得下一个值的语句只需要出现一次，逗号操作符使源码更易于维护。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇主要记录操作符和表达式相关的只是！&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《C和指针Note》之基础</title>
    <link href="http://yoursite.com/2017/02/20/c_and_pointer_note_base/"/>
    <id>http://yoursite.com/2017/02/20/c_and_pointer_note_base/</id>
    <published>2017-02-19T16:50:02.000Z</published>
    <updated>2017-02-22T15:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>C存在两种不同的环境：<code>翻译环境</code>和<code>执行环境</code>;<br><a id="more"></a><br>翻译环境是将源代码转换为可执行的机器指令，而执行环境用于实际执行代码。</p>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>其中翻译阶段主要包括了<code>编译</code>和<code>链接</code>两部分。</p>
<blockquote>
<p>__ 编译<br>将源代码转换为目标代码的过程，在这个过程中包含了<code>预处理</code>（预处理相关操作，比如define替换为实际值）和<code>解析</code>（判断源代码的意思），在最后生成<code>目标代码</code>（机器指令的初步形式）。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接器会把各个目标文件捆绑起来形成一个可执行程序。在这个过程中会引入c函数库。</p>
</blockquote>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>程序载入到内存中，并初始化在堆栈中没有初始化的变量。</p>
<blockquote>
<p>__ 运行时堆栈<br>用户保存函数的局部变量和返回值。</p>
<h4 id="静态内存"><a href="#静态内存" class="headerlink" title="静态内存"></a>静态内存</h4><p>存储在静态内存中的变量将会在程序执行期间一直保留！</p>
</blockquote>
<p>程序的终止可以是<code>main函数</code>完成返回，也可以是主动执行了<code>exit</code>。</p>
<h3 id="一个技巧"><a href="#一个技巧" class="headerlink" title="一个技巧"></a>一个技巧</h3><p>如果在使用注释的时候<code>/**/</code>嵌套了多层会导致注释失效，这时候我们可以在最外层添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#if 0</div><div class="line">//中间为代码</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>而且在使用注释的时候并不会把注释掉的部分从源代码中删除，只是不去执行而已，使用<code>if endif</code>的话是在逻辑上删除了这一段代码的。<br>这在后面的预处理器那一节会讲更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C存在两种不同的环境：&lt;code&gt;翻译环境&lt;/code&gt;和&lt;code&gt;执行环境&lt;/code&gt;;&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
