<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《C和指针Note》之数组和指针]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case4%2F</url>
      <content type="text"><![CDATA[记录指针和数组直接的关系!当前C语言环境: Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 一维数组数组名数组名的值是一个指针常量，也是数组第一个元素的地址。 注意⚠️数组具有确定的数量的元素，而指针只是一个标量值，只有数组名在表达式中使用时，编译器才会为他参数一个指针常量(意思就是你不能修改这个指针的值)。 指针常量所指向的是内存中数组的起始位置，如果修改这个指针常量，唯一可行的操作就是把整个数组移动到内存的其他位置，但是在程序完成链接之后，内存中数组的位置是固定的，所以当程序运行时，在想移动数组就晚了。 数组名不作为指针常量来表示的两种场景 注意：这里说的是不作为指针常量。 1.数组名作为sizeof操作符：sizeof返回整个数组所占用的字节，而不是每个元素所占用的字节，也不是指向数组的指针的长度。 2.数组名用于单目操作符&amp;时：返回一个指向数组的指针，而不是一个指向指针常量的指针。 int a[10]; int *c; c = &a[0];c = a;//这里赋值的是一个指针的拷贝。 下标引用和指针(间接取值操作)array[3]，*(array + 3)出了优先级之外，下标引用和间接访问完全相同。 int array[10];int *ap = array + 2; 1.ap:这是一个指针地址，所以该表达式和&amp;array[2]或者array+2相同。 2.*ap:间接访问，与array[2]和*(array + 2)相同。 3.ap[6]:C的下标引用和间接访问表达式是一样的，所以ap[6]和*(ap + 6)相同，与array[8]和*(array + 8)相同。 4.ap + 6:ap为一个指针地址，地址向后偏移6，则ap + 6和&amp;array[8]，array + 8相同。 5.*(ap + 6):上面说过ap+6为一个地址，由此可以得出*(ap+6)为间接求得地址对应的值，它和array[8]和*(array+8)相同，其实它和2&gt;.类似。 –&gt;6.ap[-1]:使用-1的偏移量使得道它前一个元素，也就是array[1]或者*(array + 2 - 1)。 上面说这么多，其实只要抓住：当前表示的地址，元素还是间接获取操作就可以了。 注意⚠️:上面提到的“C的下标引用和间接访问表达式是一样的”。 思考题:2[array]，这个表达式中的array是上文中的array。在这个上下文环境中，2[array]表达的意思是什么： 解答:因为前面我一直在强调，下标引用和间接表达式求值是相同的，所以: 第一步：我们可以把2[array]改写成*(2 + array) 第二步:由于加法运算符的两个操作数是可以交换位置的，所以把上面的表达式改写为:*(array + 2);也就是说2[array]其实和array[2]是相等的。 关于指针间接操作符和下标操作的比较 相对于指针的间接访问和下标操作，在可读性方面下标的方式更好，但是在执行效率上面下标不会比指针更有效率，但是指针有时候比下标效率更高。 具体的效率比较为: 1.当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。 2.声明为寄存器变量的指针通常比用于静态内存和堆栈中的指针效率更高。关于如何将变量声明为寄存器变量，我们可以使用register关键字来声明，比如:register int *p1;，register：这个关键字请求编译器尽可能的将变量存在CPU 内部寄存器中而不是通过内存寻址访问以提高效率。register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址运算符“&amp;”来获取register 变量的地址。 3.像&amp;array[2]或者array+2这种在运行时求值的常量表达式代价很高。 数组的初始化数组的初始化需要一系列的值，例如： int array[5] = {1,2,3,4,5};//如果在初始化的时候，初始化的个数比数组的大小小的话，空余的元素将会被赋值为0。int array[] = {1,2,3,4,5};//如果在声明中没有给出数组的长度，编译器会把数组的长度设置为刚好能够容易所有初始值的长度。对于静态数组：存储于静态内存的数组只初始化一次，当程序执行时，静态数组已经初始化完毕。如果数组没有被初始化，数组元素的初始值将会自动设置为0。对于自动变量：由于自动变量位于运行时堆栈，所以自动变量在缺省的情况下是未被初始化的。所以这里需要思考的是：当数组的初始化在一个函数中，程序在每次进入该函数的时候，是否值得每次都对该数组重新进行初始化。如果不需要的的话，我们可以把该数组声明为static。 ######指定初始化器(c99)只初始化数组中的指定元素，方法是：在初始化列表中使用带方括号的下标指明待初始化的元素。1int array[5] = &#123;[5] = 23&#125;;//把array[5]初始化为23 多维数组如int xy[3][2]数组维数不止一个的称为多维数组。数组xy[3][2]在内存中的存储顺序为: (0,0) (0,1) (1,0) (1,1) (2,0) (2,1)//多维数组中的元素存储顺序按照最右边的下标率先变化的原则，称为行主序。关于是把第一个下标(上面定义的数组xy中的3)解释为行还是解释为列，都可以的，只要你在使用这个数组的时候使用同一种就可以。如果你把第一个下标解释为行第二个下标解释为列，那么当你按照存储顺序逐个访问数组元素时，所获得的元素是按行排列的，相反则是按列排列的。 数组名和下标int xy[3][2]，数组名xy是一个指向包涵2个整型元素的数组的指针（指向数组的指针）。下面我们来看看数组的下标和指针之间的关系: 1.xy:在三个包含两个整型元素的数组中，xy为指向第一个子数组。（注意：这是指针，说明了指向） 2.xy + 1:在三个包含两个整型元素的数组中，xy为指向第二个子数组，+1是根据包含2个整型元素的数组长度进行调整的，所以是指向第二个子数组。（注意：同上，这是指针，说明了指向） 3.*(xy + 1):获取指向第二个子数组的指针，通过间接操作符得到这个子数组，或者可以把该表达式写为xy[1]（即表示的是第二个子数组）。 4.*(xy + 1) ＋ 1：在第三点中我们取得了第二个子数组，记得我们在上面讲一维数组的时候，获取数组第n个元素的地址的办法是:array + n或者&amp;array[n]，在和*(xy + 1) ＋ 1进行对比之后不难发现，其表达的意思就是获取第二个子数组中第2个元素（因为数组下标是从0开始）的地址或者可以把该表达式写为xy[1] ＋ 1（注意：同上，这是指针，是一个地址） 5.*(*(xy + 1) + 1)：由间接操作符，获得第4点中的指针指向的具体元素。同上我们可以写为:*(xy[1] + 1)，进一步改写xy[1][1]; 指向数组的指针int vector[10];int matrix[3][4];int *vp = vector;int (*mp)[10] = matrix;//下标引用的优先级是高于间接引用的，所以我们需要在间接引用这里手动加上括号才行所以mp是一个指向整型数组的指针，vp是指向整型变量的指针。 这里需要注意一下：一定不要把指向数组的指针和指针数组浓混了，那个确保算术优先级的括号是很重要的，int (*mp)[10]代表的是指向数组的指针，而int *mp[10]表示的是指针数组。 当数组作为函数的参数的时候，多维数组和一维数组相同，都是用指针作为参数进行传递，这个指针是指向数组第一个元素的指针。 一维数组作为函数参数的函数声明形式实参：int vectors[10];函数声明:void vector(int *vec);或者void vector (int vet[]) 多维数组作为函数参数的函数声明形式实参：int matrixs[3][10];函数声明:void matrix(int (*mat)[10]);或者void matrix(int mat[][10]);void matrix(int mat[][10]);这里的关键在于编译器必须知道第二个及以后各维的长度才能对各下标进行求值，因此在原型中必须声明这个维的长度 关于多维数组初始化 第一种方式:int xy[3][2] = {1,2,3,4,5,6};这种就是在声明变量的时候就在后面跟着一长串的初始数据。 第二种方式:int xy[3][2];xy[0][0] = 1;xy[0][1] = 2;…xy[2][0] = 5xy[2][1] = 6;这和第一种的差别就在于，这一种是对数组元素一个一个的去赋值，这种存储顺序是以最右边下标率先变化的（前面注释提到的行主序）。 第三种方式:因为多维数组可以看成是每个元素由一个子数组组成，所以我们可以按照一个子数组为一个个体来初始化。int xy[3][2] = {{1,2},{3,4},{5,6}};这样看起来和第一种的方式是有点类似的。 总结 1 .数组变量是const指针，所以是不能被赋值的； 2.如果指针指向的不是一片连续的空间，那么对地址进行加操作（或者减操作）是没有意义；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之指针]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case3%2F</url>
      <content type="text"><![CDATA[指针。当前C语言环境: Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 粗略的总结一下知识点 1.变量标识符与内存位置之间的关联并不是硬件提供的，而是编译器为我们提供的，硬件仍然通过地址访问内存位置。 2.数组中的元素存储于连续的内存地址中。 3.NULL指针作为一个不指向任何东西的特殊指针。在对指针进行解引用操作之前，必须确保它不是NULL指针(因为对一个NULL指针进行解引用是非法操作)。 4.指针的指针中，操作符具有从右向左的结合性，所以这个表达式相当于`(*c)`，所以可以从里向外求值。对于如下代码中:int a = 10; int *b = &a; int **c = &b; 表达式 相当的表达式 a 10 b &amp;a *b 12,a c &amp;b *c &amp;a,b **c 12,a,*b 注意⚠️在指针没有被初始化之前，一定不要对这个指针变量使用间接操作符。 习题练习纪录 1.字符串查找相关，两个字符串中找出第一个相同的字符串。解答: char *find_char(char const *source,char const *chars){ if (source == NULL || chars == NULL) { return NULL; } char const *f_p = chars; do { do { if (*source == *chars) { char *result = (char *)source; char *cp; *cp = *result; return cp; } } while (*chars++ != '\0'); chars = f_p; } while (*source++ != '\0'); return NULL; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之操作符和表达式]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case2%2F</url>
      <content type="text"><![CDATA[这篇主要记录操作符和表达式相关的只是！当前C语言环境:1234Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 移位操作符左移操作符&lt;&lt;,右移操作符&gt;&gt;;而且位移的操作数必须是整数类型。其中右移操作符存在两种情况：算术移位和逻辑移位；这里主要来说一说算术移位。 逻辑移位左边移入的位用0填充 算术移位算术移位也就是说会考虑到符号位，即左边移入的位由原值的符号位决定，如果符号位为1则移入的位为1，符号位为0则移入的位为0；对于移位操作，还必须知道数字在计算机中是以二进制的形式存在的，而且负数的表示形式还稍有不同。 负数在计算机中的二进制表示形式 假设在当前计算机中，int型占8位。比如要知道数字-10在计算机的表现形式，第一步：数字10的二进制值为00001010，第二步用100000000来减去00001010。得到的就是-10在二进制中的表现形式为:11110110。更多关于负数补码的介绍阮一峰的网络日志－－关于2的补码 这里我举例说明一下移位操作: int uint = 10; //00001010int sint = -10;//11110110printf(“%d\n”,uint &gt;&gt; 2);//00000010printf(“%d\n”,sint &gt;&gt; 2);//11111101在当前环境下： Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin打印的结果分别为2和-3,所以从这里看出来编译器对于左移操作是算术移位。 ++和–操作符对于这两个操作符的计算就很简单了，还是来举例说明一下: int a,b,c,d;a = b = 10;c = ++a;d = b++;但是需要来理解这其中的原理: ++和–操作符原理抽象的说，前缀和后缀形式的增值操作符都复制一份变量值的拷贝，这些操作符的结果不是被他们所修改的变量，而是变量值的拷贝。 逗号操作符逗号操作符将多个表达式分隔开，这些表达式从左向右逐个进行求值，__整个逗号表达式的值就是最后那个表达式的值。 int (^f1)(int) = ^(int value){ return value + 1;};int (^f2)(int) = ^(int value){ return value + 2;};int (^f3)(int,int) = ^(int a,int b){ return a + b;};int x,a,b,c;x = 0;//从这里开始a = f1(x);b = f2(x + a);for (c = f3(a,b); c &lt; 10; c = f3(a,b)) { printf(“while statements c is:%d\n”,c); a = f1(++x); b = f2(x + a);}//到这里结束，这其中的代码将会被修改上面为原始的代码片段，现在我们需要使用逗号操作符来简化上面的代码，同时我选择用while循环来代替for循环。 while (a = f1(x),b = f2(x + a),c = f3(a,b),++x,c &lt; 10) { printf(“while statements c is:%d\n”,c);}现在，循环中用于获得下一个值的语句只需要出现一次，逗号操作符使源码更易于维护。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之基础]]></title>
      <url>%2F2017%2F02%2F20%2Fc_and_pointer_note_base%2F</url>
      <content type="text"><![CDATA[C存在两种不同的环境：翻译环境和执行环境;翻译环境是将源代码转换为可执行的机器指令，而执行环境用于实际执行代码。 翻译其中翻译阶段主要包括了编译和链接两部分。 __ 编译将源代码转换为目标代码的过程，在这个过程中包含了预处理（预处理相关操作，比如define替换为实际值）和解析（判断源代码的意思），在最后生成目标代码（机器指令的初步形式）。 链接链接器会把各个目标文件捆绑起来形成一个可执行程序。在这个过程中会引入c函数库。 执行程序载入到内存中，并初始化在堆栈中没有初始化的变量。 __ 运行时堆栈用户保存函数的局部变量和返回值。 静态内存存储在静态内存中的变量将会在程序执行期间一直保留！ 程序的终止可以是main函数完成返回，也可以是主动执行了exit。 一个技巧如果在使用注释的时候/**/嵌套了多层会导致注释失效，这时候我们可以在最外层添加:123#if 0//中间为代码#endif 而且在使用注释的时候并不会把注释掉的部分从源代码中删除，只是不去执行而已，使用if endif的话是在逻辑上删除了这一段代码的。这在后面的预处理器那一节会讲更多。]]></content>
    </entry>

    
  
  
</search>
