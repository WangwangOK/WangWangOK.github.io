<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OpenGL投影变换矩阵]]></title>
      <url>%2F2020%2F09%2F07%2Fopengl_%20projection_matrix%2F</url>
      <content type="text"><![CDATA[前言本文是对OpenGL Projection Matrix一文的中文翻译，初衷是因为自己学习OpenGL时，对投影变形的数学推导比较感兴趣，因此找到了该文章。而本文并不是对该一对一的翻译，其中会增加一些易于理解的内容。 正文计算机显示器是2D平面的。如果3D场景通过OpenGL来渲染，那么就需要以2D图像的方式投影到计算机屏幕上。其中GL_PROJECTION矩阵就是用作投影变换。首先它将所有的顶点数据从观察（View）坐标变换到裁剪坐标；然后裁剪坐标还需要变换为归一化坐标（NDC，Normalized Device Coordinates），具体的方法就是裁剪坐标除以其w分量（默认是4分量向量，即x，y，z，w）。 因此需要注意的是裁剪（视锥剔除）和NDC变换都已经集成在了GL_PROJECTION矩阵中。而下面的内容主要就是描述如何从 left, right, bottom, top, near 和 far 这个6个值来构建投影矩阵。下图标明了这六个值： 这里要注意一下的是对于视锥剔除（也就是裁剪）是在裁剪坐标执行（即除以w分量）之前进行。在裁剪坐标中x、y、z分量都会尝试和w分量进行比较，如果其小于-w（注意这里是负数）或者大于w（这里是正数）都会认为这些顶点是无效的。即： -w < x,y,z < w然后OpenGl会在发生裁剪的地方重建多边形的边缘。 透视投影（Perspective Projection） 在透视投影中，处于视锥（上图左边，观察坐标）中的3D坐标会映射到立方体（上图右边，NDC坐标）中。x轴上[l,r]范围内的点映射到[-1,1]范围内；y轴上[b,t]范围内的点映射到[-1,1]范围内；z轴上[-n,-f]范围内的点映射到[-1,1]范围内。 注意：观察坐标使用的是右手坐标系，归一化坐标（NDC）使用的左手坐标系。 因此在观察空间中，处于原点的相机是望向-z轴方向，但是在NDC中却是望向+z轴方向。glFrustum()只接受为负数的near和far值（第二幅图中有标明），所以在构建GL_PROJECTION矩阵时需要对它们进行取反。 因此为了求得观察坐标到归一化坐标的变换矩阵，大致需要两步：首先需要将观察坐标（x_{e}, y_{e}, z_{e}） 投影到近平面上的点 （x_{p}, y_{p}, z_{p}）。其次是将（x_{p}, y_{p}, z_{p}）转换为（x_{n}, y_{n}, z_{n}）。 观察坐标到近平面的投影在OpenGl中，观察空间中的3D坐标都会投影到近平面（near plane）中，下面两幅图展示了如何将观察空间中的某一个点（x_{e}, y_{e}, z_{e}） 投影到近平面上的点 （x_{p}, y_{p}, z_{p}） 。 俯视图： 侧视图： 从视锥俯视图来看，x_{e} 映射到 x_{p}。通过相似三角形比例： \frac{x_{p}}{x_{e}} = \frac{-n}{z_{e}} \rightarrow x_{p} = \frac{-n* x_{e}}{z_{e}} = \frac{n* x_{e}}{-z_{e}} （等式一）从侧视图来看，y_{p}可以使用类似的方法求得： \frac{y_{p}}{y_{e}} = \frac{-n}{z_{e}} \rightarrow y_{p} = \frac{-n* y_{e}}{z_{e}} = \frac{n* y_{e}}{-z_{e}} （等式二）也就是说，无论x_{e}和y_{p}都是依赖于z_{e}，即它们和-z_{e}相反。换句话说，它们都会除以-z_{e}。这是作为构造GL_PROJECTION矩阵非常重要的线索。在观察坐标在通过乘以GL_PROJECTION矩阵转换后，裁剪坐标依然是一个齐次坐标： \begin{pmatrix} x_{clip}\\ y_{clip}\\ z_{clip}\\ w_{clip} \end{pmatrix} = M_{projection} \cdot \begin{pmatrix} x_{eye}\\ y_{eye}\\ z_{eye}\\ w_{eye} \end{pmatrix}最后通过除以裁剪坐标的w分量变成归一化坐标（NDC）： \begin{pmatrix} x_{ndc}\\ y_{ndc}\\ z_{ndc}\\ \end{pmatrix} = \begin{pmatrix} x_{clip}/w_{clip}\\ y_{clip}/w_{clip}\\ z_{clip}/w_{clip}\\ \end{pmatrix}因此我们可以设置裁剪坐标的w分量为-z_{e}，GL_PROJECTION矩阵的第4行就变为(0, 0, -1, 0)，并有如下的等式成立： \begin{pmatrix} x_{clip}\\ y_{clip}\\ z_{clip}\\ w_{clip} \end{pmatrix} = \begin{pmatrix} . & . & . & . \\ . & . & . & . \\ . & . & . & . \\ 0 & 0 & -1 & 0 \end{pmatrix} \cdot \begin{pmatrix} x_{e}\\ y_{e}\\ z_{e}\\ w_{e} \end{pmatrix} , \rightarrow w_{c} = -z_{e}下一步根据线性关系，我们将x_{p}, y_{p} 映射到 x_{n}, y_{n} （即NDC坐标）： [l, r] \Rightarrow [-1, 1],\ [b, t] \Rightarrow [-1, 1]x_{p}到x_{n}的映射将x_{p} 映射到 x_{n}： x_{n} = \frac{1 - (-1)}{r - l} \cdot x_{p} + \beta然后用(r, 1) 来替换 (x_{p}, x_{n})，也就是在直线上取的特殊点： 1 = \frac{2r}{r - l} + \beta \Rightarrow \beta = 1 - \frac{2r}{r - l} = \frac{r-l}{r - l} - \frac{2r}{r - l} = \frac{-r-l}{r - l} = - \frac{r+l}{r - l}将β带入等式一得到： x_{n} = \frac{2}{r - l} \cdot x_{p} - \frac{r+l}{r - l} （等式三）同理我们可以将y_{p} 映射到 y_{n}： y_{p}到y_{n}的映射最后得到的等式为： y_{n} = \frac{2}{t - b} \cdot y_{p} - \frac{t+b}{t - b} （等式四）然后我们将前面得到x_{p}（即等式一）带入到等式三中，我们的目的是要推导出和z_{e}的关系： x_{n} = \frac{2*\frac{n*x_{e}}{-z_{e}}}{r-l} - \frac{r+l}{r-l} x_{n} = \frac{2*n*x_{e}}{(r-l)*-z_{e}} - \frac{r+l}{r-l} x_{n} = \frac{\frac{2*n*x_{e}}{r-l}}{-z_{e}} - \frac{r+l}{r-l} x_{n} = \frac{\frac{2n}{r-l}}{-z_{e}} *x_{e} + \frac{\frac{r+l}{r-l}* z_{e}}{-z_{e}} x_{n} = (\frac{2n}{r-l} * x_{e} + \frac{r+l}{r-l} * z_{e})/-z_{e} （等式五）将前面得到y_{p}（即等式二）带入到等式四中，同样也是要推导出和z_{e}的关系： y_{n} = \frac{2*\frac{n*y_{e}}{-z_{e}}}{t-b} - \frac{t+b}{t-b} y_{n} = \frac{2*n*y_{e}}{(t-b)*-z_{e}} - \frac{t+b}{t-b} y_{n} = \frac{\frac{2*n*y_{e}}{t-b}}{-z_{e}} - \frac{t+b}{t-b} y_{n} = \frac{\frac{2n}{t-b}}{-z_{e}} *y_{e} + \frac{\frac{t+b}{t-b}* z_{e}}{-z_{e}} y_{n} = (\frac{2n}{t-b} * y_{e} + \frac{t+b}{t-b} * z_{e})/-z_{e}（等式六）上面我们为了进行透视划分(x_{c}/w_{c}, y_{c}/w_{c})，将等式的每一项都除以-z_{e}，在前面我们有w_{c} = -z_{e}。因此对于等式五和等式六我们可以将括号内的设为x_{c}、y_{c}，具体如下： x_{c} = (\frac{2n}{r-l} * x_{e} + \frac{r+l}{r-l} * z_{e}) y_{c} = (\frac{2n}{t-b} * y_{e} + \frac{t+b}{t-b} * z_{e})有了上面的关系之后，我们就可以求得变换矩阵GL_PROJECTION的对应项（第一行，第二行）了： \begin{pmatrix} x_{c}\\ y_{c}\\ z_{c}\\ w_{c} \end{pmatrix} = \begin{pmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\ \cdot & \cdot & \cdot & \cdot \\ 0 & 0 & -1 & 0 \end{pmatrix} \begin{pmatrix} x_{e}\\ y_{e}\\ z_{e}\\ w_{e} \end{pmatrix}z_{e}到z_{n}的映射现在我们仅仅只有GL_PROJECTION矩阵3行（第1、2、4行）。寻找z_{n}（归一化坐标中的z值）相对于其他来说是有点不一样的，这是因为在观察坐标中的z_{e}总是投影在-n的近平面（near plane）上面（回想一下上面的那几张图）。但我们需要唯一的z值用于裁剪和深度测试，我们可以使用逆变换进行反投影。 我们知道z并不依赖于x和y的值，我们可以借用w分量来找到z_{n}、z_{e}之间的关系。因此我们可以对上面矩阵的第3行指定为如下形式： \begin{pmatrix} x_{c}\\ y_{c}\\ z_{c}\\ w_{c} \end{pmatrix} = \begin{pmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\ \cdot & \cdot & A & B \\ 0 & 0 & -1 & 0 \end{pmatrix} \begin{pmatrix} x_{e}\\ y_{e}\\ z_{e}\\ w_{e} \end{pmatrix}我们可以得到下面的等式，等式的前半部分是我们前面提到的基础，对于归一化坐标而言，是用裁剪坐标除以其w分量： z_{n} = z_{c}/w_{c} = \frac{A*z_{e} + B*w_{e}}{w_c} （等式七）由于w_{c} = -z_{e}，所以进一步替换上面的等式： z_{n} = \frac{A*z_{e} + B*w_{e}}{-z_{e}}在观察空间中w分量为1，也即是w_{e} = 1，因此等式可以进一步化简为： z_{n} = \frac{A*z_{e} + B}{-z_{e}}为了找到系数，A和B我们使用(z_{e}, z_{n})之间的关系：-n对应-1，即（-n，-1）；-f对应1，即（-f，1）。让这两个特殊的值带入到上面的等式中得到： \left\{\begin{matrix} \frac{-An+B}{-n} = -1\\ \frac{-Af+B}{f} = 1 \end{matrix}\right. \rightarrow \left\{\begin{matrix} -An+B = -n\\ -Af+B = f \end{matrix}\right.得出B = An - n，然后将该等式带入到-Af+B = f中，得到： A = -\frac{f+n}{f-n} B = \frac{-2fn}{f-n}透视投影矩阵将A和B的值带入到矩阵中得到完整的透视投影矩阵： \begin{pmatrix} \frac{2n}{r-l} & 0 & \frac{r+l}{r-l} & 0\\ 0 & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0\\ 0 & 0 & -\frac{f+n}{f-n} & \frac{-2fn}{f-n} \\ 0 & 0 & -1 & 0 \end{pmatrix} (矩阵一)这个矩阵是通用的视锥投影矩阵。如果说观察的是对称的话，即r=-l、t=-b，上面的矩阵可以化简为： \begin{pmatrix} \frac{n}{r} & 0 & 0 & 0\\ 0 & \frac{n}{t} & 0 & 0\\ 0 & 0 & -\frac{f+n}{f-n} & \frac{-2fn}{f-n} \\ 0 & 0 & -1 & 0 \end{pmatrix} (矩阵二)同样的我们也可以根据等式七求出z_{n}的值 z_{n} = \frac{-1\frac{f+n}{f-n}*z_{e} - \frac{2fn}{f-n}}{-z_{e}} （等式八）在我们继续后面的内容之前，我们先仔细看看上面z_{n}、z_{e}之间的关系。我们注意到它们是非线性关系的合理函数。这意味在近平面（near plane）上有着非常高的精度，但在远平面（far plane）上的精度却很低。如果[-n, -f]变大，那么就会导致深度（depth）的精度问题（z-fighting）。$z_{e}$在远平面附近小的变化不会影响到{z_{n}}值（这里可以简单地将z_{e} = -n代入到上面等式中）。n和f之间的距离应尽可能地短，以最大程度地减小深度缓冲区的精度问题。 正交投影（Orthographic Projection）构建GL_PROJECTION的正投影矩阵要比透视投影要简单许多，观察坐标的x_{e}、y_{e}、z_{e}分量都是线性映射到归一化坐标中。因此我们只需要将长方形体积缩放到立方体中将其移动到原点即可。 现在我们可以根据线性关系求得GL_PROJECTION矩阵的各个元素。 x_e到x_n的映射将x_{e}映射到x_{n}： x_{n} = \frac{1-(-1)}{r-l} * x_{e} + \beta然后用点(r, +1) 替换 (x_{e}, x_{n})： 1 = \frac{2r}{r-l} + \beta \Rightarrow \beta = 1 - \frac{2r}{r-l} = - \frac{r+l}{r-l}将 β 代入到方程中得到： x_{n} = \frac{2}{r-l} * x_{e} - \frac{r+l}{r-l}y_e到y_n的映射 同理我们也可以求出y_{n}对应的函数表示： y_{n} = \frac{1-(-1)}{t-b} * y_{e} + \beta然后用点(t, +1) 替换 (y_{e}, y_{n})： 1 = \frac{2t}{t-b} + \beta \Rightarrow \beta = 1 - \frac{2t}{t-b} = - \frac{t+b}{t-b}将 β 代入到方程中得到： y_{n} = \frac{2}{t-b} * y_{e} - \frac{t+b}{t-b}z_e到z_n的映射 这里需要注意的是它们都是取的负数。 z_{n} = \frac{1-(-1)}{-f-(-n)} * z_{e} + \beta将(-f, 1)替换(z_{e}, z_{n})： 1 = \frac{2f}{f-n} + \beta \Rightarrow \beta = 1 - \frac{2f}{f-n} = - \frac{f+n}{f-n}将 β 代入到方程中得到： z_{n} = \frac{-2}{f-n} * z_{e} - \frac{f+n}{f-n}正交投影矩阵对于正交投影来说，w分量不是必须的。我们将GL_PROJECTION的中第4行设置为(0,0,0,1)。因此GL_PROJECTION完整的正交投影矩阵为： \begin{pmatrix} \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l}\\ 0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b}\\ 0 & 0 & \frac{-2}{f-n} & -\frac{f+n}{f-n}\\ 0 & 0 & 0 & 1 \end{pmatrix}如果观察空间是对称的，即r = -l, t=-b。我们可以进一步的简化： \left\{\begin{matrix} r + l = 0\\ r - l = 2r \end{matrix}\right. ，\left\{\begin{matrix} t + b = 0\\ t - b = 2t \end{matrix}\right.将上的等式代入到原矩阵中，化简之后的矩阵为： \begin{pmatrix} \frac{1}{r} & 0 & 0 & 0\\ 0 & \frac{1}{t} & 0 & 0\\ 0 & 0 & \frac{-2}{f-n} & -\frac{f+n}{f-n}\\ 0 & 0 & 0 & 1 \end{pmatrix}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语法分析——自底向上语法分析中的规范LR和LALR]]></title>
      <url>%2F2020%2F05%2F05%2Fbottom2top_syntax_parser_lalr%2F</url>
      <content type="text"><![CDATA[前言在这篇文章中主要看两种LR语法分析技术，相对于上一篇中SLR，本篇文章的两种LR技术对它进行了扩展，在输入中向前看一个符号。这两种技术分别是： “规范LR”：也可以直接叫做”LR”方法，这个方法会使用很大的一个项集，称为LR(1)项集； “向前看LR”：也可以直接叫做”LALR”方法，它基于LR(0)项集（比LR(1)项集状态要少很多）。很多情况下LALR是最合适的选择； 一、规范LR(1)我们来看个情况，在SLR方法中，如果项集 I_{i} 包含项 [A\rightarrow \alpha\ \ \cdot\ ]，如果当前输入符号 a 存在于FOLLOW(A)中。如果基于SLR来说，那么我们肯定会将 α 归约为A。然而在某些情况下，当状态 i 出现在栈顶时，栈中的可行前缀是 βα ，并且最右句型中 a 都不可能跟在 βA 之后，也就是说我们肯定不能简单就将 α 归约为 A 。 因此我们可以在项中新增一个分量，这个分量为一个终结符号。比如现在项可以表示为 [A\rightarrow\alpha\cdot \beta,\ a]，其中 A\rightarrow\alpha\beta 是一个产生式，而a是一个终结符号或者右端结束标记$。我们称这样的项为 LR(1)项 。其中的1指的是第二个分量的长度。 第二个分量称为 向前看符号 。 正式的说，LR(1)项[A\rightarrow\alpha \cdot \beta,\ a]对于可行前缀 γ 有效的条件是存在推导S\rightarrow xAw\rightarrow x\alpha\beta w，其中： 可行前缀为 xα； 要么 a 是 w 的第一个符号，要么w为空串且a对于结束符； 构造LR(1)项集LR(1)项集构造方法：一个增广文法G‘，在原来SLR的基础上对CLOSURE函数和GOTO函数进行改造。大致如下： 123456789101112131415161718192021222324252627282930313233343536SetOfItems CLOSURE(I) &#123; repeat for(I中的每个项[A -&gt; α·Bβ, a]) &#123; for(G&apos;中每个产生式B -&gt; γ) &#123; /// 解释一下，G’表示增广文法（它包含了文法的所有产生式）；B -&gt; γ 表示在增广文法中当存在产生式头部为当前项点号右边的非终结符号时，进行下面的操作 for(FIRST(βa)中每个终结符号b) &#123; 将[B -&gt; γ, b]项添加到集合I中； &#125; &#125; &#125; until 不能向I中加入更多的项； return I;&#125;SetOfItems GOTO(I,X) &#123; 将J初始化为空集； for (I中的每个项 [A -&gt; α·Xβ, a])/// 这里我解释一下，循环I中的每一个项，直到出现点号右边的符号和传入的参数符号X相同时进行后续操作 将项[A -&gt; αX·β, a]加入到集合J中; return CLOSURE(J);&#125;void items(G&apos;) &#123; 将C初始化为&#123;CLOSURE&#125;(&#123;[S&apos; -&gt; ·S, $]&#125;); repeat for(C中每个项集I) &#123; for(每个文法符号X) &#123; if (GOTO(I,X)非空且不在C中) 将GOTO(I,X)加入C中； &#125; &#125; until 不再有新的项集加入到C中&#125; 下面的代码是我对上面的表示翻译了一下，看下面代码时可以对照上面的内容对应着看。而且对Item进行了更新，因为在LR(1)项集中Item需要一个向前看运算符： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*struct Item &#123;int position; /// 点号所处位置int id; /// 当前项在产生式集合中的编号Symbol *forwardSymbol; /// 向前看符号Item()&#123; position = 0; id = 0; forwardSymbol = nullptr;&#125;Item(int pos, int idt, Symbol *ptr):position(pos),id(idt),forwardSymbol(ptr)&#123;&#125;&#125;;*/SetOfItems&lt;Item&gt; LR_1::LRCollection::closure(SetOfItems&lt;Item&gt;&amp; set) &#123; for (SetOfItems&lt;Item&gt;::iterator itr = set.begin(); itr != set.end(); ++itr) &#123; Item item = *itr; vector&lt;Production&gt; productions = grammer.productions; Production prod = productions[item.id]; Symbol *dst_sym = prod.bodies[item.position]; for (vector&lt;Production&gt;::iterator p_itr = productions.begin(); p_itr != productions.end(); ++p_itr) &#123; int index = p_itr - productions.begin(); if((p_itr-&gt;header).identifier() != dst_sym-&gt;identifier()) &#123; continue; &#125; Symbol *beta = prod.bodies[item.position + 1]; vector&lt;Symbol *&gt;first = grammer.FIRST(beta); if (first.size() &lt;= 0) &#123; first = grammer.FIRST(item.forwardSymbol); &#125; for (vector&lt;Symbol *&gt;::iterator s_itr = first.begin(); s_itr != first.end(); ++s_itr) &#123; Item itm(0,index, *s_itr); set.push_back(itm); /// &lt;------------------------ 自增长 &#125; &#125; &#125; return set;&#125;SetOfItems&lt;Item&gt; LR_1::LRCollection::lr_goto(SetOfItems&lt;Item&gt;&amp; set, Symbol *symbol, int *offset)&#123; SetOfItems&lt;Item&gt; temp; for (SetOfItems&lt;Item&gt;::iterator itr = set.begin(); itr != set.end(); ++itr) &#123; Item item = *itr; Production prod = grammer.productions[item.id]; Symbol *sym = prod.bodies[item.position]; if (sym-&gt;identifier() != symbol-&gt;identifier()) &#123; /// 目标符号不符合 continue; &#125; int position = item.position + 1; if (position &gt;= prod.bodies.size()) &#123; /// 异常 continue; &#125; Item result(item.id, item.position + 1, item.forwardSymbol); temp.push_back(result); &#125; return closure(temp);&#125;void LR_1::LRCollection::items()&#123; /// 1、将[S&apos; -&gt; .S, $]作为初始化加入到集合中 SetOfItems&lt;Item&gt; set; Item it(0,0,const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr())); /// 产生式集合中第0个为增广表达式 set.push_back(it); vector&lt;SetOfItems&lt;Item&gt; &gt; collection(1, set); using vector_type=vector&lt;SetOfItems&lt;Item&gt;&gt;; for(vector_type::iterator itr = collection.begin(); itr != collection.end(); ++itr) &#123; vector &lt;Symbol *&gt; symbols = grammer.symbols; for (vector&lt;Symbol *&gt;::iterator s_itr = symbols.begin(); s_itr != symbols.end(); ++s_itr) &#123; int offset = 0; SetOfItems&lt;Item&gt; items = lr_goto(*itr, *s_itr, &amp;offset); int result = contain_set(items); if (result == -1) &#123; collection.push_back(items); Item item = items[0]; std::string key = format(&quot;%d_%d_%d&quot;,item.id,item.position, item.forwardSymbol-&gt;identifier()); item_map.insert(make_pair(key, offset)); &#125; &#125; &#125;&#125; 现在我们来看一个增广文法，我们使用上面的知识可以对这个增广文法构造出它对应的项集： S' \rightarrow S\\ S \rightarrow CC\\ C \rightarrow cC\ |\ d下图是对应的项集族： 这个项集中的和上一篇文章中看到的项是不仅仅有了点号位置区分，还有向前看运算符的区分。 下面我们来看一下规范LR中ACTION函数的具体行为： 1）、如果 [A\rightarrow \alpha \cdot a \beta, b] 在 I_{i} 中，并且 GOTO[I_{i}, a] = I_{j}，那么将 ACTION[i, a] 设置为“移入j”。这里 a 必须是一个终结符号； 2）、如果 [A\rightarrow \alpha \cdot, a] 在 I_{i} 中且 A \neq S' （即当前产生式头部的非终结符，不是产生式集合中的增广文法的开始符号），那么将 ACTION[i, a] 设置为“归约A -&gt; α”； 3）、如果 [S' \rightarrow S \cdot , \$] 在 I_{i} 中，那么将 ACTION[i, a] 设置为“接受”； 4）、不满足上诉规则的，都设置为“报错”； 现在我们根据上面的四个规则，写出规范LR对应的ACTION函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344LR_Action* LR_1::LRCollection::action(SetOfItems&lt;Item&gt;&amp; set, Symbol *symbol) &#123; if (symbol-&gt;isTerminal() == false) &#123; return nullptr; &#125; LR_Action *action = set.actionForSymbol(symbol-&gt;identifier()); if (action != nullptr) &#123; return action; &#125; vector&lt;GrammarParser::Production&gt; productions = grammer.productions; for (SetOfItems&lt;Item&gt;::iterator itr = set.begin; itr != set.end(); ++itr) &#123; Item item = *itr; GrammarParser::Production prod = productions[item.id]; if (item.position == prod.bodies.size()) /// 当前项的点号在最右边 &#123; if (item.id == 0 &amp;&amp; symbol == GrammarParser::Symbol::EndedSymbolPtr()) &#123; /// 接受状态 AcceptAction *action = new AcceptAction(); return action; &#125; if (item.forwardSymbol-&gt;identifier() == symbol-&gt;identifier) &#123; /// 归约 ReduceAction *redue = new ReduceAction(&amp;prod); set.setActionForSymbol(symbol-&gt;identifier(), redue); return redue; &#125; continue; &#125; int offset = -1; SetOfItems result = lr_goto(set,symbol, &amp;offset); if (result != set) /// 不同的两个状态，说明goto函数有效，此时应该做移入操作 &#123; action = new ShiftAction(offset); set.setActionForSymbol(symbol-&gt;identifier(), action); return action; &#125; &#125; ErrorAction *aciton = new ErrorAction(); return action;&#125; 每个SLR(1)文法都是LR(1)文法。但是对于一个SLR(1)文法而言，规范LR(1)语法分析器的状态要比一个文法对应的SLR语法分析器的状态多。 普遍而言，同一个文法的规范LR语法分析器状态要比SLR语法分析器状态多； 二、LALR现在来看最后一个语法分析器LALR语法分析器。在实践中，用这种方法得到的分析表比规范LR分析表 小很多，而且大部分常见的程序设计语言构造都可以方便地使用一个LALR文法表示。 现在我们再来看看下面这张图： 图中 I_{4} 和 I_{7} 中项的第一个分量是相同，不同的是向前看符号不同。现在我们将 I_{4}和I_{7} 替换为 I_{47} （即I_{4} 和 I_{7}的并集），这个项集中的元素为：[C \rightarrow d\ \cdot \ ,\ c/d/\$ ]。 原来在从I_{0}, I_{2}, I_{3}经过b到达I_{4}, I_{7}的转换，都转向为 I_{47} 。这个经过修改之后的语法分析器行为在本质上和原分析器一样。 在这里： 我们将项第一个分量称为 核心 。 因此上诉的步骤就是在寻找具有相同核心的LR(1)项集，并将这些 “项的集合” 合并为一个项集。关于项、项集、项集族的关系在上一篇文章中有进行说明。 比如T_{3}和I_{6}就具有相同的核心 [C\rightarrow c \cdot C,\ C\rightarrow \cdot cC,\ C\rightarrow \cdot d\ ]。 一般而言，一个核心就是当前正在处理文法的 LR(0) 项集，一个LR(1)文法可能产生多个具有相同核心的项集。 合并具有相同核心的状态不会产生出原有状态中没有出现的移入\归约冲突。因为移入动作仅有核心决定，不考虑向前看运算符。 其中提到的“移入动作仅有核心决定，不考虑向前看运算符”，我们可以看上一节ACTION函数具体行为的第一点。 简单地构造LALR分析器构造语法分析器主要是从三个方面入手，分别是：确定项集，确定GOTO函数和确定ACTION函数。 1）、我们从上面看出，我们可以先构造一个规范LR项集族，然后寻找具有相同核心的项集进行合并； 2）、然后根据核心来确定GOTO函数的关系。如果J是一个或多个LR(1)项集的并集，即 J = I_{1} \bigcup I_{2} \bigcup\ ...\ \bigcup I_{n}，它们能组成并集也就侧面反映了它们具有相同的核心。 由于它们有相同的核心，那么GOTO(I_{1},X),\ ...,\ GOTO(I_{n},X)的核心也是相同的。令K是所有和 GOTO(I_{1},X) 具有相同核心项集的并集，那么 GOTO(J,X) = K 。 3）、关于ACTION函数的逻辑和实现规范LR的类似的（移入、归约、接受）； 显然，这并不是高效的构造LALR语法分析器的方法。就比如在学习正则表达式转换为确定的有穷自动机（DFA）时，我们最初使用的正则表达式转换为NFA，然后通过子集构造法得到DFA。经过探索之后可以直接使用nullable、firstpos、lastpos以及followpos将正则表达式转换为DFA。 同样的，我们也可以用更加高效的方法来构造LALR语法分析表。 ⚠️⚠️⚠️ 高效构造LALR语法分析表我们可以对上面的方法进行修改，使得我们在创建LALR(1)语法分析表的过程中不需要构造出完整的规范LR(1)项集族。 在介绍具体的思想之前，我先解释一下“内核项”。它在上一篇文章中提到，总体来说就是 点号不在最左边，但是增广文法的第一个产生式除外 。下面是构造高效LALR语法分析表的大致思路： 1）、首先，我们可以只使用内核项来表示任意的LR(0)和LR(1)项集； 2）、使用“传播和自生成”的过程来生成向前看符号，根据对应的LR(0)项内核生成LR(1)项内核。 这里我稍微多说一句，“传播和自生成”都是针对向前看符号而言的，“传播”是指我们从上一个项集对应的向前看符号传到下一个项集，作为对应项的向前看运算符。“自生成”则是指的根据GOTO函数和CLOSURE函数生成的向前看符号，具体的生成规则会在下面讲解； 3）、当有了内核之后，就可以使用CLOSURE函数对各个内核求其余项，最后生成语法分析表； 现在我们需要给LR(0)内核加上正确地向前看符号，创建出正确地LALR(1)内核。现在来看一个内核项 A \rightarrow \alpha \cdot B \beta,\ a，以及存在对应产生式 B\rightarrow \gamma \theta ，我们先来看CLOSURE和GOTO： 其CLOSURE函数结果为： [A \rightarrow \alpha \cdot B \beta,\ a], [B\rightarrow \cdot\gamma\theta,\ FIRST(\beta a)] 其中GOTO函数的结果为：GOTO(I, B) = A \rightarrow \alpha B\cdot \beta,\ a ; GOTO(I, \theta) = B\rightarrow \gamma \cdot \theta,\ FIRST(\beta a) 这儿我为什么要求这两个函数的值呢？因为它们和“传播和自生成”关系密切，对于GOTO函数之后得到的项集而言： 如果FIRST(βa) == a 也就是说明FISRT(β)为空，也就是说我们不能在GOTO(I, θ)中自己生成一个向前看符号，因此我们将原来内核项的向前看符号 传播 到新的内核项； 如果FIRST(βa) != a 也就是说明FISRT(β)不为空，那么我们就可以通过FISRT(β) 自生成 一个向前看符号； 有了上面的基础之后，我相信下面这段话应该就可以看懂了： 令#为一个不在当前文法中的符号，令 A\rightarrow \alpha \cdot \beta 为内核LR(0)项。对于每个 X(文法符号) 计算 J = GOTO(CLOSURE(\{[A\rightarrow \alpha \cdot \beta, \#]\}),\ X) 。 对于J中的每个内核项，我们检查它的向前看符号集合： 1、如果#是它的向前看符号，那么向前看符号就是从 A\rightarrow\alpha\cdot\beta 传播到这个项的； 2、除此之外其他的向前看符号都是自发生成的； 向前看符号 $ (结束符号) 对于初始项集中的项 S'\rightarrow \cdot S 而言是自发生成的 伪代码如下： 12345678910111213for (K中的每个项 A -&gt; α·β)&#123; J = CLOSURE(&#123;[A -&gt; α·β, #]&#125;); if ([B -&gt; γ·Xδ, a]在J中，并且a不等于#) &#123; 那么GOTO(I,X)中的项B -&gt; γX·δ向前看符号a是自生成的； &#125; if ([B -&gt; γ·Xδ, a]在J中) &#123; 那么向前看符号从I中的项A -&gt; α·β传播到了B -&gt; γX·δ上； &#125;&#125; 那么到这儿应该就在想，这个传播的最初源头在哪儿呢？很明显这个源头就是增广文法的初始项集[S'\rightarrow \cdot S, \$]。 这块儿主要是理解传播和自生成向前看运算符。 到这儿我们也把规范LR和LALR大致了解了一下，在实际的运用中主要还是使用LALR的语法分析。其原因是它可以通过向前看一个符号来解决移入归约冲突，还有就是可以减少语法分析过程中出现的状态数量。 题外话，后面一段时间我可能不会更新编译原理相关的文章了，回归时间待定了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语法分析——自底向上语法分析中的SLR]]></title>
      <url>%2F2020%2F04%2F28%2Fbottom2top_syntax_parser_basic%2F</url>
      <content type="text"><![CDATA[前言这篇文章主要来看看SLR语法分析，他是一个LR语法分析。其中L表示最左向右扫描，R表示最右推导序列。在本篇文章中，我们会接触 移入-归约 技术。并且还会接触到LR文法类，它是最大的、可以构造出相应移入-归约语法分析器的文法类。 一、归约我们可以将自底向上语法分析过程看成将一个符号串“归约”为文法开始符号的过程。一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号 。 在自底向上的语法分析过程中，关键问题是 何时进行归约以及用哪个产生式进行归约 对于文法： E \rightarrow E + T\ |\ T \\ T \rightarrow T * F \ |\ F \\ F \rightarrow (E) \ |\ \mathbf{id}词法单元序列 id * id 机型自底向上的分析过程： 这个序列中从输入串 id * id 开始，第一次归约使用产生式 F\rightarrow id，将最左边的id归约为F，得到串 F id。第二次归约将F归约为T，生成 T id。 现在（上图中的第四步）我们可以选择是对串T，还是对第二个id进行归约，其中T是产生式 E \rightarrow T 的体，而第二个id是产生式 F \rightarrow id 的体。在这里我们并没有将T归约为E，而是将id归约为F，得到了串 T * F 。然后这个串被归约为T。最后则是将T归约为E，由于E是文法的开始符号，因此整个归约过程便结束了。 因此自底向上的语法分析目的就是反向构造一个推到过程，而 归约正是最右推到的反向过程： E \Rightarrow T \Rightarrow T * F \Rightarrow T * id \Rightarrow F * id \Rightarrow id * id 对输入进行从左到右的扫描，并在扫描过程中进行自底向上的语法分析，就可以反向构造出一个最右推到。 句柄剪枝非正式的讲，“句柄”是和某个产生式体匹配的子串.比如上面的归约过程： 最右句型 归约目标子串 归约用的产生式 句柄 id_{1}*id_{2} id_{1} F \rightarrow id id_{1} F*id_{2} F T\rightarrow F F T*id_{2} id_{2} F\rightarrow id id_{2} T * F T*F T\rightarrow T * F T*F T T E\rightarrow T T E - - - 在上表中，虽然T是产生式E\rightarrow T的体，但符号T并不是句型T*id_{2}的句柄。如果我们把T替换为E之后，发现E为开始符号，那我们也就不能从单一的开始符号推导得到E * id_{2} 。 因此： 和某个产生式体匹配的最左子串不一定是句柄。 正式的对句柄下一个定义：如果存在产生式 S\Rightarrow \alpha A \omega \Rightarrow \alpha \beta \omega，最右句型\gamma 的一个句柄满足如下条件： 将该句型中的子串\beta替换为A之后得到的串 \mu ，串\mu是最右句型\gamma所处最右推导序列中位于\gamma之前的最右句型（稍微转一下弯，这里说的是最右推导的最右句型序列之前，那也就是上面所说的处于归约序列之后的子串）。 同时为了方便起见，我们就把产生式 A\rightarrow \beta 的体\beta 称作句柄。 由于文法存在二义性，因此对于同一个最右句型可能存在多个句柄；而对于无二义性的文法而言，那么该文法的每个最右句型有且只有一个句柄。 而这里提到的句柄剪枝的目的，便是寻找合适的句柄。使得我们可以按照这个过程得到一个 只包含开始符号 的最右句型，因此我们就可以说语法分析过程结束。 而将归约过程中用的产生式反向排序，我们就可以得到输入串的一个最右推导。 移入-归约语法分析技术它使用一个栈来保存文法符号，并用一个输入缓冲区来存放将要进行语法分析的其余符号。句柄在被识别之前，总是出现在栈的顶部。 在对输入串的一次从左到右扫描过程中，语法分析器将零个或多个输入符号移动到栈的顶端，直到它可以对栈顶的一个文法符号串（比如\beta）进行归约为止。将 \beta 归约为某个产生式的头部（即 A\rightarrow \beta，归约为A）。 语法分析器不断重复这个循环，直到它检测到一个语法错误，或者栈中包含了开始符号且输入缓冲区为空。 下表是对输入串“id*id”进行语法分析时，对应的文法符号为： E \rightarrow E + T\ |\ T \\ T \rightarrow T * F \ |\ F \\ F \rightarrow (E) \ |\ \mathbf{id}移入-归约步骤： 栈 输入 动作 $ id_{1}*id_{2} $ 移入（栈中） $ $$id_{1}$ $*id_{2}$$ $ 按照F\rightarrow id进行归约 $ F *id_{2} $ 按照T\rightarrow F进行归约 $ T *id_{2} $ 移入（栈中） $ T* id_{2} $ 移入（栈中） $ T*id_{2} $ 按照F\rightarrow id进行归约 $T*F $ 按照T\rightarrow T*F进行归约 $T $ 按照E \rightarrow T进行归约 $E $ 接受 最后一行我们看到了开始符号E，并且此时输入缓冲区为空。因此我们认为此次移入归约过程结束。 移入-归约语法分析器一共有4种可能的动作： 1、移入：将下一个输入符号移入到栈中（句柄）； 2、归约：语法分析器在栈中确定适当的产生式； 3、接受：栈中包含开始符号，并且输入缓冲区为空； 4、报错：发现语法错误； 句柄总是出现在栈的顶端，绝不会出现在栈的中间。 移入-归约语法分析中的冲突假如知道了栈中的所有内容，以及接下来输入串中的k个输入符号： 移入/归约冲突：当无法判断是进行移入，还是进行归约操作时出现冲突； 对于产生式集合： stmt \rightarrow \mathbf{if}\ expr\ \mathbf{then}\ stmt\\ stmt \rightarrow \mathbf{if}\ expr\ \mathbf{then}\ stmt\ \mathbf{else}\ stmt\\ stmt \rightarrow \mathbf{other}\\ 当栈中元素为$$ if expr then stmt``，而输入串为 ``else ... $$。此时我们都无法确认句柄，因为我们既可以使用第一个产生式进行归约操作，又可以以第二个产生式进行移入操作，这就是移入-归约冲突。 归约/归约冲突：无法在多个可能的归约方法中选择正确的归约动作； 对于产生式集合： ...\\ parameter \rightarrow id\\ expr \rightarrow id\\ ... 此时栈中元素为...id(id，此时id明显需要被归约，但是我们却无法确定使用哪个产生式作为句柄。 在这一节中，我们主要学习了句柄，以及移入-归约的相关知识点。 二、SLR（简单LR技术）目前最流行的自底向上语法分析器都是基于所谓的LR(k)语法分析概念。 其中“L”表示对输入进行从左到右的扫描，“R”表示反向构造出一个最右推导序列，k表示在做出语法分析决定时向前看k个输入符号。目前我们只考虑k小于等于1的清空。 我们一共有三种LR技术：SLR、规范LR、LALR。本节主要讲SLR，下一篇文章讲规范LR和LALR。 项（item）和LR(0)自动机一个LR语法分析器通过维护一些状态，用这些状态来表明我们在语法分析过程中所处的位置，从而做出移入-归约决定。这些状态代表了“项”（item）的集合。 一个文法G的一个LR(0)项是G的一个产生式再加上一个位于它产生式体中某处的点。比如对于产生式 A \rightarrow XYZ 的四个项为： A \rightarrow \cdot XYZ \\ A \rightarrow X \cdot YZ \\ A \rightarrow XY\cdot Z \\ A \rightarrow XYZ\cdot \\ 产生式A \rightarrow \epsilon 只生成一个项 A\rightarrow \cdot 一个项可以表示为 一对整数，第一个整数是基础文法的产生式编号，第二个整数是点的位置。 项指明了在语法分析过程中，我们已经看到了产生式的哪些部分（由点号来区分）。比如对于项 A\rightarrow \cdot XYZ 表明我们希望接下来在输入中看到一个从XYZ推导得到的串；项 A\rightarrow X\cdot YZ 表明我们刚刚从输入中看到了一个可以由X推导得到的串，并且希望接下来能从YZ中推导得到串；项 A\rightarrow XYZ \cdot 表明我们已经看到了产生式体XYZ，已经可以将其归约为A了。 LR(0)自动机的每个状态代表了规范LR(0)项集族中的一个项集（而项集又由多个项组合而成）。对于文法： E \rightarrow E + T\ |\ T \\ T \rightarrow T * F \ |\ F \\ F \rightarrow (E) \ |\ \mathbf{id}我们构造的LR(0)自动机如下（此时看不懂并不重要，因为这里面涉及到的闭包和GOTO尚未学习，在下面学习了闭包和GOTO函数之后可以对照着看看该自动机）： 为了构造一个文法的规范LR(0)项集族，我们需要定一个 增广文法和两个函数：CLOSURE和GOTO 。如果文法G的开始符号为S，那么G的增广文法G^{'}就是在文法G的基础上新增一个产生式 S^{'} \rightarrow S 。 引入新的增广产生式的目的是 告诉语法分析器何时应该停止语法分析并宣称接受输入符号串 。 也就是说当且仅当语法分析器要使用规则 S^{'} \rightarrow S 进行归约时，输入符号串被接受。 这儿我归纳三个概念： 项：单一的个体，在SLR中用一对整数表示（第一个整数是文法的产生式编号，第二个整数是点号在产生式的位置）； 项集：多个项的集合称为项集； 项集族：多个项集的集合称为项集族； 项集的闭包如果 I 是 文法G 的一个项集（项的集合，其数量大于等于1个）。那么构造CLOSURE(I)的规则如下： 1、将I中各个项加入到CLOSURE(I)中； 2、如果CLOSURE(I)中存在一个项 A \rightarrow \alpha \cdot B \beta，并存在产生式B \rightarrow \gamma。如果该产生式的项 B \rightarrow \cdot \gamma 不存在与CLOSURE(I)中，则将项B \rightarrow \cdot \gamma 加入到 CLOSURE(I)中。 一直循环下去，直到没有新的项可以加入到CLOSURE(I)中。 这个可能比较抽象，可以对照上图 I_{0} 项集来理解这两个规则，I_{0} 中白色部分即规则1的方式添加到CLOSURE( I_{0} )中；而灰色部分则是因为点号右边存在非终结符，并且有对应的产生式，那么我们就可以应用规则2 循环将其添加到CLOSURE( I_{0} ) 中。 使用项集闭包的目的就是为了希望能够找到对应的产生式可以推导出点号右边的符号，而项集就是收集所有可能出现的产生式集合。从归约的角度来看，比如对于产生式 A \rightarrow \alpha \cdot B \beta ，此时我们希望能够出现对应的产生式（ B\rightarrow \gamma ）能够归约点号右边即将出现的符号。 反过来看，比如id可以归约为F，F可以归约T，T可以归约为E，而最后E可以归约为 E^{'} ，则归约过程结束。 下面是一个简单的closure函数实现： 123456789101112131415161718192021222324252627282930313233343536373839SetOfItems SLR::CanonicalLR::closure(SetOfItems&amp; set) &#123; SLR::ContextFreeGrammar grammer = this-&gt;grammer; SetOfItems result(set); /// SLR::SetOfItems::items_iterator /// 循环当前项集，需要注意的是是result集合自己在发生变动，同时也是该集合在循环。也就是说如果有新的项被添加到集合内之后，还会继续查看这个新项的产生式情况 for (SLR::items_iterator itr = result.begin(); itr != result.end(); ++itr) &#123; Item item = *itr; /// 在书中我们知道项的表示方式是：数对 /// item.id: 一个数表示当前项在产生式集合中和的下标（第几个具体的产生式） /// item.position: 另一个数是表示点号在产生式体中的下标 SLR::Production production = grammer.productions[item.id]; /// 没有做越界保护 vector&lt;Symbol *&gt;bodies = production.bodies; if (item.position &gt;= bodies.size()) &#123; /// 说明此时点号在产生式的最右边，也就是说此时我们已经可以把产生式体归约为产生式头部了，无需继续添加 continue; &#125; Symbol* symbol = production.bodies[item.position]; bool isTerminal = symbol-&gt;isTerminal(); if (isTerminal) &#123; continue; &#125; /// 此时点号右边是非终结符，需要查看该非终结符是否有对应的产生式 int id = symbol-&gt;identifier(); vector&lt;Production&gt; productions = grammer.productions; bool contain_grammer = false; for (vector&lt;Production&gt;::iterator itr = productions.begin(); itr != productions.end(); ++itr) &#123; int idx = itr-productions.begin(); if ((itr-&gt;header).identifier() == id) &#123; Item new_item(idx,0); result.push_back(new_item); &#125; &#125; &#125; return result; &#125; 我们通过观察上图可以知道，如果点在最左边的某个产生式（比如上面的 E^{'}\rightarrow \cdot\ E ）被加入到项集族 I 中，那么该产生式所有依据closure函数添加到项集中的项（比如上图中灰色区域部分的项）我们是没有必要全部列出来的，因此我们将上图中白色区域中的项称为 内核项，灰色区域的项称为 非内核项。 内核项：包括初始项E{'} \rightarrow \cdot E，以及所有点不在最左边的项； 非内核项：除了初始项之外，所有点在最左边的项； 通过求闭包时加入的项不可能是内核项，因此我们抛弃所有非内核项，就可以用很少的内存来表示真正感兴趣项的集合。 GOTO函数函数GOTO(I,X)，其中 I 是项集族中的一个项集，X为一个文法符号。该函数用于定义一个文法的LR(0)自动机中的转换，这个自动机的状态对应于项集族中的项集，而GOTO函数描述了当输入为X时，离开状态X的转换。 比如我截取了上面大图中的一个部分 ： 它就表示了函数 GOTO(I_{1},\ +) 。 下面的代码大致的实现了一下GOTO函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SetOfItems SLR::CanonicalLR::lr_goto(SetOfItems&amp; set, Symbol *symbol, int *offset) &#123; int index = set.cacheForSymbol(symbol-&gt;identifier); if (index &gt;= 0) &#123; if (offset != nullptr) &#123; *offset = index; &#125; return item_set[index]; &#125; ContextFreeGrammar grammer = this-&gt;grammer; SetOfItems result; for (SLR::items_iterator itr = set.begin(); itr != set.end(); ++itr) &#123; Item item = *itr; /// 在书中我们知道项的表示方式是：数对 /// item.id: 一个数表示当前项在产生式集合中和的下标（第几个具体的产生式） /// item.position: 另一个数是表示点号在产生式体中的下标 uint idx = item.id; if (idx &gt;= grammer.productions.size()) &#123; return set; /// 异常 &#125; Production production = grammer.productions[idx]; vector&lt;Symbol *&gt; bodies = production.bodies; if (item.position &gt;= bodies.size()) &#123; continue; /// 点号在产生式的最右边； &#125; Symbol *current_sym = bodies[item.position]; if (current_sym-&gt;identifier() != symbol-&gt;identifier()) &#123; continue; &#125; Item new_item(idx,item.position+1); /// 点号右移 int index = contain_item(new_item); if (index &gt;= 0) &#123; /// 如果生成的item已经存在于某一个项集中，则返回当前项集 return item_set[index]; &#125; /// 新生成的item并未存在，将该项放入新的项集中 std::string key = format(&quot;%d_%d&quot;,item.id,item.position); item_map.insert(make_pair(key, item_set.size())); result.push_back(new_item); &#125; if (result.count() &gt; 0) &#123; if (offset) &#123; *offset = item_set.size(); item_set.push_back(result); set.setCache(*offset, symbol-&gt;identifier()); &#125; &#125; return result;&#125; LR(0)自动机的用法（帮助我们进行移入-归约操作）下面是通过使用CLOSURE函数和GOTO函数构造规范LR(0)项集族的方法： 123456789101112131415161718192021void SLR::CanonicalLR::items() &#123; /// 获取增广文法的初始化产生式，并构造初始的项集 SetOfItems set; Item augmented_item(0,0); set.push_back(augmented_item); (this-&gt;item_set).push_back(set); /// 初始项集族 /// 遍历每一个项集 for (vector&lt;SetOfItems&gt;::iterator vitr = (this-&gt;item_set).begin(); vitr != (this-&gt;item_set).end(); ++vitr) &#123; /// 遍历当前文法所有的符号 for (vector&lt;SLR::Symbol *&gt;::iterator itr = grammer.symbols.begin(); itr != grammer.symbols.end() ++itr) &#123; SetOfItems result = lr_goto(*vitr, *itr); int contain = contain_set(result); if (contain == -1) &#123; item_set.push_back(result); &#125; &#125; &#125;&#125; SLR的中心思想是根据文法构造出LR(0)自动机。这个自动机的状态是规范LR(0)项集族中的元素，而它的转换由GOTO函数给出。我们再来看看LR(0)自动机 LR(0)自动机可以帮助我们决定何时进行移入，何时进行规约操作。 假设文法符号串 γ 使得LR(0)自动机从开始状态0运行到某个状态 j 。此时如果下一个输入符号为 a，并且状态 j 有一个在 a 上的转换（即存在GOTO(j, a)），那么此时我们就 移入 a；否则我们就选择 归约 动作。我们可以通过查看状态 j （项集）内各个项点号的位置，来决定如何进行归约操作（具体可以看本节开头部分关于点号存在不同位置所表达的含义）。 比如，E^{'} \rightarrow E\cdot 的点号在最右边，它的意思是说我们已经收到期望归约所需的全部符号，可以进行归约了；而 E\rightarrow E\cdot+T 的点号右边存在符号”+”，说明此时我们收到了符号E，如果想要以该产生式进行归约的话，我期望下一个输入串是”+”。因此当输入“+”号，LR(0)自动机认为此时需要做移入操作；而当输入为非”+”号时，LR(0)将以项集中第一个项进行归约操作。 ACTION函数在前面我们已经知道如何编写和使用GOTO函数，但是并不知道ACTION函数是如何实现的。那么现在我们就来具体的看看是如何构造ACTION函数的: 1）、如果项 [A \rightarrow \alpha \cdot a \beta] 在状态i中。并且GOTO(Ii, a) 为新状态 j，那么 ACTION(i,a) 函数对应的输出值为 “移入 j”； 2）、如果项 [A \rightarrow \alpha \cdot] 在状态i中，那么对于FOLLOW(A)中所有的a，将 ACTION(i,a) 的输出值为 “归约 A -&gt; α”。这里A不是增广文法的开始符号； 3）、如果增广文法的开始项，比如 [S' \rightarrow S] 在状态i中，那么 ACTION(i, $) 输出值为 “接受”； 如果使用上诉规则时，发生了任何冲突动作。我们就说这个文法不是SLR(1)的。 ACTION(i,a) 存在两个参数，分别是表示状态的i，以及 终结符号 a（下面我已经把ACTION函数的伪代码实现已列出）。而ACTION函数的返回值有四种可能，分别是： 移入：语法分析器采取的动作是把输入符号 a 高效的移入栈中； 归约：语法分析器的动作是把栈顶元素高效地归约为对应产生式的头部（比如产生式A \rightarrow \beta，将β归约为A）； 接受：语法分析器接受输入并完成语法分析过程； 报错：语法分析器在它的输入中发现了一个错误，并执行某个纠正错误动作； 下面是Action函数的一个伪代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364SLR::LR_Action* SLR::CanonicalLR::action(SetOfItems&amp; set, SLR::Symbol *symbol) &#123; if (symbol-&gt;isTerminal() == false) /// 非终结符直接返回 &#123; return nullptr; &#125; LR_Action *action = set.actionForSymbol(symbol-&gt;identifier()); if (action != nullptr) &#123; return action; &#125; int offset = -1; SetOfItems result = lr_goto(set,symbol, &amp;offset); if (result != set) /// 不同的两个状态，说明goto函数有效，此时应该做移入操作 &#123; action = new ShiftAction(offset); set.setActionForSymbol(symbol-&gt;identifier(), action); return action; &#125; ContextFreeGrammar grammer = this-&gt;grammer; SetOfItems result; for (SLR::items_iterator itr = set.begin(); itr != set.end(); ++itr) &#123; Item item = *itr; /// 在书中我们知道项的表示方式是：数对 /// item.id: 一个数表示当前项在产生式集合中和的下标（第几个具体的产生式） /// item.position: 另一个数是表示点号在产生式体中的下标 uint idx = item.id; if (idx &gt;= grammer.productions.size()) &#123; continue; /// 异常 &#125; Production production = grammer.productions[idx]; vector&lt;Symbol *&gt; bodies = production.bodies; if (item.position != bodies.size()) &#123; continue; &#125; /// 点号在最左边，并且当前产生式为产生式集合中的第一个，即增广文法的产生式 if (idx == 0) &#123; action = new AcceptAction(); set.setActionForSymbol(symbol-&gt;identifier(), action); return action; &#125; /// 点号在产生式的最右边的一般情况 vector&lt;Symbol *&gt; syms = grammer.FOLLOW(&amp;(production.header)); for (vector&lt;Symbol *&gt;::iterator itr = syms.begin(); itr != syms.end(); ++itr) &#123; if (symbol -&gt; identifier() == (*itr)-&gt;identifier()) &#123; action = new ReduceAction(&amp;production); set.setActionForSymbol(symbol-&gt;identifier(), action); return action; &#125; &#125; &#125; action = new ErrorAction(); set.setActionForSymbol(symbol-&gt;identifier(), action); return action;&#125; LR语法分析算法下图是一个LR语法分析器的示意图，它由一个输入、一个输出、一个栈、一个驱动程序和一个语法分析表组成，其中语法分析表包括了两个部分，分别是ACTION和GOTO： 1）、栈中保存的是LR(0)自动机中的状态，各个状态都和某个项集对应； 2）、语法分析表是随着语法分析器的不同而变化的。GOTO对应于自动机的转换；而ACTION则表示当前的动作； 我们定义LR语法分析器的配置如下： (s_{0}s_{1}...s_{m},\ a_{i}a_{i+1}...a_{n},\ \$);其中第一个分量表示栈中的内容（上图中左侧的栈，其中sm 为栈顶 ），第二个分量是余下的输入串。我们可以来看看ACTION函数和LR语法分析器配置是如何配合使用的： ACTION[s_{m},a_{i}]=移入\ s ：那么语法分析器就执行一次移入动作，将下一个状态s移入栈中，此时的配置为： (s_{0}s_{1}...s_{m}s,\ a_{i+1}...a_{n},\ \$); ACTION[s_{m},a_{i}] = 归约 A\rightarrow \beta ：那么语法分析器执行一次归约动作，其中r是β的长度，$s = GOTO[s_{m-r}, A]$ 语法分析器首先将r个状态符号弹出栈，使得状态 sm-r 位于栈顶，然后语法分析器将 s 压入栈中。 在一个归约动作中，当前输入符号不发生改变 。 (s_{0}s_{1}...s_{m-r}s,\ a_{i}a_{i+1}...a_{n},\ \$); ACTION[s_{m},a_{i}] = 接受 ： 表示语法分析过程完成； ACTION[s_{m},a_{i}] = 报错 ： 表明语法分析器发生了一个语法错误； 两个LR语法分析器之间唯一的区别是他们的语法分析表ACTION表项和GOTO表项中包含的信息不同； 现在我们可以综合上面已有的知识来写一个简单的SLR语法分析程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class CanonicalLR &#123;private: ContextFreeGrammar grammer; vector &lt;SetOfItems&gt; item_set; map&lt;string,int&gt; item_map; /// key: item.id+item.position; value: item_set indexpublic: SetOfItems closure(SetOfItems&amp; set); SetOfItems lr_goto(SetOfItems&amp; set, SLR::Symbol *symbol, int *offset); SLR::LR_Action* SLR::CanonicalLR::action(SetOfItems&amp; set, SLR::Symbol *symbol); void items(); int contain_set(SetOfItems&amp; set); /// 不包含返回-1，包含返回非负数 int contain_item(Item&amp; item); /// 不包含返回-1，包含返回非负数 friend class SLRAnalyser;&#125;;class SLRAnalyser &#123; vector&lt;Symbol *&gt; inputTokens; /// 输入串 stack&lt;int&gt; stack_; CanonicalLR lr;public: /// 出现错误时，信息记录 struct Error&#123; Symbol *sym; stack&lt;int&gt; stck; Error(Symbol *s, stack&lt;int&gt;&amp; sk):sym(s),stck(sk)&#123;&#125; Error() &#123; sym = nullptr; &#125; &#125;;private: Error error;public: SLRAnalyser() &#123; stack_.push(0); &#125; SLRAnalyser::Error slrError() &#123; /// 当出现异常时，获取错误信息 return error; &#125; vector&lt;Production&gt; start() &#123; vector&lt;Production&gt; result; int i = 0; Symbol *input_sym = inputTokens[i]; while (1) &#123; int idx = stack_.top(); SetOfItems set = lr.item_set[idx]; LR_Action *action = lr.action(set, input_sym); if (action-&gt;isShiftAction()) /// 移入 &#123; ShiftAction *shift_action = dynamic_cast&lt;ShiftAction *&gt;(action); int dst = shift_action-&gt;opNum; stack_.push(dst); i++; input_sym = inputTokens[i]; &#125; else if (action-&gt;isReduceAction()) /// 归约 &#123; stack_.pop(); ReduceAction *reduce_action = dynamic_cast&lt;ReduceAction *&gt;(action); Symbol *sym = &amp;(reduce_action-&gt;production-&gt;header); SetOfItems c_set = lr.item_set[stack_.top()]; int dst; lr.lr_goto(c_set, sym, &amp;dst); stack_.push(dst); result.push_back(reduce_action-&gt;production); &#125; else if (action-&gt;isAcceptAction()) /// 接受 &#123; error.sym = nullptr; stack&lt;int&gt; sk; error.stck = sk; break; &#125; else /// 报错 &#123; SLRAnalyser::Error err(input_sym, stack_); error = err; break; &#125; &#125; return result; &#125;&#125;; 可行前缀在结束SLR相关内容之前，我们来看看“可行前缀”。可以出现在移入-归约语法分析器栈中的最右句型前缀被称为 可行前缀 ，详细定义为： 一个可行前缀是一个最右句型的前缀，并且该前缀没有越过该句型最右句柄的右端。 因此我们可以在可行前缀之后增加一些终结符号来得到一个最右句型。这里再说一下上面的提到的几个概念： 最右句型：从开始符号推导得到终结符的过程中出现的产生式，我们说这就叫句型。而最右句型指的是使用最右推导时出现的句型（最右推导，总是选择最右边的非终结符号）； 句子是不包含非终结符号的特殊句型； 最右句柄：在本篇文章的开头有讲，简单来说在最右句型归约时选择的产生式，而句柄正式该产生式的产生式体； 比如对于一个推导过程 S \rightarrow \alpha A w \rightarrow \alpha \beta_{1}\beta_{2}w，对于产生式A\rightarrow\beta_{1}\beta_{2} ，我们就可以说前缀 \alpha\beta_{1} 对于句柄 \beta_{1}\beta_{2} 是有效的，因为前缀 \alpha\beta_{1} 并未包含 \beta_{2} ，所以\alpha \beta_{1}是一个可行前缀。 这里的\alpha \beta_{1}\beta_{2}w称为最右句型（因为对于句型\alpha A w而言，w为终结符号，最右边的非终结符号为A）； 这里 \beta_{1}\beta_{2} 作为产生式 A\rightarrow\beta_{1}\beta_{2} 的产生式体，而w不能进行归约，而最右边可以进行的只有\beta_{1}\beta_{2}，因此它就是该句型的最右句柄。而\beta_{2}是作为该句柄的最右端。 现在综合上面所有的信息来看可行前缀，即该前缀是最右句型的一个前缀，而且该前缀没有包含完整的句柄，因为如果包含了完整的句柄之后，那么该最右句型就可以将产生式体归约为产生式头。 而可行前缀的作用是：可行前缀信息可以帮助我们决定是进行归约还是移入操作。比如当我们遇到了可行前缀之后，很明显目前还不能进行归约操作，因为进行归约操作的句柄还不完整。因此遇到可行前缀之后大多数情况下是要进行移入操作的；只有当句柄的最右端为空串时，此时应该做归约操作。 结语在这篇文章中，我们主要是接触了一些LR语法分析的基本概念。以及最简单的SLR语法分析技术，并且给出了相应的伪代码，包括有CLOSURE\GOTO\ACTION等等（关于相关类之间的关系在我的Github上能找到）。最后介绍了一个很重要的概念——可行前缀，这在后续的两个LR语法分析器中都有涉及。 说个题外话，之前在学习这方面知识的时候一直在思考这个产生式（包括对应的语法分析树）具体的作用是什么，体现在了什么地方。很显然在日常开发工作中基本上是不需要关心的。直到最近我在看clang文档-Grammar Additions时，里面看到了关于”@”相关语法的产生式，瞬间感觉到了亲切感：1234567891011121314151617181920212223242526272829objc-at-expression : &apos;@&apos; (string-literal | encode-literal | selector-literal | protocol-literal | object-literal) ;object-literal : (&apos;+&apos; | &apos;-&apos;)? numeric-constant | character-constant | boolean-constant | array-literal | dictionary-literal ;boolean-constant : &apos;__objc_yes&apos; | &apos;__objc_no&apos; | &apos;true&apos; | &apos;false&apos; /* boolean keywords. */ ;array-literal : &apos;[&apos; assignment-expression-list &apos;]&apos; ;assignment-expression-list : assignment-expression (&apos;,&apos; assignment-expression-list)? | /* empty */ ;dictionary-literal : &apos;&#123;&apos; key-value-list &apos;&#125;&apos; ;key-value-list : key-value-pair (&apos;,&apos; key-value-list)? | /* empty */ ;key-value-pair : assignment-expression &apos;:&apos; assignment-expression ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语法分析——自顶向下语法分析]]></title>
      <url>%2F2020%2F04%2F20%2Ftop2bottom_syntax_parser%2F</url>
      <content type="text"><![CDATA[前言自顶向下语法分析可以被看作是为输入串构造语法分析树的问题，它从语法分析的根节点开始，按照深度优先的规则创建这棵语法分析树的各个结点，自顶向下语法分析也可以被看作寻找输入串最左推导的过程。 本文的行文以下面的顺序展开： 1）、首先是以一个自顶向下语法分析的例子，为自顶向下语法分析有个大致的认识； 2）、其次我们就需要深入地了解自顶向下语法分析中使用到的“ 递归下降语法分析”； 3）、但递归下降的语法分析存在一个很大的弊端就是有回溯的可能性，为了减少回溯的次数，因此我们需要向前看多个字符。 LL(k) ，其中k表示向前看的字符数； 4）、为了能够更加准确地知道向前看字符，我们需要构造“ 预测分析表 ”，而 FIRST 和 FOLLOW 集合是构造预测分析表必不可少的部分； 好吧，那我们先来看一个自顶向下的语法分析例子。 一、自顶向下语法分析示例我们消除了左递归之后的文法（关于消除左递归可在上一篇文章中查看）： E \rightarrow TE^{'} \\ E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ T \rightarrow FT^{'}\\ T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ F \rightarrow (E)\ |\ \mathbf{id}对于输入串 id + id*id 语法分析树推导序列如下图所示： 这里使用的最左推导，每次都是寻找当前语法分析树中最左边的非终结符进行推导操作。在自顶向下的分析过程中，对于同一非终结符号的选择指定产生式成为了关键问题，比如对于非终结符F来说，它存在两个产生式 F \rightarrow (E) 和 F \rightarrow \mathbf{id} ，如果我们选择错误之后，则难免需要进行回溯，并替换为另一个正确地产生式。这种分析方式就是我们首先要学习的 递归下降语法分析 。 但我们可以使用预测分析技术来避免回溯的发生，它通过向前看固定多个符号来选择正确地产生式。比如我们向前看 k 个符号，那么这类文法为 LL(k) 文法。而我们后续要学习的LL(1)文法，就是该文法的特例。即我们向前看1个符号。 递归下降的语法分析一个递归下降语法分析程序由一组过程（也可以理解为C语言里面的函数）组成，每个非终结符号有一个对应的过程。比如： 123void expr() &#123;...&#125;void statement() &#123;...&#125;void S() &#123;...&#125; 程序的执行从开始符号对应的过程开始，如果这个过程完整地扫描了整个输入串，它就停止执行并宣布语法分析成功完成。 下面是一段伪代码： 12345678910111213void X1() &#123;...&#125;void X2() &#123;...&#125;...void Xk() &#123;...&#125;void A() &#123; 选择一个A产生式：A -&gt; X1X2X3... Xk； /// 需要注意的是这里X1, X2, X3, ... Xk组成的一个符号串，并不是非终结符号A的多个产生式 for(i = 1 to k) &#123; if (Xi 是一个非终结符号) &#123; 调用Xi(); &#125; else if (Xi等于当前的输入符号a) &#123; 读取下一个输入符号; &#125; else &#123; 发生错误; &#125; &#125;&#125; 上面的Xi有可能就是非终结符号A自身，因此可能会形成递归调用的场景。通用的递归下降分析技术可能需要回溯，也就是说我们可能需要重复扫描输入。要支持回溯的话，那我们就需要修改上面的代码： 1）、首先需要按照非终结符号产生式的顺序逐个尝试各个产生式； 2）、然后需要一个局部指针变量来保存当前进行匹配的符号； 3）、如果发生当前既不是非终结符号，又不等于当前的输入符号时。我们需要将输入符号回溯到局部指针变量指向的符号； 4）、如果再也没有当前非终结符号产生式可尝试时，我们才认为发生了错误； 1234567891011121314151617181920212223242526272829303132void X1() &#123;...&#125;void X2() &#123;...&#125;...void Xk() &#123;...&#125;char *input_char; /// 输入字符void A() &#123; 非终结符号A的产生式集合：&#123; A-&gt;X1X2X3... Xk, A-&gt;Y1Y2Y3... Yk, A-&gt;Z1Z2Z3... Zk ... &#125; for (选择一个A产生式：A -&gt; X1X2X3... Xk) &#123; /// -----&gt; 1 char *pivot = &amp;a; /// -----&gt; 2 for(i = 1 to k) &#123; if (Xi 是一个非终结符号) &#123; 调用Xi(); &#125; else if (Xi等于当前的输入符号*input_char) &#123; 读取下一个输入符号; input_char++; &#125; else &#123; input_char = pivot; /// -----&gt; 3 break; &#125; /// 继续读取下一个产生式 &#125; &#125; if (*input_char == *pivot) &#123; 发生了错误; /// -----&gt; 4 &#125;&#125; Ⅰ、具体实例下面我们来看一个具体的例子，对于文法： S \rightarrow c A d \\ A \rightarrow ab\ |\ a对于输入串 w = cad，其递归下降的语法分析过程为： 1、对于开始符号S \rightarrow c A d ，并且此时的输入指针为 c，此时我们展开开始符号S 2、从输入指针指向的输入符号 c 和当前开始符号S展开的语法分析树最左边的叶子结点c相匹配，此时我们将指针移动到 a，并且考虑当前语法分析树的非终结符号A（从左到右扫描符号）。 3、我们使用产生式 A \rightarrow ab 进行展开。很明显第二个输入符号 a 匹配成功。 4、现在我们将输入指针移动到 d ，并且把语法分析树的当前结点移动到结点 b 。很明显可以看出来 d 和 b 并不匹配。 5、此时我们需要查看对于非终结符号A，是否存在尚未尝试过的产生式。在回到A时，我们需要将输入指针回退到上一个位置处，并且使用产生式 A \rightarrow a 进行推导： 叶子结点 a 和当前输入指针指向的输入符号成功匹配。同样的移动输入指针到 d ，并且将目光移向语法分析树最右边的叶子结点处，它们同样是匹配的。因此上图中的语法分析树就是通过递归下降得到的结果。 一个左递归的文法会使得它的递归下降语法分析器进入一个无限循环。 由于回溯不是很高效，我们可以使用动态规划算法，构造基于表格的的方法。我会在单独的一篇文章来介绍一下动态规划。 二、🍺🍺🍺 FIRST和FOLLOW集合（终结符号）关于FIRST集合和FOLLOW集合一定要弄懂，因为这是在后续进行预测分析时必备的技能。在自顶向下的语法分析过程中，FIRST和FOLLOW使得我们可以根据下一个输入符号来选择应用哪个产生式。 Ⅰ、FIRSTFIRST(α) ：从 α 可以推导出一个串集合，而FIRST为这些串首个符号组成的集合； 如果 \alpha \overset{*}{\rightarrow} \epsilon (箭头上方的星号 * 表示 α 可以通过多个步骤之后得到 ε )，那么 ε 就在 FIRST(α) 中。又或者存在推导 \alpha \overset{*}{\rightarrow} c\gamma那么终结符号 c 也在 FIRST(α) 中。 计算文法符号X的FIRST(X)时，不断应用下面的规则，直到再没有新的 终结符号或者ε 可以被加入到任何FIRST集合中为止： 1）、如果X是终结符号，那么FIRST(X) = X； 2）、如果X是一个非终结符号，且存在产生式 X \rightarrow Y_{1}Y_{2}...Y_{k} （其中k&gt;1）： 如果终结符号 a 在 FIRST(Y_{i}) 中的必要条件是 FIRST(Y_{1})、FIRST(Y_{2})、...、FIRST(Y_{i-1}) 中包含有 ε 符号； 比如 FIRST(Y_{1}) 中所有符号一定都在 FIRST(X) 中，如果 Y_{1} 不能推导出 ε，那么我们就没有必要再向 FIRST(X) 加入任何符号。但是如果 Y_{1} 能推导出 ε，那么我们就需要查看其后非终结符号的推导情况了。 简单来说就是，对于文法中非终结符号的产生式而言，观察其产生式体能够推导出终结符号的集合。 3）、如果 X \rightarrow ε 是一个产生式，那么 ε 加入到 FIRST(X) 中； 也就是说： 对于FIRST(α)我们看产生式头可以推导得到的产生式体中的首个符号集合，即计算FIRST时非终结符号处于产生式的头部。 下面是FIRST集合求解的代码（靠着自己理解编写，难免存在问题，如有问题麻烦指出）: 12345678910111213141516171819202122232425262728293031vector&lt;Symbol *&gt; GrammarParser::ContextFreeGrammar::FIRST(Symbol *sym) &#123; /// 视角总是把当前符号当做产生式的头部 vector&lt;Symbol *&gt;firsts; /// 1、如果是一个终结符号，那么FIRST返回它自身 if (sym-&gt;isTerminal()) &#123; firsts.push_back(sym); return firsts; &#125; /// 2、如果是一个非终结符号，并且是一个产生式 for (vector&lt;Production&gt;::iterator itr = this-&gt;productions.begin(); itr != this-&gt;productions.end(); ++itr) &#123; Nonterminal header = itr-&gt;header; /// &lt;--------- 产生式头部 if (header.identifier() != sym-&gt;identifier()) &#123; continue; &#125; vector&lt;Symbol *&gt;bodies = itr-&gt;bodies; for (vector&lt;Symbol *&gt;::iterator s_itr = bodies.begin(); s_itr != bodies.end(); ++s_itr) &#123; if (*s_itr == Symbol::EmptySymbolPtr()) &#123; /// 3、如果是一个推出空串的产生式 firsts.push_back(*s_itr); continue; &#125; vector&lt;Symbol *&gt;temp = FIRST(*s_itr); firsts.insert(firsts.end(),temp.begin(),temp.end()); /// 递归查看当前符号的FIRST集合情况 &#125; &#125; return firsts;&#125; Ⅱ、FOLLOWFOLLOW(A)：定义为在某些句型中，紧跟在非终结符号A右边的终结符号集合。 比如对于句型 S \overset{*}{\rightarrow} \alpha A a \beta ，终结符号 a 就在 FOLLOW(A) 中。如果非终结符号A是某些句型的最右符号，那么特殊的 “结束标记” $ 也在FOLLOW(A)中。 和FIRST集合类似，计算所有非终结符号A的FOLLOW(A)集合时，不断应用下面的规则，直到再没有 新的终结符号 可以被加入到任意FOLLOW集合中为止： 1）、将 $ 放到FOLLOW(S)中，其中S是开始符号，而 $ 是输入右端的结束标记； 2）、如果存在一个产生式 A\rightarrow\alpha B \beta ，那么FIRST(β)中除了ε之外的所有符号都在FOLLOW(B)中。即这块儿需要查看符号串β的推导； 3）、如果存在一个产生式 A\rightarrow\alpha B，那么FOLLOW(A)中所有的符号同时也都在FOLLOW(B)中； 也就是说： 计算FOLLOW时非终结符号位于产生式体中，查看当前产生式体中（或者叫句型的右边部分）非终结符号紧挨着的 终结符号 集合。 下面是FOLLOW集合的请求代码（和上面相同，同样可能存在问题）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081vector&lt;Symbol *&gt; GrammarParser::ContextFreeGrammar::FOLLOW(Symbol *sym) &#123; /// 视角总是将当前符号放在产生式体中 vector &lt;Symbol *&gt; follows; /// 1、如果当前符号时开始符号，那么将结束标记加入到follows中 if (sym-&gt;identifier() == productions[0].header.identifier()) &#123; Symbol *end = const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr()); follows.push_back(end); return follows; &#125; if (sym-&gt;isTerminal()) &#123; return follows; &#125; /// 判断当前迭代器是否是body中的最后一个符号， auto expr_last = [&amp;follows,this](vector&lt;Symbol *&gt;::iterator current, vector&lt;Symbol *&gt;::iterator begin, size_t count, Symbol *header_ptr) -&gt; bool &#123; size_t idx = current - begin; bool result = false; if (idx == count - 1) /// 当前符号处于产生式体的末尾 &#123; /// 如果存在一个产生式 A --&gt; aB，那么FOLOOW(A)中所有符号都在FOLLOW(B)中 vector&lt;Symbol *&gt; temp = FOLLOW(header_ptr); follows.insert(follows.end(), temp.begin(), temp.end()); result = true; &#125; return false; &#125;; /// 2、如果存在一个产生式 A --&gt; aBb，那么FIRST(b)中除了空串以外，所有符号都在FOLLOW(B)中 for (vector&lt;Production&gt;::iterator itr = this-&gt;productions.begin(); itr != this-&gt;productions.end(); ++itr) &#123; Nonterminal header = itr-&gt;header; Symbol *header_ptr = &amp;header; vector&lt;Symbol *&gt;bodies = itr-&gt;bodies; size_t count = bodies.size(); vector&lt;Symbol *&gt;::iterator sym_itr = bodies.end(); /// 求解当前FOLLOW集合的符号指针； for (vector&lt;Symbol *&gt;::iterator s_itr = bodies.begin(); s_itr != bodies.end(); ++s_itr) &#123; if (sym_itr != bodies.end()) &#123; /// 第2种情况求解 size_t first_index = s_itr - sym_itr; if (first_index &lt;= 0) &#123; continue; &#125; vector&lt;Symbol *&gt; firsts = FIRST(*s_itr); for (vector&lt;Symbol *&gt;::iterator first_itr = firsts.begin(); first_itr != firsts.end(); ++first_itr) &#123; if (*first_itr == Symbol::EmptySymbolPtr()) &#123; /// 3、如果存在一个产生式 A --&gt; aB，或者产生式 A --&gt;aBb（FIRST(b)包含空串），那么FOLOOW(A)中所有符号都在FOLLOW(B)中 bool result = expr_last(s_itr, bodies.begin(), count, header_ptr); size_t idx = s_itr - bodies.begin(); if (result) &#123; sym_itr = bodies.end(); &#125; break; &#125; follows.push_back(*first_itr); sym_itr = bodies.end(); &#125; &#125; if (sym-&gt;identifier() != (*s_itr)-&gt;identifier()) &#123; continue; &#125; /// 3、如果存在一个产生式 A --&gt; aB，或者产生式 A --&gt;aBb（FIRST(b)包含空串），那么FOLOOW(A)中所有符号都在FOLLOW(B)中 bool result = expr_last(s_itr, bodies.begin(), count, header_ptr); if (result) &#123; break; &#125; sym_itr = s_itr; continue; &#125; &#125; return follows;&#125; Ⅲ、示例我们对下面文法来求解FIRST和FOLLOW集合： E \rightarrow TE^{'} \\ E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ T \rightarrow FT^{'}\\ T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ F \rightarrow (E)\ |\ \mathbf{id}首先我们以非终结符号出现的顺序，将它们按照顺序排列起来（有点像消除左递归时，我们创建的非终结符号集合）： E,\ T,\ E^{'},\ F,\ T^{'} 1）、 非终结符号E ： FIRST(E) = { ( , id }，其推导过程为： E \Rightarrow TE^{'} \Rightarrow FT^{'}E^{'} \Rightarrow (E)T^{'}E^{'}\ |\ \mathbf{id}； FOLLOW(E) = { ), $ }。从产生式 F \rightarrow (E) 我们可以得到一个终结符号。而且从求FOLLOW的第一点可知，对于开始符号，我们需要将$添加进去。 2）、 非终结符号E’： FIRST(E’) = { +, ε }，其推导过程为：E^{'} \rightarrow +TE^{'}\ |\ \epsilon。 FOLLOW(E’) = { ), $ }，这是因为产生式 E \rightarrow TE^{'} 可知，FOLLOW(E)和FOLLOW(E’)是完全等价的。 3）、 非终结符号T：FIRST(T) = { ( , id }，其推导过程为： T \Rightarrow FT^{'} \Rightarrow (E)T^{'}E^{'}\ |\ \mathbf{id} FOLLOW(T)的计算从上述的文法中可以看出，非终结符号T出现在产生式体中的有 TE^{'},\ +TE^{'} ，也就是在其后面的均为非终结符号E’。因此FOLLOW(T)包含FIRST(E’)； 由于E’可以推导出空串ε，而且根据产生式 E \rightarrow TE^{'} 。我们可以知道FOLLOW(T)同样等于FOLLOW(E)。因此求出上面两个的并集为： FOLLOW(T) = { +, ), $ }。 4）、 非终结符号T‘：FIRST(T’) = { , $ }，其推导过程为：$$ T’\rightarrow FT’$$； FOLLOW(T’) = { +, ), $ }。这是因为根据产生式 T \rightarrow FT^{'} 可知，FOLLOW(T’)和FOLLOW(T)是相同的； 5）、 非终结符号F：FIRST(F) = { (, id }，其推导过程为 F \rightarrow (E)\ |\ \mathbf{id} ； FOLLOW(F)的计算和非终结符号T是类似的，首先我们根据产生式 T \rightarrow FT^{'},\ T^{'} \rightarrow *FT^{'}可知，非终结符号F其后紧跟着非终结符号T’，因此FOLLOW(F)则包含了FIRST(T’)； 而且我们从产生式 T \rightarrow FT^{'},\ T^{'} \rightarrow *FT^{'}\ |\ \epsilon 可知，T’可以推导出空串ε，因此FOLLOW(F)也包含有FOLLOW(T)； 因此最终的结论为：FOLLOW(F) = { *, +, ), $ } 如果这块儿存在无法理解的部分，可以对照例子，返回查看FIRST和FOLLOW的计算方式。 三、🍭🍭🍭LL(1)文法LL(1)中的第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，而“1”则表示在每一步中只需要向前看一个输入符号来决定语法分析动作。我们利用LL(1)的文法，可以构造出不需要回溯的递归下降语法分析器（即预测分析器）。 左递归文法和二义性文法都不可能是LL(1)的 对于任意两个不同的产生式：A\rightarrow\alpha\ |\ \beta，只有满足下面条件时，它们才是LL(1)文法： 1）、不存在终结符号a，使得 α 和 β 都能够推导出以 a 开头的串； 意思也就是说，FIRST(α) 和 FIRST(β) 是不相交的集合。 2）、 α和β中最多只有一个可以推导出空串； 当然这里一样的，FIRST(α) 和 FIRST(β) 是不相交的集合。如果出现了相交的集合，那么交集就是 ε 集。 3）、如果 \beta \overset{*}{\rightarrow} \epsilon，那么 α 不能推导出任何以 FOLLOW(A) 中某个终结符号开头的串。类似的，对于 α 也一样； 这里我仔细的说一下，如果要推导出以FOLLOW(A)中某个终结符号开头的串，那也就是说 FIRST(α) 和 FOLLOW(A) 要存在交集。对于推导 \beta \overset{*}{\rightarrow} \epsilon 而言，我们从第二点可以知道，那么此时 α 不能推导出 ε。这样看来要 FIRST(α) 和 FOLLOW(A) 存在交集，那是不可能发生的。 👏👏👏构建预测分析表我们构造一个预测分析表 M 。该表是一个二维数组，其中第一列为文法中出现的各个非终结符号；其中第一行为文法中出现的终结符号。 NT：非终结符号t：终结符号 NT\t + * ( ) id $ E . E’ . T . T’ . F . 对于文法G的每个产生式 A\rightarrow\alpha，处理如下： 1、对于FIRST(α)中每个终结符号a，将 A\rightarrow\alpha 加入到 M[A,a] 中。首先查看该产生式的FIRST集合，找到该集合中存在的所有终结符号a、b、c… 如果FIRST(α)不存在ε空串，那么对应非终结符号构造结束，寻找下一个产生式。 2、如果FIRST(α)中存在ε空串： 1）、对于FOLLOW(A)中每个终结符号b，将 A\rightarrow\alpha 加入到 M[A,b] 中； 2）、如果$在FOLLOW(A)中，将 A\rightarrow\alpha 加入到 M[A,$]中； 通俗一点来说就是，先看FIRST集合，如果FIRST集合里面包含了空串，然后再看对应的FOLLOW集合 简单一点来说就是，先查看对应产生式的FIRST集合，如果FIRST集无法推导出空串ε，那么该产生式结束，寻找下一个产生式；如果当前产生式FIRST可以推导出空串，那么求该非终结符号对应的FOLLOW集合和结束标记$。 同样的，我们还是以文法 E \rightarrow TE^{'} \\ E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ T \rightarrow FT^{'}\\ T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ F \rightarrow (E)\ |\ \mathbf{id}举例： 下面使用的到FIRST集合FOLLOW集合的结果，是上一节里面求得的各个非终结符号的结果。具体可以对照上面内容一起看。 1）、对于非终结符号E而言，FIRST(E) = { ( , id }，因此我们将产生式 E \rightarrow TE^{'} 填入到对应的格子里面： NT\t + * ( ) id $ E E \rightarrow TE^{'} E \rightarrow TE^{'} 2）、对于非终结符号E’而言，FIRST(E’) = { +, ε }。由可知FIRST(E’)可以推导出空串ε，因此我们需要获取FOLLOW(E’)，得到 FOLLOW(E’) = { ), $ }。填写对应的格子如下： NT\t + * ( ) id $ E’ E^{'} \rightarrow +TE^{'} E^{'} \rightarrow \epsilon E^{'} \rightarrow \epsilon 3）、对于非终结符号T而言，FIRST(T) = { ( , id }，可知其不能推导出空串。因此我们只需要填写FIRST集合里面对应表格即可： NT\t + * ( ) id $ T F \rightarrow FT^{'} F \rightarrow FT^{'} 4）、对于非终结符号T’而言，它和E‘有点相似之处。即我们从FIRST(T’) = { *, $ } 可知，其可以推导出空串。同样的我们需要查看 FOLLOW(T’) = { +, ), $ } NT\t + * ( ) id $ T’ T^{'} \rightarrow \epsilon T^{'} \rightarrow *FT^{'} T^{'} \rightarrow \epsilon T^{'} \rightarrow \epsilon 5）、对于非终结符号F而言，其FIRST(F) = { ( , id } NT\t + * ( ) id $ F F \rightarrow (E) F \rightarrow \mathbf{id} 将上面的表格汇总之后就得到了我们最终的预测分析表： NT\t + * ( ) id $ E E \rightarrow TE^{'} E \rightarrow TE^{'} E’ E^{'} \rightarrow +TE^{'} E^{'} \rightarrow \epsilon E^{'} \rightarrow \epsilon T F \rightarrow FT^{'} F \rightarrow FT^{'} T’ T^{'} \rightarrow \epsilon T^{'} \rightarrow *FT^{'} T^{'} \rightarrow \epsilon T^{'} \rightarrow \epsilon F F \rightarrow (E) F \rightarrow \mathbf{id} 下面的代码是对LL(1)文法的语法预测分析表的一个伪代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class ll_prediction_analysis_table &#123;private: ContextFreeGrammar grammar; map&lt;int,int&gt; row_map; /// key: symbol id, value: table row index map&lt;int,int&gt; col_map; /// key: symbol id, value: table col index vector &lt; vector&lt;int&gt; &gt; table;private: void extract_symbol() &#123; /// 从文法的各个产生式中分离出终结符和非终结符 int terminal_index = 0; for (vector&lt;Production&gt;::iterator itr = grammar.productions.begin(); itr != grammar.productions.end(); ++itr) &#123; int index = itr - grammar.productions.begin(); vector&lt;Symbol *&gt; bodies = itr-&gt;bodies; for (vector&lt;Symbol *&gt;::iterator body_itr = bodies.begin(); body_itr != bodies.end(); ++body_itr) &#123; if ((*body_itr)-&gt;isTerminal()) &#123; col_map.insert((*body_itr)-&gt;identifier(), terminal_index); ++terminal_index; &#125; &#125; row_map.insert((itr-&gt;header).identifier(),index); &#125; /// 添加结束符 int ended_key = (const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr()))-&gt;identifier(); col_map.insert(ended_key,terminal_index); vector &lt;int&gt; inner(col_map.size(),-1); vector &lt;vector&lt;int&gt; &gt;tb(row_map.size(), inner); table = tb; &#125; void create_table() &#123; /// 这里我默认是对应产生式有对应的LL(1)文法，也就是说表内每一项只包含一个产生式，不会包含多重定义的项。 auto map_itr = row_map.cbegin(); while (map_itr != row_map.cend()) &#123; int table_row_index = map_itr-&gt;second; int key = map_itr-&gt;first; &#125; for (vector&lt;Production&gt;::iterator itr = grammar.productions.begin(); itr != grammar.productions.end(); ++itr) &#123; int index = itr-grammar.productions.begin(); Nonterminal header = itr-&gt;header; int row_index = col_map[header.identifier()]; /// 1.对于FIRST中每个终结符号a，将产生式 A --&gt; α 加入到 table[A][a] 中 vector&lt;Symbol *&gt; first = grammar.FIRST(&amp;header); if (first.size() &lt;= 0) &#123; continue; &#125; bool empty = false; for (vector&lt;Symbol *&gt;::iterator f_itr = first.begin(); f_itr != first.end(); ++f_itr) &#123; if (*f_itr == Symbol::EmptySymbolPtr()) &#123; empty = true; &#125; int f_key = (*f_itr)-&gt;identifier(); int col_index = col_map[f_key]; table[row_index][col_index] = index; &#125; /// 2. 如果FIRST中包含有空串时,FOLLOW(A)中每个终结符号b，将产生式 A --&gt; α 加入到 table[A][b] 中 /// 3. 如果结束符号$在FOLLOW(A)中，将产生式 A --&gt; α 加入到 table[A][$] 中 if (!empty) &#123; return; &#125; vector&lt;Symbol *&gt;follows = grammar.FOLLOW(&amp;header); for (vector&lt;Symbol *&gt;::iterator f_itr = follows.begin(); f_itr != follows.end(); ++f_itr) &#123; int f_key = (*f_itr)-&gt;identifier(); int col_index = col_map[f_key]; table[row_index][col_index] = index; &#125; &#125; &#125;public: ll_prediction_analysis_table(ContextFreeGrammar&amp; grammar) &#123; this-&gt;grammar = grammar; extract_symbol(); create_table(); &#125; Production&amp; objectForPair(pair&lt;Symbol*, Symbol*&gt; row_col);&#125;; 四、非递归的预测分析我们可以显式地维护一个栈结构，来构造出一个非递归的预测分析器。如下图所示： 上图中的语法分析器有一个输入缓冲区，一个包含了文法符号序列的栈，一个上一节我们学习到的语法分析表，以及一个输出流。其中输入缓冲区中包含要进行语法分析的串。 其大致的执行过程如下： 1）、考虑栈顶符号X和当前输入符号a； 2）、如果X是一个非终结符号，该分析器查询预测分析表M中的条目M[X,a]来选择一个产生式； 3）、如果X不是一个非终结符号，那么检查终结符号X和当前的输入符号a是否匹配； 下面是表驱动的预测分析方法伪代码，其中输入为待匹配的字符串，和一个预测分析表；上图中栈第一个元素值为文法的开始符号，栈底存在一个哨兵，用于判断当前栈是否为空： 123456789101112131415161718192021222324252627282930313233bool ll_syntax::syntax() &#123; Symbol *ended = const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr()); char* ip = &amp;input_string[0]; for (Symbol *sym = stack.back(); sym-&gt;identifier() != ended-&gt;identifier(); sym = stack.back()) &#123; if (sym-&gt;identifier() == *ip) &#123; stack.pop_back(); ip++; continue; &#125; if (sym-&gt;isTerminal()) &#123; return false; /// 语法错误 &#125; Terminal ip_sym(*ip); int status = 0; Production prodction = table.objectForPair(make_pair(sym, &amp;ip_sym), &amp;status); if (status != 0) &#123; return false; /// 语法错误 &#125; /// 移除栈顶元素，然后将产生式体加入到栈中 stack.pop_back(); vector&lt;Symbol *&gt; bodies = prodction.bodies; for (vector&lt;Symbol *&gt;::const_reverse_iterator itr = bodies.rbegin; itr != bodies.rend(); ++itr) &#123; stack.push_back(*itr); &#125; &#125; return true;&#125; 这儿我用代码简单地实现了一下，到这儿我们基本上把LL语法分析初步学习完了。 本篇文章中最主要部分还是对产生式求解FIRST集合和FOLLOW集合，这个是务必要掌握的，切记切记！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单了解2-3树、2-3-4树和红黑树]]></title>
      <url>%2F2020%2F01%2F11%2Ftwo_three_four_red_black_tree%2F</url>
      <content type="text"><![CDATA[在这篇文章中，我主要是将数据结构中的2-3树、2-3-4树、红黑树进行了整理。由于本篇字数、图片以及代码较多，可选择自己比较在于的部分阅读，但我建议是从上往下依次阅读。 毕竟大部分人可能比较关心红黑树。但是怎么是从2-3到红黑树的，这个过程是很值得了解的。而在文章的最后，我也大致手撸了一套2-3树相关操作的代码。 一、2-3树 一颗2-3树中的每个结点的度为2，或者3；其中度为2的称为2节点，度为3的称为3节点。 该树或者为空，或者满足以下性质： 每个内部节点可以是2节点，也可以是一个3节点。2节点存放一个元素，3节点存放两个元素 ； 2节点 ：的两个子节点分别是：left_child, middle_child；该节点的存放元素为data_l，该元素的关键字为data_l.key。以left_child为根的子树中所有节点的关键字（data_l.key）都小于该节点的data_l.key；以middle_child为根的子树中所有节点的关键字都大于该节点的data_l.key； 3节点 ：的三个子节点分别是：left_child, middle_child, right_child；该节点存放的两个元素分别为data_l, data_r。它们对应的元素关键字为data_l.key，data_r.key。以left_child为根的子树中所有节点关键字(data_l.key)都小于data_l.key；以middle_child为根的子树所有节点都大于data_l.key，小于data_r.key；以right_child为根的子树所有节点都大于data_r.key； 4、所有的外部节点都位于同一层 （null节点）。 查找1）、首先我们查看是2节点，还是3节点。通过查看data_r是否为INT_MAX（由于0可能是正常存储的元素，因此这里取的是INT_MAX）来确定，如果为INT_MAX则为2节点； 2）、如果是2节点：小于则沿着left_child查找，大于则沿着middle_child查找；相等则查找成功； 3）、如果是3节点：小于data_l则沿着left_child，大于data_l且小于data_r则沿着middle_child，大于data_r则沿着right_child；如果相等则查找成功 插入操作当待查关键字不在2-3树中时，查找过程中将遇到唯一的叶节点（空节点）。如果节点只包含一个元素，那么就可以将新元素插入到该节点中。以构成3节点； 插入操作相对来说要复杂一点，但是理解透彻了也并不复杂。下面来仔细看一下插入过程，这里以插入数字30为例； 1）、首先我们的初始2-3树如下： 2）、现在我们插入数字30，它大于20，因此它应该处于3节点（B）的right_child里面。但是我们看看上面2-3树的性质4：所有的外部节点都位于同一层，所以现在我将30放入节点B这一层： 3）、但这明显不是2-3树，它存在了既不是2节点，也不是三节点的节点，因此我们需要改造它。改造的方法就是将20向上提： 4）、没办法，这又不符合预期。它依然违反了性质4，因此我们还需要改动。继续提20： 到这里我们大致上完成了2-3树中插入30的操作。主要就是先找到最直观的插入地址，然后一步一步的去更新该树，以符合2-3树的性质。 可以简单的理解2-3树的插入操作是从叶子节点向上生长的过程 下面我们来看一个更加复杂的插入例子。为了画图简单起见，2-3节点中的2节点的另一个data_r，以及每个为空的叶子节点就不画出了，因此下图中只有一个数据域的为2节点，有两个数据域的为3节点。下面以插入数字50为例： 这是类似的，就是节点向上移动的过程。我们大致看了一下插入操作，就是不断去满足2-3树的性质的同时去做节点上移的事儿。 下面我们再来看看2-3树的删除操作。 删除操作（旋转和合并）后面的删除都以下面这棵树为基础进行： 非叶节点删除首先，如果要删除的元素不在叶节点中，则可以用一个叶节点中的适当元素与待删除元素进行交换，从而将该删除操作转化为在叶节点上的删除操作。 一般情况下，我们可以用被删除元素的左子树中关键字最大的元素，或者右子树中关键字最小的元素与该元素交换。 总的来说就是把非叶节点的删除转换为叶节点的删除操作，而叶节点的删除操作又分为2节点和3节点删除操作。 3叶节点删除3节点的删除操作相对比较简单，大致的规则如下： 1）、如果要删除3节点的data_l时，当删除之后需要将data_r的关键字移动到data_l处。并且将data_r清零或者置为一个最大值即可； 这是以上面基础2-3树删除3节点中的data_l（10）域之后的结果。 2）、如果要删除3节点的data_r时，直接将其清零或者置为一个最大值即可； 这里是将基础2-3树删除3节点中data_r（70）域之后的结果。 2叶节点删除对于2节点的删除操作相对比较复杂一点，它并不能像3节点那样简单的删除就行了。因为2节点直接删除对应的data_l域的话，将会导致整个节点变为空。因此需要分多种情况来讨论： 旋转待删除节点为2节点，且该节点的相邻兄弟子树有一个是3节点时我们使用旋转的操作。 1）、待删除元素为左儿子，并且其中右边的兄弟子树（只看相邻兄弟子树）为3节点； 其中x为待删除节点的元素。 2）、待删除元素为中儿子，并且其左兄弟或者右兄弟为3节点； 其中x为待删除节点的元素。 3）、待删除元素为右儿子，并且其中左边兄弟子树（只看相邻兄弟子树）为3节点； 旋转操作不删除节点！！！ 合并旋转解决了当被删除元素为2节点，并且其左右两边的兄弟子树存在3节点的情况。那如果被删除节点左右两边都不存在3节点时，需要怎么处理呢？这时候就需要用到合并操作。 合并操作用于2节点删除时，其左右兄弟同样为2节点时！合并操作会删除节点！！！ 和旋转类似，我们同样需要看被删除元素所在节点的位置。由于待删除节点左右兄弟子树存在3节点时都可以使用旋转的操作，所以以下所有的情形中所有待删除元素的相邻子树中都不会不会存在3节点。 下面具体的合并分类： 1）、待删除节点为左儿子； 这里当父节点未3节点时，变换的第二步时如果其右子树为2节点时，我们同样可以将b下降到右子树中，而a保持不变。 2）、待删除节点为中儿子； 过渡态中：c&lt;a&lt;b&lt;d，结果的合并基于该大小关系。 3）、待删除节点为右儿子； 过渡态中：c&lt;a&lt;d&lt;b，结果的合并基于该大小关系。 删除操作总结1）、非叶子节点，先将其转换为叶子节点之后操作； 2）、3节点删除直接删除即可，只不过需要注意剩下元素必须在data_l中； 3）、2节点的删除一定要牢记2-3树的四条性质来进行旋转和合并操作； 4）、节点变化的基础是我们在定义2-3树时，左儿子、中儿子、右儿子，以及节点的左右数据域的大小关系。 很显然，执行一次旋转和执行一次合并操作的时间复杂度为O(1)。如果执行的是（删除中的）旋转操作，那么一次旋转完成后删除就会结束； 在删除过程中，执行的合并操作次数不会超过2-3树的高度。因此对于包含n个节点的2-3树，其删除操作的时间复杂度为O(logn)； 二、2-3-4树2-3-4树是对2-3树的扩展，其中允许4节点（也就是最多有4个儿子）。它满足的性质和2-3树是类似的，主要还是在他们的大小关系上。下图主要是描述的4节点的结构，2节点和3节点从左到右依次为一个元素（data_l）和两个元素（data_l, data_m）已经对应的子节点： 大小关系如下： 1）、left_child.data_l.key &lt; lef_child.data_m.key &lt; left_child.data_r.key &lt; root.data_l.key; 2）、root.data_l.key &lt; left_mid_child.data_l.key &lt; ... &lt; root.data_m.key; 3）、root.data_m.key &lt; right_mid_child.data_l.key &lt; ... &lt; root.data_r.key; 4）、root.data_r.key &lt; right_child.data_l.key &lt; ... &lt; right_child.data_r.key; 2-3-4树也要满足所有的外部节点都在同一层上； 如果一颗高度为h的2-3-4树中只包含2节点，那么该树共有(2^h) - 1个元素（元素个数，不是节点个数）；如果只包含4节点，那么该树共有(4^h) - 1个元素。因此一颗2-3-4树的元素个数为2^h - 1 到 4^h - 1个元素。同样来说包含n个元素的2-3-4树，其高度范围log4(n+1)到log2(n+1)之间。下图是一个2-3-4树的具体例子： 插入操作（拆分4节点、向上移动）插入操作我们可以和2-3树做一样的操作，即先从根节点到叶节点向下执行，然后从叶节点到根节点的向上扫描，并逐级调整以满足2-3-4树的性质。 但是对于2-3-4树存在更加高效的方式： 我们从根节点开始扫描，当扫描到4节点时就对该节点进行拆分操作，主要是看当前4节点父节点来进行适当的拆分操作。依次循环下去，那么到叶子节点时就能保证叶子节点为2节点或者3节点。 对于一个4节点，需要考虑以下三种不同的情况： 1）、4节点是2-3-4树的根节点； 根节点的拆分会使得2-3-4树的高度增加1。并且拆分之后得到的两个节点都是 2节点 ； 2）、4节点的父节点是一个2节点； 上半部分中4节点作为2节点的左子树，下半部分为4节点作为2节点的右子树。拆分之后得到的两个节点同样都是 2节点 ； 3）、4节点的父节点是一个3节点； 拆分之后得到的两个节点同样都是 2节点 ； 到这儿我们就能大致看出规律了： 4节点的data_m向上提，data_l和data_r自成一个2节点； 2-3-4树插入实例以下图为原2-3-4树执行插入操作： 1、首先我们插入元素5：从根节点开始扫描，发现根节点为4节点。因此使用第一点中的拆分过程，将4节点的中data_m向上提，独立成一个2节点。此时会使得树的总体高度增加1。然后依次寻找5所在的位置，发现目标叶子节点为一个3节点，符合插入要求，直接插入即可。 2、插入元素14：从根节点开始扫描，发现包含元素【5，12，15】的节点为4节点，而该节点父节点为2节点。因此我们可以使用上面第二点“4节点为父节点是一个2节点”的拆分方法。拆分完成后继续寻找元素14的插入点，发现节点【15】为2节点直接插入。 比如这里插入一个元素77和这个例子很类似。发现节点【72，80，90】为4节点，把元素80向上提，构成新的节点【70，80，99】。然后把元素77插入到节点【72】的右子节点中即可。 因此2-3-4树的插入操作对于2-3树插入操作的优势在于，只需自顶向下单次扫描就可以完成；而2-3树需向下扫描之后，还有元素向上提的过程。 删除操作（合并4节点、向下移动）插入操作虽然和2-3树类似，但是需要有效率上的改进。如果没有优势的话，那该查找树存在也没有什么意义。 删除任何元素都可以化简为删除某个叶子节点中的元素。 如果 删除元素所在的叶节点是3节点或者4节点 ，直接删除即可。结果分别变成2节点和3节点 ； 我们可以从根节点到叶节点的向下扫描过程中对2-3-4树进行更新，以达到删除元素时，元素所在叶节点为3节点或者4节点。这样我们就可以避免在类似2-3树删除操作（从叶节点到根节点向上）出现的重建步骤。 向下扫描2-3-4树并进行更新时要求：每当查找移向下一层节点时，该节点必须是3节点或者4节点。 为了描述方便，这里假设当前节点为p，而将要移到的下一个节点为q，也就是说q是p的子节点。r节点为q节点的兄弟节点，当q是p的left_child时，r节点为p的left_mid_child；否则q最近的兄弟节点r就是其左边的兄弟节点。如果看起来有点不顺口，直接对应下面图就行了。下面列出5种情况： 1）、p(父节点)是叶子节点 ：此时待删除元素要么在节点p中，要么不存在； 2）、q不是2节点：那就是3节点或者4节点，不需要更新。继续寻找下一个节点； 3）、q是2节点且其兄弟节点r为2节点：将p、q、r合并成一个4节点。这个过程其实就是2-3-4树插入过程的逆过程（也就是插入里面的三种情况）。其中p节点分为2节点、3节点、4节点； 4）、q是2节点且其兄弟节点为3节点： 这里有个错误，下半部分的应该是y上移动. 5）、q是2节点且其兄弟节点为4节点： 第四种和第五种非常类似。 2-3-4树删除实例下面我们来看一个2-3-4树删除元素的实例。在下面的例子中我们删除元素74： 三、红黑树从2-3-4树到红黑树红黑树相对于2-3-4树能够更有效地节省存储空间，因为对于2-3-4树而言，它如果存在2节点或者3节点是存在data_l或者data_m是没有使用而浪费了。在红黑树中，每个节点的儿子指针分为：红色和黑色两种。在本文中： 1）、红色指针：红色节点表示从父节点指向该节点的指针为红色指针。红色指针用虚线表示； 2）、黑色指针：黑色节点表示从父节点指向该节点的指针为黑色指针。黑色指针用实线表示； 红黑树是2-3-4树的二叉树表示，因此我们来看一下2-3-4树到红黑树的转变过程： 2-3-4树种的2节点：把一个2节点p表示为一个红黑树节点q。红黑树该节点左右子节点均为黑色； 123q.data = p.data_l;q-&gt;left_child = p-&gt;left_child;q-&gt;right_child = p-&gt;left_mid_child; 2-3-4树种的3节点：把一个3节点表示为2个红黑树节点，其中一个节点作为另一个节点的子节点。并且子节点为红色； 2-3-4树种的4节点：把一个4节点表示为3个红黑树节点，其中data_m所在节点为父节点，左右子节点用红色表示； 下面是将上面2-3-4树转换成红黑树的例子： 红黑树性质我们从上面一节得出的红黑树，可以知道红黑树具有如下性质： 1）、红黑树是一颗二叉查找树； 2）、根节点为黑色节点； 3）、所有根节点到外部节点的路径上黑色指针个数相同（同样的黑色节点也相同）。这是因为在2-3-4树中所有外部节点都位于同一层，而在该树种指针都是黑色指针； 4）、任何从根节点到外部节点的路径上都不存在两个连续的红色指针； 下面是红黑树大致的结构： 12345678910typedef struct red_black_tree* red_black_ptr;typedef struct red_black_tree &#123; element data; /// 左右儿子 red_black_ptr left_child; red_black_ptr right_child; /// 两个颜色域 color left_color; color right_color;&#125;red_black; 红黑树的插入红黑树的插入可以按照两种方式：自顶向下（Top-To-Down），自底向上（Down-To-Top）。自顶向下只需从根到叶节点一次扫描即可；而自底向上需要从根节点到叶节点扫描之后，还需要继续从叶节点到根节点扫描一次。 👻🍄👻自顶向下的插入通过观察当前节点的两个颜色域是否都为红色。如果都为红色，那么该节点对应2-3-4树中的4节点（详细可以看上面2-3-4树到红黑树的转换过程）。当发现4节点时： 第一步、将该节点的两个颜色域都变为黑色（由红变黑）； 第二步、如果该节点是其父节点的左儿子、或者右儿子，则将其父节点的左颜色域、或者右颜色域变为红色； 第三步、如果此时树中出现两个连续的红色指针时，则需要类似AVL树的LL、LR、RL、RR旋转操作； 由于前面有了2-3-4树的基础知识，我们以2-3-4树的2节点、3节点、4节点，来总结红黑树插入时旋转和变色的规律： 每插入一个元素时，我们自顶向下遍历每一个节点: 1）、如果是2节点、或者3节点，则保持它们性质不发生改变（至于怎么判断红黑树中当前节点是2节点，还是3节点。请看“从2-3-4树到红黑树”一节）； 变色 2）、如果当前节点是4节点时（红黑树中其左右指针必定指向红色节点），则将其左右指针和左右子节点变为黑色。这里是将当前4节点作为父节点而言的； 3）、如果当前节点是4节点时，并且该节点作为其父节点左子节点、或者右子节点，那么将其父节点对应的左指针或者右指针变为红色，并且当前节点也变为红色；这里是将该节点作为其父节点的子结点而言的。 旋转 4）、如果出现连续两个红色指针时，就需要做对应的旋转操作； 红黑树插入实例例一：下面先来看一个最简单的例子，我们一次将1，2，3，4，5，6，7，8 插入到红黑树中： 自顶向下的插入过程，是在从根节点到需要插入的目的节点开始进行遍历，并且在遍历过程中对红黑树进行变色和旋转。 自底向上插入自底向上的插入，首先需要查找关键字在红黑树的插入位置。显然这个插入操作是不成功的查找，且在该 向下查找过程中不需要进行旋转变换，只需要将待插元素作为最后遇到的节点的某个子节点，并用红色指针将其与它父节点连接 。 由于每次以红色指针插入，所以此时所有根节点到外部节点路径上黑色节点的数量相同，但有可能存在两个连续红色指针。 出现两个连续的红色指针时假设连续出现的两个红色指针分别为 和 。 这表示q作为p的子节点，r作为q的子节点： p —&gt; q —&gt; r；因此p、q、r之间存在四种情况： 1）、LL: q作为p的左子节点，r作为q的左子节点； 2）、LR: q作为p的左子节点，r作为q的右子节点； 3）、RL: q作为p的右子节点，r作为q的左子节点； 4）、RR: q作为p的右子节点，r作为q的右子节点； 现在假设s作为q的兄弟（如果s不为空，即存在兄弟节点）， 变色当s节点（q的兄弟节点）为红色节点时需要做变色操作： 节点p变为红色节点；节点q，s变为黑色节点；节点r不变。这样做变色操作可能会导致红色指针冲突沿着树向上传播，所以颜色调整过程需要多次重复。 颜色调整不会影响从根节点到外部节点路径上黑色指针的个数； 旋转当出现连续两个红色指针，并且节点s为黑色节点时，此时需要做旋转操作。 旋转操作不会引起红色指针冲突的传播，因此最多只需要执行一次旋转操作； 红黑树插入实例例二：现在使用自底向上的方式按顺序插入元素10，9，8，7，6，5，4，3： 1）、插入节点颜色为红色； 2）、节点s为红色时，并且q和r为两个连续的红色节点，此时则需要变色； 3）、如果节点s为黑色，或者为空。当q和r为两个连续红色节点时，此时只需要旋转即可； 自顶向下和自底向上的总结1）、对于自顶向下的插入方法，需要执行O(logN)次旋转操作；而自底向上的插入方法只需要执行一次旋转操作； 2）、两种方式都需要执行O(logN)颜色调整操作； 使用自底向上的插入方式就和网上大部分提到的红黑树操作方式一样。但我们还是需要知道自顶向下的操作方式。 红黑树的删除其实讲到这里，红黑树已经没有什么讲的必要了。只需要套用2-3-4树的删除节点策略即可。最主要的是在自顶向下扫描的过程中，明确当前红黑树节点处于对应2-3-4树节点的类型。 扫描过程： 1）、尚未命中待删除元素时，则以二叉树大小关系，去寻找合适的左右子树； 2）、命中待删除元素时，如果元素所处节点为叶子节点。那么直接删除即可； 3）、命中待删除元素时，如果元素所处节点不是叶子节点，此时我们可以像2-3树/2-3-4树的规则继续向下寻找叶子节点。寻找的目标可以是命中节点的左子树中最大子节点，或者右子树中最小子节点； 明确节点类型： 1）、如果当前节点是红色节点，那么该节点一定对应于2-3-4树中的3节点、或者4节点；由于2-3-4树中，3节点和4节点无需变换直接向下继续遍历即可； 2）、如果当前节点是黑色节点，那么再去查看该节点左右子节点是否存在红色节点。如果没有红色节点，那么该节点即对应2-3-4树中的2节点。此时则需要看该节点相邻子树的情况，进行对应2节点到4节点的变换（具体变换过程见2-3-4树的删除一节）。 下面是一个具体的例子，在这个例子中我将要删除元素80： 源代码由于需要写的代码太多了，而且我又比较懒。所以我就写了一下2-3树的增加、删除等相关操作，我将代码全部贴在这里，也可以直接去Github上查看源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;list&gt;#include &lt;stdlib.h&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;/// 这里假设对于element来说，如果该域值不存在，我们使得element的value部分设置为INT_MAXclass element &#123;private: int value;public: element(int val) :value(val) &#123;&#125; element() &#123; value = INT_MAX; &#125; void setValue(int val) &#123;value = val;&#125; int getValue() const &#123; return value; &#125; static inline element invalid() &#123; return element(INT_MAX); &#125;&#125;;bool operator == (const element&amp; lhs,const element&amp; rhs) &#123; return lhs.getValue() == rhs.getValue();&#125;bool operator != (const element&amp; lhs,const element&amp; rhs) &#123; return !(lhs.getValue() == rhs.getValue());&#125;class two_three_tree_node &#123;public: element data_l; element data_r; two_three_tree_node* left_child; two_three_tree_node* middle_child; two_three_tree_node* right_child;public: two_three_tree_node() &#123; data_l = element::invalid(); data_r = element::invalid(); left_child = NULL; middle_child = NULL; right_child = NULL; &#125; virtual ~two_three_tree_node() &#123; data_l = element::invalid(); data_r = element::invalid(); if (left_child != nullptr) &#123; delete left_child; &#125; if (middle_child != nullptr) &#123; delete middle_child; &#125; if (right_child != nullptr) &#123; delete right_child; &#125; &#125;&#125;;class node_strategy &#123;protected: const two_three_tree_node* node; element value;public: node_strategy():node(NULL),value(element::invalid()) &#123; &#125; virtual void setValue(const element&amp; ele) = 0; virtual void setNode(const two_three_tree_node* nd) = 0; virtual two_three_tree_node* next() = 0; virtual ~node_strategy() &#123; &#125;&#125;;class left_child_strategy:public node_strategy &#123; two_three_tree_node* next() &#123; element data_left = node-&gt;data_l; if (value.getValue() &lt; data_left.getValue()) &#123; return node-&gt;left_child; &#125; return nullptr; &#125; void setValue(const element&amp; ele) &#123; value = ele; &#125; void setNode(const two_three_tree_node* nd) &#123; node = nd; &#125;&#125;;class middle_child_strategy :public node_strategy &#123; two_three_tree_node* next() &#123; element data_left = node-&gt;data_l; element data_right = node-&gt;data_r; if (value.getValue() &gt; data_left.getValue() &amp;&amp; value.getValue() &lt; data_right.getValue()) &#123; return node-&gt;middle_child; &#125; return nullptr; &#125; void setValue(const element&amp; ele) &#123; value = ele; &#125; void setNode(const two_three_tree_node* nd) &#123; node = nd; &#125;&#125;;class right_child_strategy :public node_strategy &#123; two_three_tree_node* next() &#123; element data_right = node-&gt;data_r; if (value.getValue() &gt; data_right.getValue()) &#123; return node-&gt;right_child; &#125; return nullptr; &#125; void setValue(const element&amp; ele) &#123; value = ele; &#125; void setNode(const two_three_tree_node* nd) &#123; node = nd; &#125;&#125;;///#######################################################################################################################///#######################################################################################################################/// #### 查找///#######################################################################################################################///#######################################################################################################################class search_strategy &#123; two_three_tree_node* root;public: search_strategy(two_three_tree_node* rt) &#123; root = rt; &#125; two_three_tree_node* search(element&amp; ele) &#123; two_three_tree_node* node = root; node_strategy *left = new left_child_strategy(); node_strategy *middle = new middle_child_strategy(); node_strategy *right = new right_child_strategy(); while (node) &#123; if (node-&gt;data_l == ele) &#123; return node; &#125; if (node-&gt;data_r == ele) &#123; return node; &#125; left-&gt;setNode(node); left-&gt;setValue(ele); if (two_three_tree_node *temp = left-&gt;next()) &#123; node = temp; continue; &#125; middle-&gt;setNode(node); middle-&gt;setValue(ele); if (two_three_tree_node * temp = middle-&gt;next()) &#123; node = temp; continue; &#125; right-&gt;setNode(node); right-&gt;setValue(ele); if (two_three_tree_node * temp = right-&gt;next()) &#123; node = temp; continue; &#125; node = nullptr; &#125; delete left; delete middle; delete right; return nullptr; &#125;&#125;;///#######################################################################################################################///#######################################################################################################################/// #### 插入///#######################################################################################################################///#######################################################################################################################class insert_strategy &#123;private: /// 创建一个栈结构，将从叶节点到根节点路径上左右的节点保存下来 struct find_stack &#123; struct find_stack_node &#123; two_three_tree_node* tree_node; find_stack_node* next; &#125;; void push(const two_three_tree_node* tree_node) &#123; if (!tree_node) &#123; return; &#125; find_stack_node* node = new find_stack_node(); node-&gt;tree_node = const_cast&lt;two_three_tree_node*&gt;(tree_node); node-&gt;next = top; top = node; &#125; two_three_tree_node* pop() &#123; find_stack_node* node = top; top = top-&gt;next; two_three_tree_node* tree_node = node-&gt;tree_node; node-&gt;next = nullptr; node-&gt;tree_node = nullptr; delete node; return tree_node; &#125; find_stack_node* stack_top() &#123; return top; &#125; ~find_stack() &#123; while (top) &#123; pop(); &#125; &#125; private: find_stack_node* top; &#125;;///#######################################################################################################################///#######################################################################################################################///#####寻找节点///#######################################################################################################################///####################################################################################################################### class find_element &#123; private: two_three_tree_node* root; element value; find_stack* stack; public: find_element(const two_three_tree_node* rt, element val) &#123; root = const_cast&lt;two_three_tree_node*&gt;(rt); value = val; stack = new find_stack(); &#125; void set_value(element val) &#123; value = val; &#125; /// 修改版查找：根据根节点和指定元素：如果查找到指定元素，则认为查找成功，返回null；否则返回查找过程中遇到的叶子节点； two_three_tree_node* node() &#123; two_three_tree_node* node = root; node_strategy* left = new left_child_strategy(); node_strategy* middle = new middle_child_strategy(); node_strategy* right = new right_child_strategy(); two_three_tree_node* result = nullptr; while (node) &#123; stack-&gt;push(node); if (node-&gt;data_l == value) &#123; goto release; &#125; if (node-&gt;data_r == value) &#123; goto release; &#125; left-&gt;setNode(node); left-&gt;setValue(value); if (two_three_tree_node * temp = left-&gt;next()) &#123; node = temp; continue; &#125; middle-&gt;setNode(node); middle-&gt;setValue(value); if (two_three_tree_node * temp = middle-&gt;next()) &#123; node = temp; continue; &#125; right-&gt;setNode(node); right-&gt;setValue(value); if (two_three_tree_node * temp = right-&gt;next()) &#123; node = temp; continue; &#125; node = nullptr; &#125; if (stack-&gt;stack_top()) &#123; result = stack-&gt;stack_top()-&gt;tree_node; &#125; release: delete left; delete middle; delete right; return result; &#125; find_stack* get_stack() &#123; return stack; &#125; ~find_element() &#123; root = nullptr; delete stack; stack = nullptr; &#125; &#125;; //// 拼接 class split_element &#123; private: find_stack* stack; element ele; public: split_element(const find_stack* steck,const element&amp; val) &#123; stack = const_cast&lt;find_stack *&gt;(steck); ele = val; &#125; two_three_tree_node* split(bool (*two_node_insert_handle)(two_three_tree_node* node,const two_three_tree_node* insert_node))&#123; find_stack::find_stack_node* top = stack-&gt;stack_top(); two_three_tree_node* be_insert_node = new two_three_tree_node(); be_insert_node-&gt;data_l = ele; int breakpoint = ele.getValue(); while(be_insert_node-&gt;data_l != element::invalid() &amp;&amp; top)&#123; two_three_tree_node* current = top-&gt;tree_node; if (two_node_insert_handle(current, be_insert_node)) &#123; return nullptr; &#125; /// current 存放三个元素里面最小的一个 /// max 存放三个元素里面最大的一个 two_three_tree_node* max_item = new two_three_tree_node(); if (be_insert_node-&gt;data_l.getValue() &lt; current-&gt;data_l.getValue()) &#123; max_item-&gt;data_l = current-&gt;data_r; max_item-&gt;data_r = element::invalid(); max_item-&gt;left_child = current-&gt;middle_child; max_item-&gt;middle_child = current-&gt;right_child; element temp = current-&gt;data_l; current-&gt;data_l = be_insert_node-&gt;data_l; current-&gt;data_r = element::invalid(); current-&gt;left_child = be_insert_node-&gt;left_child; current-&gt;middle_child = be_insert_node-&gt;middle_child; current-&gt;right_child = nullptr; be_insert_node-&gt;data_l = temp; be_insert_node-&gt;data_r = element::invalid(); be_insert_node-&gt;left_child = current; be_insert_node-&gt;middle_child = max_item; top = top-&gt;next; continue; &#125; if (be_insert_node-&gt;data_l.getValue() &gt; current-&gt;data_r.getValue()) &#123; max_item-&gt;data_l = be_insert_node-&gt;data_l; max_item-&gt;data_r = element::invalid(); max_item-&gt;left_child = be_insert_node-&gt;left_child; max_item-&gt;middle_child = be_insert_node-&gt;middle_child; current-&gt;right_child = nullptr; element temp = current-&gt;data_r; current-&gt;data_r = element::invalid(); be_insert_node-&gt;data_l = temp; be_insert_node-&gt;left_child = current; be_insert_node-&gt;middle_child = max_item; be_insert_node-&gt;data_r = element::invalid(); top = top-&gt;next; continue; &#125; if (be_insert_node-&gt;data_l.getValue() &lt; current-&gt;data_r.getValue() &amp;&amp; be_insert_node-&gt;data_l.getValue() &gt; current-&gt;data_l.getValue()) &#123; max_item-&gt;data_l = current-&gt;data_r; max_item-&gt;left_child = be_insert_node-&gt;middle_child; max_item-&gt;middle_child = current-&gt;right_child; max_item-&gt;data_r = element::invalid(); current-&gt;middle_child = be_insert_node-&gt;left_child; current-&gt;data_r = element::invalid(); current-&gt;right_child = nullptr; be_insert_node-&gt;left_child = current; be_insert_node-&gt;middle_child = max_item; be_insert_node-&gt;right_child = nullptr; be_insert_node-&gt;data_r = element::invalid(); top = top-&gt;next; continue; &#125; &#125; return be_insert_node; &#125; &#125;; static bool two_node_insert(two_three_tree_node* node, const two_three_tree_node* insert_node) &#123; if (node-&gt;data_r != element::invalid()) &#123; return false; &#125; if (node-&gt;data_l.getValue() &lt; const_cast&lt;two_three_tree_node*&gt;(insert_node)-&gt;data_l.getValue()) &#123; node-&gt;data_r = insert_node-&gt;data_l; node-&gt;middle_child = insert_node-&gt;left_child; node-&gt;right_child = insert_node-&gt;middle_child; &#125; else &#123; element temp = node-&gt;data_l; node-&gt;data_l = insert_node-&gt;data_l; node-&gt;data_r = temp; node-&gt;right_child = node-&gt;middle_child; node-&gt;left_child = insert_node-&gt;left_child; node-&gt;middle_child = insert_node-&gt;middle_child; &#125; return true; &#125;public: two_three_tree_node* insert(two_three_tree_node* root ,const element &amp;ele) &#123; find_element* fele = new find_element(root,ele); two_three_tree_node* leaf = fele-&gt;node(); if (nullptr == leaf) &#123;/// 待插入元素已存在于树中 delete fele; return root; &#125; split_element* se = new split_element(fele-&gt;get_stack(), ele); two_three_tree_node* root_node = se-&gt;split(two_node_insert); if (root_node == nullptr) &#123;/// 2节点 delete fele; return root; &#125; /// 3节点 delete fele; return root_node; &#125;&#125;;///#######################################################################################################################///#######################################################################################################################/// #### 删除///#######################################################################################################################///#######################################################################################################################class delete_strategy &#123; two_three_tree_node* root; element ele;private: /// 获取兄弟节点; two_three_tree_node* get_bro_node(two_three_tree_node * const node, two_three_tree_node * const parent) &#123; if (node == parent-&gt;left_child) &#123; return parent-&gt;middle_child; &#125; if (node == parent-&gt;middle_child) &#123; if (is_three_node(parent-&gt;right_child)) &#123; return parent-&gt;right_child; &#125; return parent-&gt;left_child; &#125; if (node == parent-&gt;right_child) &#123; return parent-&gt;middle_child; &#125; return nullptr; &#125;protected: static inline bool is_three_node(two_three_tree_node* node) &#123; if (nullptr == node) &#123; return false; &#125; if (node-&gt;data_l != element::invalid() &amp;&amp; node-&gt;data_r != element::invalid()) &#123; return true; &#125; return false; &#125; static bool remove_element(two_three_tree_node* node, element ele) &#123; if (node-&gt;data_r == ele) &#123; node-&gt;data_r = element::invalid(); return true; &#125; if (node-&gt;data_l == ele) &#123; node-&gt;data_l = node-&gt;data_r; node-&gt;data_r = element::invalid(); return true; &#125; return false; &#125; class delete_ttt_node &#123; public: two_three_tree_node* node; element* isptr; delete_ttt_node(const two_three_tree_node* rt, const element* is) &#123; node = const_cast&lt;two_three_tree_node*&gt;(rt); isptr = const_cast&lt;element*&gt;(is); &#125; &#125;; /// 叶节点转移 class leaf_swap &#123; delete_ttt_node* ttt_node; element ele; /// 返回值为目标节点 /// leaf为叶节点 private: two_three_tree_node* leaf_node; two_three_tree_node* leaf_parent_node; public: leaf_swap(const two_three_tree_node* rt, element&amp; el) &#123; ttt_node = new delete_ttt_node(rt, nullptr); ele = el; leaf_node = nullptr; leaf_parent_node = nullptr; &#125; leaf_swap() &#123; ttt_node = new delete_ttt_node(nullptr, nullptr); ele = element::invalid(); leaf_node = nullptr; leaf_parent_node = nullptr; &#125; ~leaf_swap() &#123; delete ttt_node; &#125; two_three_tree_node* get_leaf_node() &#123; return leaf_node; &#125; two_three_tree_node* get_leaf_parent_node() &#123; return leaf_parent_node; &#125; delete_ttt_node* get_swap_info(two_three_tree_node** leaf) &#123; two_three_tree_node* node = ttt_node-&gt;node; delete_ttt_node* des_node = new delete_ttt_node(ttt_node-&gt;node, nullptr); node_strategy* left = new left_child_strategy(); node_strategy* middle = new middle_child_strategy(); node_strategy* right = new right_child_strategy(); /// 命中待删除元素 while (node) &#123; if (node-&gt;data_l == ele) &#123; des_node-&gt;node = node; des_node-&gt;isptr = &amp;(node-&gt;data_l); break; &#125; if (node-&gt;data_r == ele) &#123; des_node-&gt;node = node; des_node-&gt;isptr = &amp;(node-&gt;data_r); break; &#125; left-&gt;setNode(node); left-&gt;setValue(ele); if (two_three_tree_node * temp = left-&gt;next()) &#123; leaf_parent_node = node; node = temp; continue; &#125; middle-&gt;setNode(node); middle-&gt;setValue(ele); if (two_three_tree_node * temp = middle-&gt;next()) &#123; leaf_parent_node = node; node = temp; continue; &#125; right-&gt;setNode(node); right-&gt;setValue(ele); if (two_three_tree_node * temp = right-&gt;next()) &#123; leaf_parent_node = node; node = temp; continue; &#125; node = nullptr; &#125; delete left; delete middle; delete right; /// 寻找叶子节点 /// 左子树的最大子节点；或者右子树的最小子节点； /// 这里我选择左子树的最大子节点； if (des_node == nullptr) &#123; leaf_parent_node = nullptr; return des_node; &#125; *leaf = des_node-&gt;node; for (node = (des_node-&gt;isptr-&gt;getValue() == des_node-&gt;node-&gt;data_r.getValue()) ? des_node-&gt;node-&gt;middle_child : des_node-&gt;node-&gt;left_child; node; node = node-&gt;middle_child) &#123; /// 非叶节点 leaf_parent_node = *leaf; *leaf = node; &#125; return des_node; &#125; bool swap() &#123;/// 仅仅交换两个指针的数据域的值，指针域不做改变 two_three_tree_node* leaf = nullptr; delete_ttt_node* des_node = get_swap_info(&amp;leaf); leaf_node = leaf; if (nullptr == des_node || nullptr == leaf) &#123; return false; &#125; if (des_node-&gt;node == leaf) &#123;/// 叶节点，不做交换 return true; &#125; if (leaf-&gt;data_r != element::invalid()) &#123; element r_temp = leaf-&gt;data_r; leaf-&gt;data_r = *(des_node-&gt;isptr); *(des_node-&gt;isptr) = r_temp; &#125; else &#123; element l_temp = leaf-&gt;data_l; leaf-&gt;data_l = *(des_node-&gt;isptr); *(des_node-&gt;isptr) = l_temp; &#125; delete des_node; return true; &#125; &#125;; class two_node_delete_interface &#123; protected: two_three_tree_node* leaf; two_three_tree_node* bro; two_three_tree_node* parent; two_node_delete_interface(two_three_tree_node* lf, two_three_tree_node* bo, two_three_tree_node* pt) :leaf(lf), bro(bo), parent(pt) &#123;&#125; virtual ~two_node_delete_interface()&#123;&#125; &#125;; /// 旋转 class rotate : public two_node_delete_interface &#123;/// 兄弟节点为3节点时，旋转 private: bool left_leaf_rotate() &#123; leaf-&gt;data_l = parent-&gt;data_l; leaf-&gt;data_r = element::invalid(); parent-&gt;data_l = bro-&gt;data_l; bro-&gt;data_l = bro-&gt;data_r; bro-&gt;data_r = element::invalid(); leaf-&gt;middle_child = bro-&gt;left_child; bro-&gt;left_child = bro-&gt;middle_child; bro-&gt;middle_child = bro-&gt;right_child; return true; &#125; bool right_leaf_rorate() &#123; leaf-&gt;data_l = parent-&gt;data_l; parent-&gt;data_l = bro-&gt;data_r; leaf-&gt;left_child = bro-&gt;right_child; return true; &#125; bool middle_leaf_rorate() &#123; if (bro == parent-&gt;right_child) &#123; leaf-&gt;data_l = parent-&gt;data_r; leaf-&gt;data_r = element::invalid(); parent-&gt;data_r = bro-&gt;data_l; bro-&gt;data_l = bro-&gt;data_r; bro-&gt;data_r = element::invalid(); leaf-&gt;middle_child = bro-&gt;left_child; bro-&gt;left_child = bro-&gt;middle_child; bro-&gt;middle_child = bro-&gt;right_child; return true; &#125; leaf-&gt;data_l = parent-&gt;data_l; parent-&gt;data_l = bro-&gt;data_r; leaf-&gt;left_child = bro-&gt;right_child; return true; &#125; public: rotate(two_three_tree_node* lf, two_three_tree_node* bo, two_three_tree_node* pt):two_node_delete_interface(lf, bo, pt) &#123;&#125; bool execute() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; if (leaf == parent-&gt;left_child) &#123; return left_leaf_rotate(); &#125; else if (leaf == parent-&gt;middle_child) &#123; return middle_leaf_rorate(); &#125; else &#123; return right_leaf_rorate(); &#125; &#125; &#125;; /// 合并 class combine : public two_node_delete_interface &#123; protected: bool left_leaf_combine() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; bool parent_is_three_node = is_three_node(parent); if (false == parent_is_three_node) &#123; parent-&gt;data_r = bro-&gt;data_l; parent-&gt;left_child = leaf-&gt;left_child; parent-&gt;middle_child = bro-&gt;left_child; parent-&gt;right_child = bro-&gt;right_child; delete bro; delete leaf; bro = nullptr; leaf = nullptr; return true; &#125; bro-&gt;data_r = bro-&gt;data_l; bro-&gt;data_l = parent-&gt;data_l; parent-&gt;data_l = parent-&gt;data_r; parent-&gt;data_r = element::invalid(); parent-&gt;left_child = parent-&gt;middle_child; parent-&gt;middle_child = parent-&gt;right_child; parent-&gt;right_child = nullptr; bro-&gt;right_child = bro-&gt;middle_child; bro-&gt;middle_child = bro-&gt;left_child; bro-&gt;left_child = leaf-&gt;left_child; delete leaf; leaf = nullptr; return true; &#125; bool middle_leaf_combine() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; bool parent_is_three_node = is_three_node(parent); if (false == parent_is_three_node) &#123; parent-&gt;data_r = parent-&gt;data_l; parent-&gt;data_l = bro-&gt;data_l; parent-&gt;left_child = nullptr; parent-&gt;middle_child = nullptr; delete leaf; delete bro; leaf = nullptr; bro = nullptr; return true; &#125; bro-&gt;data_r = parent-&gt;data_l; parent-&gt;data_l = parent-&gt;data_r; parent-&gt;data_r = element::invalid(); parent-&gt;middle_child = parent-&gt;right_child; parent-&gt;right_child = nullptr; bro-&gt;middle_child = leaf-&gt;left_child; bro-&gt;right_child = leaf-&gt;middle_child; delete leaf; leaf = nullptr; return true; &#125; bool right_leaf_combine() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; bro-&gt;data_r = parent-&gt;data_r; parent-&gt;data_r = element::invalid(); parent-&gt;right_child = nullptr; bro-&gt;middle_child = leaf-&gt;left_child; bro-&gt;right_child = leaf-&gt;middle_child; delete leaf; leaf = nullptr; return true; &#125; public: combine(two_three_tree_node* lf, two_three_tree_node* bo, two_three_tree_node* pt) :two_node_delete_interface(lf, bo, pt) &#123;&#125; bool execute() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; if (leaf == parent-&gt;left_child) &#123; return left_leaf_combine(); &#125; else if(leaf == parent-&gt;middle_child) &#123; return middle_leaf_combine(); &#125; else &#123; return right_leaf_combine(); &#125; &#125; &#125;; class two_node_delete : public two_node_delete_interface &#123; public: two_node_delete(two_three_tree_node* lf, two_three_tree_node* bo, two_three_tree_node* pt):two_node_delete_interface(lf, bo, pt) &#123;&#125; bool execute() &#123; if (nullptr == leaf || nullptr == parent || nullptr == bro) &#123; return false; &#125; /// 查看兄弟节点为2节点，还是3节点； bool three_node = is_three_node(bro); if (true == three_node) /// 兄弟节点为3节点，旋转 &#123; rotate* rtt = new rotate(leaf, bro, parent); return rtt-&gt;execute(); &#125; else /// 兄弟节点为2节点，合并 &#123; combine* cbn = new combine(leaf, bro, parent); return cbn-&gt;execute(); &#125; return false; &#125; &#125;;public: delete_strategy(const two_three_tree_node*rt, element&amp; el) &#123; root = const_cast&lt;two_three_tree_node*&gt;(rt); ele = el; &#125; bool execute() &#123; leaf_swap* ls = new leaf_swap(root, ele); bool result = ls-&gt;swap(); if (false == result) &#123; return false; &#125; two_three_tree_node* leaf = ls-&gt;get_leaf_node(); if (nullptr == leaf) &#123; return false; &#125; two_three_tree_node* leaf_parent = ls-&gt;get_leaf_parent_node(); /// 3节点 if (is_three_node(leaf)) &#123; remove_element(leaf, ele); return true; &#125; /// 2节点 two_three_tree_node* bro = get_bro_node(leaf, leaf_parent); if (nullptr == bro) &#123; return false; &#125; two_node_delete* tnd = new two_node_delete(leaf, bro, leaf_parent); tnd-&gt;execute(); return result; &#125;&#125;;int main()&#123; vector&lt;int&gt; randoms; /// 插入 //cout &lt;&lt; &quot;input root node value: &quot; &lt;&lt; endl; int rootvalue = 50; //cin &gt;&gt; rootvalue; two_three_tree_node* root = new two_three_tree_node(); root-&gt;data_l = element(rootvalue); /* 自行定制输入数字 int inputvalue = 0; while (cout &lt;&lt; &quot;input node (-1 exit): &quot;, cin &gt;&gt; inputvalue,inputvalue != -1) &#123; randoms.push_back(inputvalue); &#125; */ randoms = &#123; 33 ,85 ,68 ,80 ,62 ,15 ,97 ,10 &#125;; insert_strategy* ins = new insert_strategy(); for (vector&lt;int&gt;::iterator itr = randoms.begin(); itr != randoms.end(); itr++) &#123; root = ins-&gt;insert(root, element(*itr)); &#125; /// 查找 search_strategy* search = new search_strategy(root); element search_item(12); bool search_result = search-&gt;search(search_item); /// 删除 int val; while (cout&lt;&lt;&quot;input delete item: &quot;&lt;&lt;endl,cin&gt;&gt;val,val!=-1) &#123; element be_deleted(val); delete_strategy* delete_s = new delete_strategy(root, be_deleted); delete_s-&gt;execute(); &#125; return 0;&#125; 文章内容较长，到这里基本上算是把2-3树、2-3-4树、以及红黑树都捋了一遍。如果存在错误，麻烦帮忙指出（可以微博联系我）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语法分析——文法的基础概念]]></title>
      <url>%2F2019%2F10%2F28%2FSyntaxParser_context_free_grammar%2F</url>
      <content type="text"><![CDATA[前言在语法分析一章中会出现很多的专业术语，我会在这一节将语法分析涉及到的术语都大致捋一遍。这些专业术语是学习语法分析的必备技能，务必记住并理解，下面我们进入正题。 介绍语法分析通常用于编译器中。在我们的编译器模型中，语法分析器从词法分析器获得一个词法单元组成的串，并验证这个串可以由源语言的文法（比如上下文无关文法，在后面会详细解释）生成。 处理文法的语法分析器大体上可以分分为三种类型：通用的、自顶向下的和自底向上的。而编译器中常用的的方法分为自顶向下和自底向上。顾名思义： 1）、自顶向下的方法从语法分析树的根节点开始向底部构造语法分析树； 2）、自底向上则从叶子结点开始，逐渐向根节点方向构造。 这两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号。 最高效的自顶向下方法和自底向上方法只能处理某些文法子类，但其中的子类，特别是 LL、LR 它们的表达能力已经足以描述现代程序设计语言大部分的语法构造了。 手工实现的语法分析通常使用LL文法。处理较大的LR文法类的语法分析器通常是使用自动化工具构造得到。 这里的第一个L表示从左向右扫描，第二个的L和R分别表示最左推导和最右推导。有关于推导的概念下面就会展开来说，在前面我们提到了文法，所以现在还是先看看上下文无关文法。 一、上下文无关文法（Context-Free-Grammar）文法自然地描述了大多数程序设计语言构造的层次化语法结构，比如if-else之类的。一个上下文无关文法由四个元素组成： 终结符号：也称为词法单元。词法单元由两个部分组成：名字和属性值。我们常常把这些词法单元名字称为终结符号。因此我们在语法分析中，通常将词法单元和终结符当做一个意思； 非终结符号：也称为语法变量，每个非终结符号表示一个终结符号串的集合； 产生式：包括产生式头、一个箭头，和一个产生式体； 开始符号：指定一个非终结符号为开始符号； 如下图的上下文无关文法： 对此，我们需要一些约定来表示不同的符号，以便后续行文方便： 终结符号： Ⅰ）、小写字母，a、b、c等等； Ⅱ）、运算符号，比如 + 。 - ， * ，/ 之类的； Ⅲ）、标点符号，比如括号、逗号等等； Ⅳ）、数字； Ⅴ）、黑体字符串，比如 id，if。每个这样的字符串表示一个终结符号； 非终结符： Ⅰ）、大写字母，A、B、C等等； Ⅱ）、小写，斜体的字符串。比如 expr ， stamt 等等； 产生式体： 使用小写的希腊字母，比如α、β、γ表示文法符号串。比如 A -&gt; α，其中A为产生式头部，α为产生式体。 可选体： 具有相同头部的产生式 A -&gt; α1，A -&gt; α2，… ,A -&gt; αk，可以简写为 A -&gt; α1 | α2 | … | αk。在这里我们把α1，α2，αk称作A的可选体。这个可选体概念不太重要，只需要记住相同产生式头部的简写形式即可。 因此，运用前面的约定，我们可以看出这里一共有三个产生式；其中E、T、F为非终结符；+、*、(、)、id为终结符；其中非终结符E为开始符号。 1、推导——最左推导、最右推导从开始符号出发，每个重写步骤把一个非终结符替换为它的某个产生式的体。比如下面关于非终结符E的文法： 产生式 E --&gt; -E 表明，讲一个E替换为 -E 的过程写作： 读作 “E推导出-E” 。同样的我们可以按照任意顺序对单个E不断地应用各个产生式，得到一个替换序列，比如： 句型：是指推导过程中出现的各种表达式，其中可以包含终结符号，也可以包含非终结符号，当然也有可能是空串； 句子：是不包含非终结符的句型； 一个终结符号串存在于文法G的的语言L(G)中，当且仅当该符号串是文法G的一个句子。可以由文法生成的语言，称为上下文无关语言。 如果两个文法生成相同语言，那么这两个文法是等价的。 比如串 -(id+id) 是文法 的一个句子，这是因为存在推导过程： 串E、-E、… 、-(id+id) 都是这个文法的句型。在上诉的推导过程中，每一个推导步骤上都需要做两个选择，我们要选择替换掉哪个非终结符号。下面是另外一种推导： 这一个推导和上一个推导稍有不同，我们推导的第四步，选择替换掉的是右边的非终结符。基于此我们的推导有两种推导形式： 最左推导：总是选择每个句型最左边的非终结符号进行替换。如果α =&gt; β 是一个推导步骤，且被替换的是α中的最左非终结符号。我们用 α =&gt;lm β （这里lm应该是在推导符号=&gt;的下方，由于不太好书写，因此这里用放在符号右边的形式）； 最右推导：总是选择每个句型最右边的非终结符号进行替换。此时我们写作 α =&gt;rm β（同上）； 使用最左推导得到的句型称为最左句型。最右推导也被称为 规范推导。 2、语法分析树和推导语法分析树是推导的图形表示，它过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部结点表示一个产生式的应用。该内部结点的标号是产生式头中的非终结符号。 这里可以再对语法分析树和词法分析树进行一次对比。上一章词法分析中使用正则表达式构造DFA时提及抽象语法树中每个内部结点为正则表达式中的一个运算符，该内部结点子树的左右子节点分别表示该运算符的运算分量。 比如 -(id+id) 的语法分析树为： 该语法分析树对应的推导过程是上面提到的两个推导： 一颗语法分析树的叶子结点既可以是非终结符号，也可以是终结符号。从左到右排列这些符号就可以得到一个句型，它成为这颗树的 结果。在这里我们从左到右读取每一个叶子结点并排列起来，得到的结果是：- ( id + id ) 。 二义性文法 ，如果一个文法可以为某个句子生成多颗语法分析树，那么它就是二义性的。换句话说，二义性文法就是对同一个句子有多个最左推导或者最右推导的文法。 到这儿，我们可以先看一个例子。 例一对于文法 S \rightarrow\ a\ S\ b\ S\ |\ b\ S\ a\ S\ |\ ε，有一串aabbab。尝试写出最左推导和最右推导出该的语法分析树。 最左推导语法分析树： 最右推导语法分析树： 从语法分析的结构，我们不难看出来该文法是二义性文法。 3、上下文无关文法和正则表达式文法是比正则表达式表达能力更强的表示方法。即每个可以使用正则表达式描述的构造都可以使用文法来描述，但反之则不成立。我们可以根据正则表达式构造出对应的文法，下面则是从正则表达式构造对应文法的大致步骤。如下： 1）、对于NFA的每个状态i，创建一个非终结符Ai； 2）、如果状态i有一个在输入a上到达状态j的转换，则加入产生式 A_{i} \rightarrow a A_{j} 如果状态i在输入 ε 上到达状态j，则加入产生式 A_{i} \rightarrow A_{j}； 3）、如果i是一个接受状态，则加入产生式 A_{i} \rightarrow ε； 4）、如果i是自动机的开始状态，令 Ai为所得文法的开始符号； 比如正则表达式 $(a|b)^{*}abb$ ，它对应的DFA为： 从上面步骤我们可以得到一共有4个状态，因此对于对应文法则有4个非终结符，分别为 A_{0},A_{1},A_{2},A_{3} 。根据上图的转换我们得到文法为： 二、设计文法如果前面看到的，任何能够使用正则表达式描述的东西都可以使用文法来描述。因此在这儿来列举4点关于正则表达式和文法的异同： 1）、将一个语言的语法结构分为词法和非词法两部分可以很方便地将编译器前端模块化，将前端分解为大小合适的组件； 2）、一个语言的词法规则通常很简单，我们不需要使用像文法这样功能强大的表示方法来描述这些规则； 3）、和文法相比，正则表达式通常更加简洁，并且更容易理解； 4）、根据正则表达式自动构造得到的词法分析器效率要高于文法得到的分析器； 根据上诉4点来说明，既然正则表达式都可以使用文法来描述，而在词法分析中我们依然选择了正则表达式来描述词法单元； 正则表达式更适合描述标识符、常量、关键字、空白这样的语言构造的结构；文法更适合描述嵌套结构，比如if-else之类的； 1、左递归左递归是指 产生式体的最左边符号和产生式头部的非终结符号相同 。对于产生式 产生式的头部是E，同时E也是产生式体的最左边的非终结符号，因此该推导将会被将被递归调用。 同样的，右递归也就是指的产生式头部的非终结符号和产生式体最右边的终结符相同的情况。 该文法无法用于自顶向下的语法分析中，这是因为自顶向下的语法分析是基于LL文法的。而对于LL文法来说，第一个L指的是从左到右扫描语法分析树的一层的每个结点，遇到非终结符则应用对应非终结符的产生式。第二个L指的是最左推导。前面我们已经知道了最左推导，即每一次替换掉产生式最左边的非终结符，因此这也就和左递归的定义吻合了。关于更详细的自顶向下的语法分析将在后面进行详细讲解。 既然存在左递归，那么消除左递归肯定是有必要的。 消除立即左递归：比如存在立即左递归的产生式： 其中 $\beta _{i}$ 都不以A开头。因此我们可以用下面的技术来消除立即左递归： 需要特别注意的是：第二个产生式到空串的产生式 。非终结符号A生成的串和替换之前生成的串一样，但不再是左递归的。这个过程消除了所有$A$和$A_{1}$产生式相关联的左递归。 比如我们对文法 应用消除立即左递归的技术上面文法的左递归，得到的结果为： 消除一般左递归但并不是所有的文法都是立即左递归的，有可能是经过多次推导之后才发现递归的情形。比如下面的文法就不是立即左递归： 对于推导 可以看出非终结符号S是左递归的，但它并不是立即左递归。那么对于这种情况的左递归如何消除呢？ 1）、首先将文法的所有非终结符，从开始符号按出现顺序，依次对它们进行编号为A1, A2, A3, …,An； 2）、从A1开始依次读取每一个非终结符到An，我们称作Ai； 同时又从A1开始读取非终结符号到Ai-1，我们称作Aj 。如果存在形如A_{i} \rightarrow A_{j}\gamma 那我们就将其替换为产生式组： A_{i} \rightarrow \sigma _{1} \gamma\ |\ \sigma _{2} \gamma\ |\ ...\ |\ \sigma _{k} \gamma \\ A_{j} \rightarrow \sigma _{1} \ |\ \sigma _{2} \ |\ ...\ |\ \sigma _{k} \\这样我们就可以尽最大的可能构造立即左递归了。 3）、如果此时存在立即左递归，则使用上面提到的消除立即左递归的方式来消除； 下面我用C++写了一个简单地消除左递归的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct GrammerProduction &#123; string header; vector&lt;string&gt; bodies ; GrammerProduction() &#123;&#125; //GrammerProduction(const GrammerProduction&amp; lhs) &#123;&#125; //GrammerProduction&amp; operator=(const GrammerProduction&amp; lhs) &#123;&#125; GrammerProduction(string hdr)&#123; header = hdr; &#125; bool isEmpty() &#123; return bodies.empty(); &#125; void add_body(string bdy) &#123; bodies.push_back(bdy); &#125; private: string recursive_nonterminal; /// 发生立即左递归时，需要引入的非终结符 public: void set_recursive_nonterminal(string nt) &#123; recursive_nonterminal = nt; &#125; void replace_body(GrammerProduction* prd) &#123; if (prd==nullptr) &#123; return; &#125; vector&lt;string&gt; new_bodies; for (vector&lt;string&gt;::iterator itr_body = bodies.begin(); itr_body != bodies.end(); itr_body++) &#123; /// 遍历当前所有的产生式 if (itr_body-&gt;empty()) &#123; continue; &#125; string char_body(1,(*itr_body)[0]); string prd_header = prd-&gt;header; if (char_body != prd_header) &#123; new_bodies.push_back(*itr_body); continue; &#125; /// 如果当前产生式最左边是非终结符，并且该非终结符和Aj相等。即Ai -&gt; Aj γ for (vector&lt;string&gt;::iterator pitr_body = prd-&gt;bodies.begin(); pitr_body != prd-&gt;bodies.end(); ++pitr_body) &#123; string tmp_body = *itr_body; tmp_body = tmp_body.replace(0,1,*pitr_body); new_bodies.push_back(tmp_body); &#125; &#125; bodies = new_bodies; &#125; GrammerProduction* remove_immediately_left_recursive() &#123; vector&lt;string&gt; new_bodies; GrammerProduction* new_production = new GrammerProduction(recursive_nonterminal); if (!new_production) &#123; return nullptr; &#125; for (vector&lt;string&gt;::iterator itr_body = bodies.begin(); itr_body != bodies.end(); ++itr_body) &#123; /// 遍历当前所有的产生式 string tmp_body = *itr_body; string first_char_body(1,(*itr_body)[0]); if (first_char_body == header) &#123; /// 立即左递归 tmp_body = tmp_body.erase(0,1); tmp_body = tmp_body+recursive_nonterminal; new_production-&gt;add_body(tmp_body); &#125;else&#123; tmp_body = tmp_body+recursive_nonterminal; new_bodies.push_back(tmp_body); &#125; &#125; if (new_production-&gt;isEmpty()) &#123; return nullptr; &#125; new_production-&gt;add_body(&quot;#&quot;); bodies = new_bodies; return new_production; &#125;&#125;;struct Grammer &#123; vector&lt;GrammerProduction*&gt; productions; Grammer() = default; void printProductions()&#123; cout&lt;&lt;&quot;-------------------------------------&quot;&lt;&lt;endl; for (vector&lt;GrammerProduction*&gt;::iterator itr = productions.begin(); itr != productions.end(); ++itr) &#123; /// 外层循环从第一个开始符号开始 姑且叫作Ai GrammerProduction* p = *itr; /// 获取Ai所有的产生式体 cout&lt;&lt;p-&gt;header&lt;&lt;endl; for (vector&lt;string&gt;::iterator body_itr = p-&gt;bodies.begin(); body_itr != p-&gt;bodies.end(); ++body_itr) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;*body_itr&lt;&lt;endl; &#125; cout&lt;&lt;&quot;-------------------------------------&quot;&lt;&lt;endl; &#125; &#125; void add_prodction(GrammerProduction* pro) &#123; if (pro==nullptr) return; this-&gt;productions.push_back(pro); &#125; void remove_left_recursive() &#123; vector&lt;GrammerProduction*&gt; new_productions; for (vector&lt;GrammerProduction*&gt;::iterator itr = productions.begin(); itr != productions.end(); ++itr) &#123; /// 外层循环从第一个开始符号开始 姑且叫作Ai GrammerProduction* p = *itr; /// 获取Ai所有的产生式体 for (vector&lt;GrammerProduction*&gt;::iterator itr_j = productions.begin(); itr_j != itr; ++itr_j) &#123; /// 内层循环获取当前非终结符之前的其他非终结符，姑且叫作Aj GrammerProduction* jp = *itr_j; /// 获取Aj所有的产生式体 p-&gt;replace_body(jp); &#125; GrammerProduction *ptr = p-&gt;remove_immediately_left_recursive(); /// 消除可能存在的立即左递归 if (ptr==nullptr) continue; new_productions.push_back(ptr); &#125; if (new_productions.size() &lt;= 0) &#123; return; &#125; productions.insert(productions.end(),new_productions.begin(),new_productions.end()); &#125;&#125;; 比如我们有带左递归的产生式集合： S \rightarrow Aa\ |\ b\\ A \rightarrow Ac\ |\ Sd\ |\ ϵ现在我们可以使用上诉的C++代码来帮我们消除左递归： 123456789101112131415161718192021222324int main() &#123; GrammerProduction *s_productions = new GrammerProduction(&quot;S&quot;); /// S -&gt; Aa | b s_productions-&gt;set_recursive_nonterminal(&quot;T&quot;); s_productions-&gt;add_body(&quot;Aa&quot;); s_productions-&gt;add_body(&quot;b&quot;); GrammerProduction *a_productions = new GrammerProduction(&quot;A&quot;); /// A -&gt; Ac | Sd | ε a_productions-&gt;set_recursive_nonterminal(&quot;B&quot;); a_productions-&gt;add_body(&quot;Ac&quot;); a_productions-&gt;add_body(&quot;Sd&quot;); a_productions-&gt;add_body(&quot;#&quot;); Grammer grammer; grammer.add_prodction(s_productions); grammer.add_prodction(a_productions); cout&lt;&lt;&quot;带有左递归的产生式：&quot;&lt;&lt;endl; grammer.printProductions(); grammer.remove_left_recursive(); cout&lt;&lt;&quot;消除左递归之后的产生式：&quot;&lt;&lt;endl; grammer.printProductions(); cout&lt;&lt;&quot;Done&quot;&lt;&lt;endl; return 0;&#125; 最后的输出结果如下： 123456789101112131415161718192021222324252627带有左递归的产生式：-------------------------------------S Aa b-------------------------------------A Ac Sd #-------------------------------------消除左递归之后的产生式：-------------------------------------S Aa b-------------------------------------A bdB #B-------------------------------------B cB adB #-------------------------------------Done 解释一下，这里的非终结符号B是A的产生式出现左递归之后，引入的非终结符。 2、提取左公因子提取左公因子可以适用于预测分析技术或自顶向下分析技术的文法。当我们不清楚应该在两个产生中如何选择的时候，我们可以通过改写产生式来推后这个决定，当我们有足够的信息时再做出正确地决定。 比如有产生式 A \rightarrow \alpha \beta_{1}\ |\ \alpha \beta_{2}，是A的两个产生式，并且产生式体开头都是从 α 推导得到的一个非空串。那么这时候我们就不清楚是产生式 A \rightarrow \alpha \beta_{1} 还是以产生式 A \rightarrow \alpha \beta_{2} 进行展开。 然后我们可以将A展开为 \alpha A^{'}，从而延迟要做出决定的时刻，原来的产生式就变为了： A \rightarrow \alpha A^{'}\\ A^{'} \rightarrow \beta_{1}\ |\ \beta_{2}总结一下上面提到的内容：对于每个非终结符号A，找出他的两个或多个选项之间的最长公共前缀 α。如果 α 不为空，即存在一个非平凡的公共前缀，那么将所有A的产生式 A \rightarrow \alpha\beta_{1}\ |\ \alpha\beta_{2}\ |\ ...\ |\ \alpha\beta_{n}\ |\ \gamma替换为 A \rightarrow \alpha A^{'}\ |\ \gamma\\ A^{'} \rightarrow \beta_{1}\ |\ \beta_{2}\ |\ ...\ |\ \beta_{n}其中 γ 表示所有不以 α 开头的产生式； A^{'} 是一个新的非终结符号。不断地应用这个转换，直到每个非终结符号的任意两个产生式体都没有公共前缀为止。 3、非上下文无关语言的构造在常见的程序设计语言中，存在少量无法文法描述的语法构造。在C或者Java的文法不区分由不同字符串组成的标识符。所有的标识符在文法中都被表示为像 id 这样的词法单元。在这些语言的编译器中，标识符是否先声明后使用是在语义分析阶段检查的 。 三、总结在本篇文章中，介绍了一大堆的概念。比如上下文无关文法里面的产生式、终结符、非终结符，还有开始符号等等；然后我们接触到了推导的概念，推导又分为最左推导和最右推导。我们根据这两种推导，我们可以构造出对应语法分析树；语法分析树的所有叶子结点从左到右拼起来之后，得到的就是对应产生式文法的句子。而中间过程中出现的则成为句型； 而且，我们也了解到如何通过正则表达式来构造对应的上下文无关文法。大致的过程是根据正则表达式，我们可以根据词法分析一章的知识来构造一个NFA（根据连接、并、闭包运算对应的状态转换图）。我们根据NFA的状态数对应非终结符号，具体转换规则都已经详细列在了上面； 在构造文法的过程中，我们遇到左递归的情况。因此我们需要知道如何去消除立即左递归，和左递归。详细的消除方法在上面用C++语法已列出；最后我们还了解了提取左公因子的方法，当我们不清楚应该如何选择产生式，推迟这个时机，待我们有足够信息做出正确选择之前。 下一篇文章，我们将会去看看自顶向下的语法分析技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[词法分析——正则表达式直接转换为DFA]]></title>
      <url>%2F2019%2F10%2F28%2Fcompiler_regular2dfa%2F</url>
      <content type="text"><![CDATA[在上篇文章中，我们至少学会了将正则表达式构造成对应的NFA和DFA。但是用上篇文章中从正则表达式转换为对应DFA的方式效率低下，即我们要先将正则表达式转换为NFA，然后使用子集构造法将NFA转换为对应DFA。 在本篇文章中，我们将首先学习如何将正则表达式直接转换为DFA，并最小化DFA的状态数目。然后看看DFA模拟中时间和空间的权衡问题。 在正式进入正则表达式转换为DFA之前我们需要一些基本概念，没有这些基本概念可能不太好理解后面提到的内容。 一、需要的基本概念重要状态NFA的重要状态直接对应于正则表达式中存放字母表中符号的位置，而 重要状态是指NFA的某一状态有一个标号为非空的离开转换 。比如我们在上一节中将正则表达式转换为对应NFA时引入了新状态，它们的离开转换都是空转换，因此它们并不是重要状态。 每个重要状态对应于正则表达式中某个运算分量 。 因此我们在比较两个NFA状态集合时，判断它们是否一致的依据如下：1）、具有相同的重要状态；2）、要么都包含接受状态，要么都不包含接受状态； 抽象语法树注意这里的抽象语法树和上一节提到的语法分析树有一点不同，关于语法分析树可以回去看上一篇提到的语法分析树定义。但抽象语法树是必须要完全理解的。 抽象语法树中，每个内部结点代表一个运算符，该运算符结点的子结点代表这个运算符的运算分量 !!! 在抽象语法树中，内部结点代表的是程序的构造；而在语法分析树中，内部结点代表的是非终结符。有时候我们将语法分析树称为具体语法树；而抽象语法树简称为语法树。这是因为在文法的很多非终结符都代表程序的具体构造，还有各种辅助符号。而这些在抽象语法树中都是不需要的。 而前面提到的重要状态就是抽象语法树中运算符的运算分量。下面是正则表达式 (a|b)*abb对应的抽象语法树： 1）、结束标记符#：前面我们提到了重要状态，但（NFA或者DFA）接受状态没有一个标号为非空的离开转换，因此接受状态为非重要状态。基于此，我们可以给正则表达式的右边连接一个结束标记符 # ，使得正则表达式的接受状态成为重要状态。那么我们也就不用特殊处理接受状态了。 2）、叶子节点位置：上面抽象语法树叶子结点下方都有一个有序的整数，我们称这个整数为对应叶子的结点的位置。非空的叶子结点才会赋予相应的整数，也就是说为空串的叶子结点我们不需要对其增加位置。 二、nullable、firstpos、lastpos和followpos函数我们要从一个正则表达式直接构造出DFA，除了前面我们已经构造了的抽象语法树之外，我们还需要计算nullable、firstpos、lastpos和followpos函数。 1）、bool nullable(n)：其中n的取值为抽象语法树中任意结点（可以是叶子结点，也可以是是内部结点。即运算符和运算分量），其返回值的逻辑是当此结点的子表达式中包含有空串ε时返回true，否则为false； 2）、nodes firstpos(n)：子表达式的语言中某个串的第一个符号，该语言是以n为根的子表达式； 3）、nodes lastpos(n)：子表达式的语言中某个串的最后一个符号，同样的该语言也是以n为根的子表达式； 4）、nodes followpos(n)：这相对要复杂一点。比如在抽象语法树中存在两个结点分别为n和m，存在某个串s = a1…aiai+1…ap，即以该正则表达式为模式的串。要满足followpos(n)==m，那么则需要ai和位置n匹配，aI+1和位置m匹配。比如当前有一个符号串aabb，想要构造该串对应于上图抽象语法树中各个节点顺序为1、3、4、5，因此我们就说follow(3)=4。通俗一点说就是要看抽象语法树指定结点的followpos，需要先找到对应结点在某个符号串中的位置，然后看该符号后一位符号即可。 上面的nodes表示的结点集合。前面说的结点均指的是抽象语法树中的重要位置。 更详细点，当我们计算上面抽象语法树位置1的followpos，即followpos(1)。那么我们通过抽象语法树来看，位置1之后经过并运算和闭包运算可以得到的子串有： 123aa;/// 第一个a来自于位置1，第二个a来自于位置1。闭包运算循环了两次；ab;/// a来自于位置1，b来自于位置2。闭包运算循环了2次；aa;///第一个a来自于位置1，第二个a来自于位置3。闭包运算循环了1次； 因此得到 followpos(1) = {1,2,3}; 下表整理了计算nullable、firstpos、lastpos的计算规则： 序号 结点n nullabl(n) firstpos(n) lastpos(n) 1 标号为ε的叶子结点 true ∅ ∅ 2 位置为i的叶子结点 false {i} {i} 3 并 结点n=c1,c2 nullable(c1) 逻辑或 nullable(c2) firstpos(c1) ∪ firstpos(c2) lastpos(c1) ∪ lastpos(c2) 4 连接 结点n=c1c2 nullable(c1) 逻辑与 nullable(c2) 如果 nullable(c1) 为真，那么值为firstpos(c1) ∪ firstpos(c2)。否则为firstpos(c1) 如果 nullable(c2) 为真，那么值为lastpos(c1) ∪ lastpos(c2)。否则为lastpos(c2) 5 闭包 结点n=c1* true firstpos(c1) lastpos(c1) 由于md格式问题，上表第3行的逗号“,”替换为正则表达式中的”|”符号。 1、每个叶子结点的firstpos和lastpos只包含它自身。上表中第2点； 2、“并” 结点的firstpos和lastpos分别是它所有子节点的firstpos和lastpos的并集。上表第3点； 3、“闭包”结点的firstpos和lastpos分别是它唯一子节点的firstpos和lastpos。上表的第5点； 4、对于“连接”结点而言，firstpos主要是看左子结点是否为空。而lastpos右子节点是否为空。 现在我们运用上面的规则，将第一节的抽象语法树中每个结点的firstpos和lastpos求出来。如下图： 图中蓝色表示firstpos集合，而橙色表示lastpos集合。 计算followpos只有两种情况会使得正则表达式的某个位置跟在另一个位置之后： 1）、如果是结点n是一个“连接”结点，且在抽象语法树中其左右子节点分别为c1，c2。那么对于lastpos(c1)中的每个位置i，firstpos(c2)中所有位置都在followpos(i)中；通俗的讲就是以“连接”结点为根的子树，左子结点lastpos集合中每个位置的followpos都包含右子结点的firstpos。有点类似于二叉树后序遍历，左子树最大结点的后面跟着的是右子树的最小结点。 2）、如果n是“闭包”结点，lastpos(n)中每个位置的followpos都包含于的firstpos(n)中； 基于上诉两个规则，我们对上面的图求解各个重要结点的followpos（上图已经标出每个结点的firstpos和lastpos）。下面是详细步骤： 1、首先我们运用规则1来查看第一个“连接”结点，其左子结点的lastpos为{1,2}，并且其右子结点的firstpos为{3}。因此位置1结点和位置2结点的followpos都包含有位置3。 需要注意一点的是并不是看的当前结点本身的lastpos和firstpos，而是看的其左子结点的lastpos和右子结点的firstpos。 位置n followpos(n) 1 {3} 2 {3} 2、同理我们将剩下的“连接”结点运用规则1，得到如下结果（这里太简单了我就不画图了）： 位置n followpos(n) 3 {4} 4 {5} 5 {6} 3、现在是时候运用上面的规则2了，查找抽象语法树中的“闭包”结点。它和“连接”结点不同的是：“连接”结点看的是其左右子树的lastpos和firstpos，而“闭包”结点看的是其本身的lastpos和firstpos。 位置n followpos(n) 1 {1,2} 2 {1,2} 4、现在我们将前面三步得到的数据进行合并之后的结果为： 很明显位置6作为增广正则表达式中存在的终结符标识，因此其followpos为空集。 位置n followpos(n) 1 {1,2,3} 2 {1,2,3} 3 {4} 4 {5} 5 {6} 6 ∅ 回过头来看一下正则表表达式 (a|b)*abb匹配子串中，位置1对应的结点a其后可能存在字符为a（位置1）、b（位置2）、a（位置3）。位置2和位置1同理。 现在我们将每个位置，已经对应的followpos用一个有向图来表示如下： 很明显的可以看出来，表示followpos函数的有向图几乎就是相应的正则表达式不包含空转换的NFA。 三、根据正则表达式构建DFA要从一个正则表达式构造一个DFA的大致步骤如下： 1、根据扩展的正则表达式构造出一个抽象语法树； 2、计算每个节点的nullable函数值、firstpos函数值、lastpos函数值。以及重要位置节点的followpos函数值； 3、抽象语法树根节点的 firstpos 作为DFA的开始状态； 4、查看正则表达式中存在的各个转换（即a或者b），将当前状态中相同转换的followpos合并到一个集合中； 5、如果合并的集合出现新的状态，则将该状态添加到DFA的状态集合中； 6、如果经过各个转换之后没有新状态就停止。否则重复执行4~6步； 看一下例子能够更加清晰地认识到如何根据正则表达式构建DFA。 图中蓝色表示firstpos集合，而橙色表示lastpos集合。 1）、对于正则表达式 (a|b)*abb，我们构造得到的抽象语法树，已经对应的firstpos/lastpos都在上图中; 2）、我们将根节点的firstpos = {1,2,3} 作为DFA的开始状态： 3）、该正则表达式中存在的转换有a, b，开始状态集合为{1,2,3}，此时我们将状态集合{1,2,3}相同状态的followpos合并到一个集合中。集合{1,2,3}中对应转换a的位置有1，3；对应转换b的位置有{2}。转换a的 followpos(1)={1,2,3}, followpos(3)={4}，将两个集合合并起来为 {1,2,3,4}，由于该状态是新状态，因此将状态集合{1,2,3,4}添加到DFA中；转换b的followpos(2)={1,2,3}，由于该状态并不是新状态。因此只是一个简单转换即可。 重复执行第三步，得到的最终结果为： 四、最小化DFA的状态数对于同一个语言，可以存在多个识别此语言的DFA。例如上图和上一节中由NFA通过子集构造法得到的DFA都能够识别正则表达式 (a|b)*abb。可以看出来它们的个数也不一样。因此如果让我们使用DFA来实现词法分析器，我们肯定是希望使用状态数量尽量少的DFA了。 首先我们先看看区分状态的概念： 区分状态，如果从状态s和t出发，沿着标号为x的路径到达的两个状态中只有一个是接受状态，那么我们就说串x区分状态s和t。状态s和t是可区分的。空串ε可以区分任何一个接受状态和非接受状态。 上图中串 bb 可以区分状态A和B，这是因为从A出发经过标号为bb的路径到达会接受状态C，而状态B经过标号bb的路径到达状态E接受状态。 其次还有一个重要的结论：任何正则语言都有一个唯一的状态数目最少的DFA。而且从任意一个接受相同语言的DFA出发，通过 分组、合并等价的状态，我们总是可以构建得到这个状态数量最少的DFA。 因此DFA状态最小化算法的工作原理是： 将一个DFA的状态集合划分成多个组，每个组中的各个状态之间相互不可区分，但是来自不同组任意的两个状态是可区分的（前面提到的区分概念）。 然后将每个组中的状态合并成状态最少DFA的一个状态。 最初，划分两个组：接受状态组和非接受状态组。基本步骤是从当前划分中取一个状态组，比如 A = {s1, s2, … , sk}，并选定某个输入符号a，检查a是否可以用于区分A组中的某些状态。查看s1, s2, … , sk在a上的转换，如果这些转换的到达的状态落入当前划分的两个或多个组中，我们就将A分割成多个组。 我们以上图为例来看看DFA状态最小化算法：1）、首先划分两组：接受状态组合非接受状态组，这里我们分别给他们起名为组1和组2。 2）、在上图看到DFA仅有a、b两种转换。由于组2只包含了一个状态，并且该状态为接受状态而不能再被分割，所以组2原封不动。因此我们继续看组1。组1中的状态A、B、C、D针对a的转换，得到的状态均为状态B，因此串a无法区分状态A、B、C、D。 3）、组1中的状态A、B、C、D针对b的转换，状态A、B、C都是到达组内某个成员上，这显然是无法区分的（前面提到过组内各个状态之间互不可区分）。但状态D到达的是组2成员对应的状态，很明显状态D可以和A、B、C区分开来。因此我们可以继续将组1划分更小的组： 4）、类似于第三步，组3的状态A、B、C针对b的转换可以划分为两个不同的组。这是因为状态A、C经过转换b之后均为组内状态；而状态B经过转换b得到的组4成员对应的状态： 由于组5中各个状态，无论是针对转换a，还是转换b而言，得到的状态均相同。因此我们不能讲组5进行更细粒度的划分。那么上图就是最终的划分结果。 现在我们根据上面的信息画出对应的状态转换表，由于状态A和状态C经过转换得到的状态是一样的，因此集合{A,C}这里以状态A表示： 状态 a b A B A B B D D B E E B A 我们画出对应的DFA，并将其与上面我们用抽象语法树构造得到的DFA进行对比： 很明显能够对比出来，上面两个DFA除了赋予各个状态的名称不一样之外，各个转换以及转换后的状态都是一样的。我们称这两个状态机是同构的。同构是指对于两个不同的自动机，如果某个自动只是通过更改状态的名字就可以转换为另一个自动机。 五、DFA模拟中的时间和空间的权衡最简单和最快捷的表示一个DFA的转换函数的方法是：使用一个以状态和字符为下标的二维表。给定一个状态和下一个输入字符，我们访问这个数组就可以找出下一个状态以及我们必须要执行的特殊动作。但是我们知道对于二维表而言，各个状态针对某些字符并没有对应转换。如果数量变多了之后就会存在大量的空间浪费问题。 我们可以使用一个带有四个数组的数据结构，如下图所示： 1）、base数组用于确定状态s条目的基准位置；2）、next和check数组存放的正式对应状态条目；3）、数组check用于确定base[s]给出的基准位置是否正确，如果错误则使用default数组来确定另一个基准位置； 在计算状态s在输入a的后继状态时，我们首先查看数组next和check中在位置 index = base[s] + a （a指当前输入字符，其对应于ascii码表上固定数字）上的状态条目。a、如果check[index] == s，那么该状态条目有效（该状态指的是经过转换a之后得到的后续状态）；b、如果check[index] != s，那我们则得到另一个状态条目t = default[s]。并将状态t设置为当前状态重复上诉过程获取下一个状态； 下面是对应的伪代码： 1234int nextState(s,a) &#123; if(check[base[s]+a] == s) return next[base[s]+a]; else return nextState(default[s],a);&#125; 总结在这一节中需要重点理解的就是抽象语法树：抽象语法树的每个内部结点代表一个运算符，该内部结点的子节点代表运算符的运算分量。然后可以根据正则表达式构造对应的抽象语法树。函数nullable、firspos、lastpos以及followpos在构造DFA中起着重要的作用。nullable指的是对应结点的子表达式是否可能返回空串；firstpos是子表表达式串的第一个符号；lastpos是子表达式串的最后一个符号；followpos则是相对要复杂一点，只针对连接结点和闭包结点求followpos。在有了上面只是作为铺垫之后，求正则表达式来DFA的转换就要轻松许多。首先是在抽象语法树中以根节点所在的firstpos集合作为DFA的开始状态。然后查看集合内部各个序号对应的转换，获取对应需要的followpos求并集。以此类推下去可构造一个完整的DFA。而在最小化DFA状态数时，则根据不同的划分，递归地将各组区分开来，得到状态数最少的DFA。而在最后也给出了权衡时间和空间的数据结构。 到这儿基本上把词法分析相关的知识都简单过了一遍了。后续再继续更新语法分析部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[词法分析——从正则表达式到有穷自动机]]></title>
      <url>%2F2019%2F10%2F28%2Fcompiler_regular_fa%2F</url>
      <content type="text"><![CDATA[自动机在本质上是和状态转换图类似的。但也有一点不同，它们只能对每个可能的输入串简单地回答“是”或者“否”；有穷自动机分为两类： 1、不确定的有穷自动机（NFA）：其边上的标号没有任何限制，离开一个状态的多条边上可以存在多个相同的符号，也可以是空； 2、确定的有穷自动机（DFA）：对于每个符号而言，以该符号为标号的边有且只有一条离开该状态。 下面我们就一次来看看不确定的有穷自动机，和确定的有穷自动机。 一、NFA——不确定的有穷自动机不确定的有穷自动机由下面几个部分组成：1）、有穷的状态集合，类似于上一节中状态转换表的每一个节点；2）、一个输入符号集合，可以简单地理解为unicode字符集之类的；3）、转换函数，类似于状态转换表中的有向箭头一样；4）、开始状态，或者叫初始状态；5）、接受状态，也称作终止状态，如下图的双圆圈表示； 上图是一个能够识别正则表达式 (a|b)*abb的NFA转换图。 转换表和接收串我们可以将一个NFA表示为一张转换表。表的每一行表示一个状态，表的每一列对应于输入符号和空串。先将上图的NFA转换图转换成为对应的转换表，然后根据转换表再具体说明其中的含义： 状态 a b 空字符ε 0 {0,1} {0} ∅ 1 ∅ {2} ∅ 2 ∅ {3} ∅ 3 ∅ ∅ ∅ 对于一个给定的状态和给定的转换，其得到的值是NFA转换图中应用对应转换之后得到的状态集合。如果对应的转换没有后续状态，则用符号∅表示。 而自动机在判断是否接收字符串的依据是：存在某条字符序列组成符号串的路径，该路径能够从开始状态到达某个接收状态。我们就说NFA接收这个符号串。比如： 该NFA接收符号串： 即字符串aaa被这个NFA接受。路径中的ε并不会记录在实际的路径中。 二、DFA——确定的有穷自动机确定的有穷自动机是不确定有穷自动机的特例，它性质如下：1）、没有输入符号ε；2）、对于每一个状态s，每一个输入符号a，有且只有一条边离开状态s。 通俗来讲就是指定某个状态，不存在两个或者以上相同的转换存在。比如对于NFA而言，状态0中转换a可以到达两个及其以上不同的状态；而DFA则只能到达一个（有且只有）状态。 比如下面同样是识别(a|b)*abb的DFA转换图： 对于给定的输入串ababb，这个DFA的对应状态顺序为：0、1、2、1、2、3。 三、正则表达式、NFA以及DFA之间的关联这里首先我们将正则表达式转变为接受相同语言的NFA。然后介绍如何将NFA转变为DFA。这样我们就有了一个粗略的方式将正则表达式转换为NFA和DFA的方案。 正则表达构造NFA的规则通过正则表达式构造NFA主要分为六种情况。在下面每一个情况中，我们都有提出状态i和状态f是否为新状态。指出的意义在于我们需要明确新构建NFA时出现的状态是否为原各个NFA中已有状态，还是需要我们去新增一个状态。比如在连接运算中出现的状态i和f并非新状态，而是已有状态的特殊状态： 规则1、空字符ε表达式；对于表达式ε，构造下面的NFA这里i是一个新状态，也是NFA的开始状态；f是另一个新状态，也表示NFA的接受状态 规则2、字母表中子表达式；这里状态i和状态f是新状态 规则3、正则表达式中的并运算；假设正则表达式s和t对应的NFA为N(s)和N(t)，r = s|t的NFA为N(r)。这里状态i和状态f是新状态：因此从状态i到状态f的任何路径要么只通过N(s)，要么只通过N(t)。且离开i或进入f的ε转换都不会改变路径上的标号。因此我们可以判定 N(r)识别 L(r) = L(s) ∪ L(t) 。 规则4、正则表达式中的连接运算；同样的，假设正则表达式s和t对应的NFA为N(s)和N(t)，r = st 。对应的NFA为：这个情形下的状态i和状态f并非新引入的状态，而是原有正则表达式s和t中已有的状态。 规则5、正则表达式中的闭包运算；这里假设正则表达式 r = s*，N(s)表示正则表达式s对应的NFA。因此闭包运算得到的NFA为：这里状态i和状态f都是新引入的状态。 规则6、括号表达式r = (s) 其NFA是完全相同的； 因此 只有在正则表达式的连接运算和括号存在时，才不会引入新的状态 。N(r)的状态数最多为r中出现的运算符和运算分量总数的两倍。这是因为每一个构造步骤最毒只引入两个新状态。 正则表达式构造NFA实例现在我们运用上面提到的规则，来将一个正则表达式转换为对应的NFA。将正则表达式转换为NFA的算法是语法制导的，也就是说： 沿着正则表达式的语法分析树 自底向上 递归的进行。 下面关于语法分析树定义部分可以选读，由于会用到很多专业名词，此时大可不必去细究语法分析树，因为对于我来说理解下文并不是必须需要这些知识点。但为了行文的准确性，我将下面要用的语法分析树的定义先列出来。语法分析树用图形方式展示了从文法的开始符号推导出相应语言中符号串的过程。给定一个上下文无关文法，该文法的语法分析树具有如下形式：1）、根节点的标号为文法的开始符号（大体上为文法的第一个产生式的首个符号）；2）、每个叶子结点的标号为一个终结符或者空ε（具体字母表中的符号，粗略来看它的叶子结点从左到右组成了最终的正则表达式）；3）、每个内部结点的标号为一个非终结符（可以简单理解为该符号还存在产生式还可以可以推导出终结符号）。4）、对于产生式A-&gt;XYZ，对于X, Y ,Z来说既可以是终结符，也可以是非终结符。 对于正则表达式 (a|b)*abb ，我们构造处对应的语法分析树： 1）、既然是自底向上的，那首先肯定是看子表达式a和b。运用规则1，即可得到两个NFA： 2）、现在的叶子节点为并运算符，此时运用规则3。此时我们需要新引入两个状态，并且原有NFA中的接受状态要变为非接受状态： 对于带有括号的正则表达式而言，我们从规则6可知，括号运算符不会改变当前的NFA。因此当遇到括号时NFA不改变。 3）、对于闭包运算符来说，同样会引入两个新状态： 4）、最后是3个连接操作，连接的子表达式分别是a、b、b。因此将它们连接之后得到的最终NFA如下： NFA到DFA的转换——子集构造法现在我们已经能够从正则表达式转换为NFA了，那如果我们要把正则表达式转换为DFA呢？这里先介绍用NFA转换为DFA的方式，后续会将通过抽象语法树搭配firstpos，lastpos和followpos直接从正则表达式构造DFA。现在我们先通过子集构造法来讲NFA转换为DFA。 子集构造法中，我们需要通过NFA为DFA构造转换表。 DFA的每一个状态是一个NFA的状态集合。 DFA的状态是一个集合，该集合里面包含的是对应NFA的状态。 我们在上面看到在将正则表达式构造成NFA时，NFA里面存在很多空转换。所以当务之急是如果正确地处理NFA上面的空转换。下面展示了NFA的状态集合上的相关操作： 序号 操作 解释 1 ε-closure(s) 指的是从NFA的状态s开始，可以通过ε转换得到的状态集合 2 ε-closure(T) 指的是集合T中的某个NFA状态，该状态只通过ε转换得到的状态集合 3 move(T,a) 即集合T中的状态通过转换a得到的状态集合 假设s0是NFA的开始状态，那么对应DFA的开始状态就是 ε-closure(s0) 。而DFA的接受状态是至少包含NFA接受状态的集合。 我们在上一节得到的NFA，现在我们将该NFA转换为DFA： 1、对于开始状态0，我们使用操作1（上表中序号为1的操作，下文类似），即状态0通过ε空转换可以得到的状态集合为： {0, 1, 2, 3, 7}。这里有一点需要注意的是：因为路径可以不包含边，所以状态0也是可以从它自身出发经过标号ε到达的状态。 2、我们对第一步得到的集合求转换a的集合。现在我们看状态集合{0, 1, 2, 3, 7}通过转换a（即应用操作3）可以得到的状态集合{3,8}。此时我们对集合{3,8}应用操作2得到的集合为{1, 2, 4, 6, 7}： 在集合{0, 1, 2, 3, 7}里面，只有状态2和状态7可以通过a转换得到的集合是{3, 8}。此时查看状态3通过空转换得到集合为：a、s3 —ε—&gt; s6 —ε—&gt; s7;b、s3 —ε—&gt; s6 —ε—&gt; s1 —ε—&gt; s2;c、s3 —ε—&gt; s6 —ε—&gt; s1 —ε—&gt; s4;因此最终的集合为 {1,2,3,4,6,7,8}。 3、同样的，我们对第一步得到的集合求转换b的集合。现在我们看状态集合{0, 1, 2, 3, 7}通过转换b可以得到的状态集合{5}。然后集合{5}通过空转换可以得到的集合为{1, 2, 4, 6, 7} 具体的分析和第2步类似。 这样我们对后续出现的每一个状态都执行对应的转换a、转换b。我们可以得到一个状态转换表： NFA状态 DFA状态 a b {0,1,2,4,7} A B C {1,2,3,4,6,7,8} B B D {1,2,4,5,6,7} C B C {1,2,4,5,6,7,9} D B E {1,2,4,5,6,7,10} E B C 我们前面说过NFA开始状态通过ε转换得到集合为开始状态，因此上表中对应DFA对应的状态为A。而NFA状态集合中包含有接受状态对应DFA的状态E，因此E为DFA的接受状态。对应的DFA如下： 下面是对应算法的伪代码描述。模拟一个NFA的执行（即NFA转换为DFA） a）、输入部分：一个以eof结束的输入串x；一个NFA N，它的开始状态为s0，接受状态为F，转换函数move；b）、输出：如果NFA N接受符号串x，则返回yes，否则返回no； 12345678910S = ε-closure(s0); /// 首先求出开始状态经过空转换之后的集合，即上面的第1步c = nextChar(); /// 读取下一个输入字符while(c != eof) &#123; /// 首先计算当前集合S经过转换c之后得到集合，然后用该集合进行空转换。得到c转换之后真正的元素集合。 /// 即上面提到的第2、3步 S = ε-closure(move(S,c)); c = nextChar();&#125;if (S ∩ F != ∅) return YES;else retnru NO; 四、词法分析器生成工具的设计词法分析器的程序包含一个固定模拟自动机的程序（先不指定是NFA，还是DFA）。下图是一个lex程序转换成自动机的结构： 这里提到了前面介绍的几个概念，这儿简要说明一下。输入缓冲区可以让我们依次读入多个字符到缓冲区中（这个大致为4096字节），而不是每读入一个字符就调用一次系统读取命令；词素作为匹配了某个模式词法单元的字符串，比如词素为name词法单元id；指针lexemeBegin指向当前词素的开始位置处；指针forward的作用是一直向前扫描，直到匹配某个模式为止。 下表中有三个模式，已经对应模式的动作。这个表指明了词法分析器需要的模式，已经匹配到对应模式之后的动作： 序号 模式 动作 P1 a A1 P2 abb A2 P3 a*b+ A3 这里的动作是指匹配到对应模式之后需要做的相关操作，比如匹配到词法单元id之后的动作是生成对应的标识符，获取对应词法单元并返回给语法分析器；匹配到空白符之后我们将输入回退到非空白符的开头，而且不向语法分析器返回任何词法单元。等等。 上表中满足模式P2和也同时满足模式P3，当出现这种冲突时我们首先选择P2。这是因为在解决冲突时 以先出现的模式为主 (P2先于P3列出)。 下面列出三个模式对应的NFA： 以及将上面三个合并之后得到的NFA： 现在如果词法分析器模拟了上图的NFA，那么该分析器必须从它的输入中lexemeBegin指向的位置开始读取输入，并移动forward指针。然后根据子集构造法来获取当前的状态集合。需要注意的是：这里并不是使用子集构造法将NFA转换为DFA，而只是简单地想知道某一状态集合通过子集构造法之后得到的新的状态集合（不过在下面的“词法分析器使用的DFA”一节会使用该表，该表的第二列就是对应DFA的状态）。 NFA状态 状态编号（DFA状态） a b {0,1,3,7} A B C {2,4,7} B D E {8} C ∅ C {7} D D C {5,8} E ∅ F {6,8} F ∅ C 在上表中，最终会达到一个没有后续状态的输入点。此时不可能有任何更长的输入前缀使得这个NFA到达某个接受状态，此后的状态将一直为空。比如上表中状态编号为C、E、F之后再继续输入a，那么此时就没有任何的后续状态。 上图中我们的输入字符串以 aaba 开头。当我们在读入第四个符号 a 之后，此时我们处于一个空状态集合中（也可以从上表中第三行得出）。 这时候我们就沿着状态集的顺序往回找，直到找到包含一个或多个接受状态的集合为止 。 如果集合中存在多个接受状态，那么我们就选择模式靠前相对应的接受状态。此时将forward指针移动到词素的末尾，同时执行对应的动作（前面表格中的A1…A3）。 在这里表明输入串aaba被模式 a*b+ 匹配。然后执行对应的动作A3。 词法分析器使用的DFA根据前面的转换表，我们构造出对应的DFA： 对于状态{6,8}而言有两个接受状态，分别对应于模式 abb 和 ab+ 。由于前一个模式先被列出，因此我们选择 *abb 作为状态{6,8}所关联的模式。 在词法分析器中，使用DFA和使用NFA的方法相似。模拟DFA运行，直到某一点上没有后续状态为止。这种时候我们就沿着顺序往回找，直到找到包含一个或多个接受状态的集合为止。 向前看运算符有时候为了能够正确地识别某个词法单元的实际词素，我们需要指明 该词法单元模式r1之后必须跟着模式r2 ，因此我们可以将其表示为 “r1/r2“ 。实际上在将r1/r2转换为对应的NFA时，我们把/看成ε（不会去输入中查找/）。 例如： 上图是词法单元IF的模式，在这个模式中我们使用了向前看运算符。状态6表明了关键字IF的出现，因为如果只是单单的空转换之前的模式（r1）将无法准确的识别是关键字if，还是一个带有if前缀的标识符。当进入了状态6时，我们需要向回扫描到最晚出现的状态2，此时我们找到了对应词法单元的词素。 总结在本篇文章中，我们认识到了NFA（不确定的有穷自动机）和DFA（确定的有穷自动机），以及它们与状态转换图之间的差异。DFA和NFA最明显的差异莫过于对于每一个状态s，对于同一个输入符号而言有且只有一条离开该状态的边。其次我们知道了如何通过正则表达式构造NFA，大致的操作有连接、并、闭包和简单的括号操作操作。其中并和闭包操作会引入新状态（使用空转换进行连接）。然后我们通过子集构造法可以将NFA转换为对应的DFA。其中包括有三种操作，分别是：某一指定状态的空转换；某一指定集合执行空转换；某一指定集合执行特定转换a。通过这三种操作我们构造出NFA对应DFA的转换表。最后我们了解了一点词法分析器生成工具的设计，以及向前看运算符的作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[词法分析——手动词法单元的识别（状态转换图、KMP算法）]]></title>
      <url>%2F2019%2F10%2F28%2Fcompiler_stateGraph_kmp%2F</url>
      <content type="text"><![CDATA[在这儿我们先用手工的方式将正则表达式表示的模式转换为状态转换图。在下一节我们会用自动化的方法构造对应的转换图。 1）、结点：状态转换图有一组被称为“状态”的结点，它表示在扫描过程（即词法分析器扫描指定输入串，寻找指定模式词素）中可能出现的状态。也就是lexemeBegin指针和forward指针之间的所有的字符。2）、边：从图的一个状态指向另一个状态，每条边的标号包含了一个或多个符号。如果找到这样的一条边，就将forward指针前移，并进入该边指向的下一个状态。3）、开始状态：也就是上图中的start。4）、接收状态或者最终状态：该状态表明已经找到了一个词素。也就是上图中两个圆圈。 接收状态通常是 向语法分析器返回一个词法单元和相关的属性值 。 5）、回退🌟号：上图中接受状态右上角的*号，表示我们识别到的词素并不包含使我们到达接受状态的符号（也就是上图中的no let/dig边）。此时我们需要回退forward指针到倒数第二个状态。这其中可能会回退多步，所以这里用*号来表示需要回退； relop状态转换图我们根据上一节的relop词法单元，已经对应的属性来构造一个relop的状态转换图 词素 词法单元名字 属性值 &lt; relop LT &gt; relop GT … … … != relop NE 其实对于这个状态转换图来说，我只画了其中的比较运算符和逻辑运算符。对于位运算符（&lt;&lt;左移, &gt;&gt;右移）并没画出来。这里主要是想表达各个接收状态，和forward指针回退的操作。 id（标识符）和关键字的状态转换图 词法单元 模式 letter [A-Za-z] id letter(letter , digit)* 注：上表中的正则表达式将逗号“,”更改为”|”。对于关键字来说，它们看起来和标识符是很像的。但它们并不是标识符。 对于关键字if/else/for等等关键字，标识符forearm同样也是满足上诉转换图的。 为了解决上诉问题，编译原理中的处理方案有两个： （1）👏👏👏、初始化时就将各个保留字填入符号表中；符号表的某个字段会指明这些串并不是普通的标识符，并指出其对应的词法单元。当我们找到一个标识符时，如果该标识符尚未出现在符号表中，就会调用上图中出现的installID将此标识符放入符号表中，并返回一个指针（该指针指向词素对应的符号表条目）。 任何在词法分析时不在符号表中的标识符都不可能是一个保留字，因此它的词法单元是id （2）、为每一个关键字建立单独的状态转换图； 对于这个状态图来说，我们必须要区分以else为前缀的标识符（比如elseid），因此我们在倒数第二个状态后的边，必须要限制为非字符和数字。 使用第二个方案时：必须要设定词法单元的优先级，使得当一个词素同时匹配id和保留字模式时，优先识别保留字词法单元。 我们从第一点可以确定标识符加入符号表的时机是： 识别到对应词法单元时，如果该标识符尚未加入符号表。此时词法分析器会将该 标识符 (也可以理解为词素) 放入符号表中。 词法单元number状态转换图 词法单元 模式 digit [0-9] digits digit+ number digits(.digits)?(E[+-]?digits)? 下图是一个识别整数和浮点数的状态转换图： 从上图中我们可以看到，接收状态22既匹配到了科学计数法表示的浮点数（包含小数部分，也包含指数部分），也匹配到了科学计数法表示的整数。接收状态23是匹配到的整数词素；接收状态24为不带科学计数法的的整数。 当我们在接收状态时，返回词法单元 number 以及一个指向 常量表 条目的指针，上面找到的词素就放在这个常量表条目中。 ws（空白符）状态转换图 词法单元 模式 ws(空白符) (blank \ tab \ newline)+ 我们用转换delim替换上表中的blank、tab、newline： 空白符后面需要跟一个非空白符才能确定当前已经完成了对连续空白符的扫描。 当我们识别到空白符之后，但我们 并不向语法分析器返回任何词法单元。相反，我们必须在这个空白符之后再次启动词法分析过程 。 基于状态转换图的的词法分析器体系结构 1、使用一个state变量来保存一个状态转换图的当前状态编号（就是前面我们从0到27的编号）。 2、用switch语句根据state的值将我们转到对应状态相应的代码段，该代码段为对应状态所需要执行的动作； 二、KMP算法现在我们看一下KMP算法，它可以用于在文本串中识别一组关键字。在看KMP字符串匹配算法之前，我们先看一下朴素字符串匹配算法。 朴素字符串匹配算法朴素字符串匹配算法是同一个循环找到所有有效偏移，寻找满足条件的情况。 朴素字符串匹配算法可以形象地看成是待匹配串（子串）沿着原文本（主串）滑动，同时对每个偏移都要检测子串上的字符是否与主串中对应字符相等。其中红色字符表示对应位置匹配成功，灰色字符表示匹配失败。大致的代码是这样： 12345678910111213141516171819using namespace std;int naive_string_matcher(string text, string pattern)&#123; string::size_type n = text.size(); string::size_type m = pattern.size(); string::size_type total = n-m; string::size_type s = -1; for (string::size_type i = 0; i &lt; total; i++) &#123; s = i; string::size_type matched = 0; for(string::size_type idx = 0; idx &lt; m; idx++) &#123; if(pattern[idx] == text[s+idx]) matched++; &#125; if (matched == m) return s; &#125; return s; &#125; 在最坏情况下，朴素字符串匹配算法的平均时间复杂度为O(n2) 。 失效函数KMP算法在最坏情况下也会比朴素字符串匹配算法好很多。为了快速处理文本串并在这些串中搜索一个关键字，定义了 失效函数 f(s) ，其中s为对应状态图上的各个状态。也可以叫做辅助函数。在这之前我们先看看串的一部分术语： 前缀：从串s尾部删除0个或多个符号后得到的串； 后缀：从串s开始处删除0个或多个符号后得到的串； 子串：删除某个前缀或者后缀之后得到的串； 真前缀、真后缀、真子串：指的是既不包含空串，也不包含本身的前缀、后缀、子串； 针对关键字b1b2b3…bn，其目标是使得b1b2…bf(s)不仅是b1…bs的真前缀，又是b1…bs后缀的子串。并且b1b2…bf(s)是所求得的最长串。下面我们以串ababaca来进行讲解： a、构造关键字状态转换图我们根据前面的知识，节点表示状态，有向边指的是转换 现在有了状态转换图，我们需要构造每一个状态节点s，所对应的失效函数值。 b、求解每一个状态s的函数值 1）、由于前面提到过真前缀的前提，因此我们从s=1开始计算。首先我们将f(1)设置为0，既状态1对应的失效函数值为0。并且这里我们新增一个辅助游标t用于对照状态s： s 1 2 3 4 5 6 7 f(s) 0 - - - - - - 2）、此时我们比较一下状态t的转换（a）和状态s的转换（b），发现字符a并不等于字符b。此时我们将f(s+1)，即f(2)的值设置为0： s 1 2 3 4 5 6 7 f(s) 0 0 - - - - - 并且将s移动到状态2： 3）、继续比较状态t的转换（a）和状态s的转换（a）此时他们相等。因此 先将t的自增1，然后将f(s+1)，即f(2)的值设置为t的值（此时为1）： s 1 2 3 4 5 6 7 f(s) 0 0 1 - - - - 同样的，此时将s移动到状态3： 4）、依次比较后续的s=3，和s=4的情况。它们的情形和第三步类似： s 1 2 3 4 5 6 7 f(s) 0 0 1 2 3 - - 此时t=3，s=5。对应的状态转换图为： 5）、现在我们比较一下状态t的转换（b）和状态s的转换（c），它们并不相等。由于 此时t不为0，说明在此之前肯定是存在某一串既为真前缀，又为后缀子串 。因此我们获取t当前位置对应失效函数函数的值。此时t=3，查上表可知f(3)=1。所以现在我们将t移动到状态1： 6）、同样的比较状态t的转换（b）和状态s的转换（c），依然不相等。由于t不等于0，此时t=1，查第4步的表可知f(1)=0。所以我们现在将t移动到状态0： 7）、对于后续状态的失效函数值确定，可以仿照第2、3和5步进行求解。最终完整失效函数为： s 1 2 3 4 5 6 7 f(s) 0 0 1 2 3 0 1 下面是对应的代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;void trie_func(string pattern, vector&lt;int&gt; &amp;f) &#123; const string::size_type length = pattern.size()+1; int t = 0; f[0]=t;// f[0] store t f[1]=0; for(int s = 1; s&lt; length-1; s++) &#123; while(t&gt;0 &amp;&amp; pattern[t] != pattern[s])&#123; t=f[t]; f[0]=t; &#125; if(pattern[s]==pattern[t])&#123; t=t+1; f[s+1]=t; f[0]=t; &#125; else &#123;f[s+1]=0;&#125; &#125;&#125;int main(int argc, const char * argv[])&#123; string pattern(&quot;ababaca&quot;); vector &lt;int&gt; trie(pattern.size()+1); trie_func(pattern,trie); for (vector&lt;int&gt;::iterator itr = trie.begin(); itr != trie.end(); itr++) &#123; cout&lt;&lt;*itr&lt;&lt;endl; &#125; return 0;&#125; 子串与主串的比较现在我们以主串bcbababaababacacd 和子串 ababaca 作为例子，来看主串是否包含子串。 我们从前面知道子串失效函数为： state 1 2 3 4 5 6 7 f(s) 0 0 1 2 3 0 1 这里我将上一节的字符s替换为state，是因为这一节我会用字符s用作当前子串相对于主串的偏移量。而真正原因是我太懒了，发现图中和失效函数都用了同一个字符s。为了避免混淆，但又不想重新画图🤣。 1）、主串的第一个字符和子串的第一个字符不相等。此时我们将子串向右滑动一位，此时偏移值s = 1 ： 2）、依次对后面机会字符进行对比，直到s=3时，我们发现字符串 ababa 成功匹配，但是子串的第六个字符和主串的第九个字符并不相等： 这时候失效函数就派上用途了。此时已匹配长度q=5，也就是说在状态转换图中对应于状态5。而状态5对应的失效函数值为3，对于串ababa来说，长度为3的串aba既是它的真前缀，又是它后缀的子串。此时主串和子串中的aba已经失效，已经没有再去比较的意义了，我们可以直接去比较主串中的a和子串中的b了： 3）、现在我们将子串向右边移动2个字符，然后继续进行比较： 这里计算偏移量s很重要： ⚠️⚠️⚠️ s = s + (state - f(state)) 比如这里的q=5，也就说明state=5，而f(state) = 3。因此向右的偏移量为：s = 3 + (5-3) = 5。 4）从图中标红也能看出来a≠b，因此我们需要继续重复步骤3的事情： 5）、如上图所示，我们继续将子串向右移动2个字符，进行比较： 相等。但这里有一个需要注意的点是：此时state为1，而f(state)=0。这意味着此时并没有存在即是真前缀又是后缀的子串。现在只能和第一步一样，手动将偏移量加1。 6）、现在将偏移量加1之后，并将子串和主串进行匹配。此时匹配成功，因为我们可以判断主串是包含有指定关键字的字符串： 下面是简单的代码实现，需要注意的是这里并没有做极端情况的处理： 1234567891011121314151617181920212223242526272829303132333435363738int kmp_match(string text, string pattern) &#123; vector&lt;int&gt; trie(pattern.size() + 1); trie_func(pattern, trie); int offset = -1; int q = 0; string::size_type m = text.size(); string::size_type n = pattern.size(); if (m &lt; n) &#123; return -1; &#125; for (string::size_type i = 0; i &lt; m; i++) &#123; while (q &gt; 0 &amp;&amp; text[i] != pattern[q] &amp;&amp; q != 0) &#123; q = trie[q]; &#125; if (text[i] == pattern[q]) &#123; q++; &#125; if (q==n) &#123; offset = i - q + 1; &#125; &#125; return offset;&#125;int main()&#123; string text(&quot;bcbababaababacacd&quot;); string pattern(&quot;ababaca&quot;); int offset = kmp_match(text, pattern); cout &lt;&lt; &quot;offset: &quot; &lt;&lt; offset &lt;&lt; endl;&#125; 总结本节到这儿，我们已经能够手工地为各类词法单元构造状态转换图了。这类词法单元包括有：标识符（包括字符）、数字（包括数位）、关键字、运算符等等，而且也知道如何使用KMP算法来寻找指定串，例如标识符和关键字等等。在下一节就需要通过自动地方式里生层对应的状态图了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[词法分析——词法单元和正则表达式]]></title>
      <url>%2F2019%2F10%2F28%2Fcompiler_token_regular%2F</url>
      <content type="text"><![CDATA[本系列文章是《编译原理》的读书笔记，并加入了一些个人的理解。本系列的主要内容顺序如下：1）、首先解释什么是词法单元；2）、如何手动识别词法单元；3）、最后是词法分析器如何自动机自动识别词法单元；本文主要是看一下词分析器的词法单元部分。包括一些基本概念，以及词法单元的识别。 首先我们先大体上看一下词法分析器的作用。它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元的序列。每个词法单元对应一个词素。 这里我们有提到几个专业名词：词素、词法单元。它们的定义马上就会说到，我们可以先看看下面这幅图： 从图中我们可以看出来词法分析器还在和符号表进行交互，其主要作用是从符号表中读取有关标识符种类信息，以确定需要向语法分析器传送的词法单元。 一、词法单元现在我们就先来看看前面提到的一些专业名词： 词法单元：由一个 词法单元名和一个可选的属性 构成。比如一个特定的关键字，或者代表一个标识符的输入字符序列。 词法单元是语法分析器处理的输入符号。 词素：源程序中的一个字符序列，它和某个词法单元的模式匹配。它被词法分析器识别为该词法单元的一个实例； 模式：它描述了一个词法单元的词素可能具有的形式； 这儿我大致地解释一下这三个概念之间的关系：词法单元指定的是某一类型的事物，用面向对象来说就是，词法单元类（class）；词素就是指的是该类的具体实例；而模式就是该类的一个属性，它描述了词素所具有的具体特征。 1234class Tokens&#123; string pattern;&#125;;Tokens lexeme; 并不是说实际就是这个代码，我只是为了便于理解，而进行的类比。下表给出了一些常见的词法单元： 词法单元 非正式描述 词素实例 if(关键字) 字符i,f if else(关键字) 字符e,l,s,e else comparison(比较运算符) &lt;,&gt;,&lt;=,&gt;=,==… &lt;=, != id(标识符) 字母开头的字母/数字串 pi, printf number(数字) 数字常量 3.1415 literal(字符/串) 两双引号之间的任何字符 “hello, world” 词法单元的大致分类1）、关键字：每个关键字有一个词法单元；2）、标识符：一个表示所有标识符的词法单元；3）、常量：常量词法单元包含的数字和字符串；4）、运算符：运算法也是一个词法单元，可以是比较运算符，也可以是算术运算符；5）、标点符号：每一个标点符号有一个词法单元。比如括号等等； 词法单元的属性值从这里我们可以看出来词法单元表示了一类事物，但是我们如何去区分具体的词素？ 词法分析器不仅向语法分析器返回一个词法单元的名字，还会返回一个描述该词法单元的词素属性值。 比如我们声明的一个变量、或者函数时，它作为标识符一类的词法单元。它们更加详细的信息（词素、类型、第一次在源代码中出现的位置）都会保存在符号表中。因此： 一个标识符的属性值是一个指向符号表中该标识符对应项的指针。 注意，词法单元的属性值是指向符号表项的指针。 二、正则表达式这一节主要是在讲正则表达式，如果已经熟悉了正则表达式，可以直接跳过阅读词法单元的识别。而且这一节会增加很多概念，也是比较枯燥的。从前面我们可以感性（直观）知道哪些词素是某一类型的词法单元。为了能够明确地划分不同词素对应的词法单元，我们需要引入正则表达式。正则表达式是一种用来描述词素模式的重要表示方法。因此正则表达式就描述了特定词素对应的模式。 在词法分析中，最重要的语言上的运算是：并、连接和闭包 运算： 并（L|M）：得到的串s可能属于L也可能属于M。但只能是其中之一； 连接(LM)：得到的串s即属于L，也属于M； 闭包：闭包分Kleene闭包和正闭包。Kleene闭包是指某一集合的符号重复 0～∞ 多次，可能是空串。正必报不包含重复0次，即不包含空串； letter_ (letter_ | digit_) *这是一个c语言中标识符的正则表达式。其中用letter_来表示任一字母或者下划线，用digit_表示数位。c语言中标识符必须是必须是以字符开头，包含数字、字符来表示。 优先级正则表达式中，括号的优先级最高，优先级依次降低：1）、一元运算符 *；2）、连接（左结合）；3）、并运算符优先级最低（左结合）； 比如正则表达式 (a|b)*，可以表示多个串： 12345678910空集;//闭包次数为0; a;//闭包次数为1,取并的左边;aa;//闭包次数为2,一直取并的左边;aa...a;//闭包次数为n,一直取并的左边;b;//闭包次数为1,取并的右边;bb;//闭包次数为2,取并的右边;bb...b;//闭包次数为n,取并的右边;ab;//闭包次数为2,先取左边再取右边;ba;//闭包次数为2,先取右边再取左边;... 如上, 可以用一个正则表达式定义的语言叫做正则集合。如果两个正则表达式r和s表示相同的语言，则称 r 和 s 等价r=s 。 例一c语言中的标识符是由字母、数字和下划线组成的串，下面是c标识符对应语言的正则定义： 123letter_ -&gt; A | B | C | ... | Z | a | b | c | ... | z | _ digit -&gt; 0 | 1 | ... | 9 id -&gt; letter_ (letter_ | digit ) * 例二无符号数是形如5280、0.01234、6.336E4或者1.89E-4的串。下面的正则定义给出了这类符号串的精确定义： 12345digit -&gt; 0 | 1 | ...| 9digits -&gt; digit digit* optionalFraction -&gt; . digits | 空集optionalExponent -&gt; (E (+|-|空) digits) | 空number -&gt; digits optionalFraction optionalExponent 正则表达式的扩展 单目后缀运算符+：指的正闭包； 单目后缀运算符?：表示出现0个，或者一个； 字符类：正则表达式a1 | a2 | a3 |…|an可以缩写为 [a1a2a3…an]。当a1到an形成一个逻辑上连续的序列时，可以写作 [a1 - an]; 例三我们可以使用正则表达式的扩展，来把例一的正则表达式进行改写： 123letter_ -&gt; [A-Za-z_]digit -&gt; [0-9]id -&gt; letter_ (letter_ | digit ) * 现在通过正则表达式，我们可以写出对应词法单元对应的模式来。因此下一步要做的就是读取源代码里面的字符流，搭配对应的词法单元的模式，生成对应的词法单元。 三、输入缓冲很多情况下，我们需要至少向前看一个字符。比如在c语言中，像-、=或者&lt; 这样单字符运算符也有可能是 -&gt; 、== 或者&lt;= 这样的双字符。在编译原理中会引入一个哨兵标记的双缓冲区方案来处理向前看运算符的问题。 上图中出现的lexemeBegin和forward指针作用分别是：1）、lexemeBegin：该指针指向当前词素的开始处。当前我们正在匹配某一正则表达式对应模式的词素；2）、forward：该指针一直向前扫描，直到发现某个模式被匹配为止。 第一步、读取内容到缓冲区中：每次读取缓冲区长度的字符到缓冲区中；每个输入缓冲区的容量通常是一个磁盘块的大小，比如4096字节。我们在读取的时候就是一次性读取一个缓冲区长度的字符到缓冲区中，以避免频繁的使用读取函数。当输入文件中的剩余字符不足缓冲区长度的时候，文件的默认会有一个eof（end of file）来表示文件结束。 第二步、lexemeBegin和forward指针的移动：使用lexemeBegin指针和forward指针读取指定模式的词素。一旦确定了下一个词素（下图中的左括号）forward指针将指向该词素 结尾的字符 。词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来（在前面我们提过的词法单元分为词法单元名和可选的属性）。然后lexemeBegin指针移动到 刚刚找到词素之后的第一个字符 。如下图所示： 第三步、缓冲区的替换：我们在移动forward指针前需要判断当前是否已经到达某个缓冲区的末尾。如果是，我们需要将新字符读入到另外一个缓冲区中（前面提到的双缓冲区），且将forward指针指向新缓冲区的头部。 哨兵标记如前面所说，我们在每次移动forward指针时，我们都需要检查是否到达了缓冲区的末尾。如果是的话，我们就需要加载另一个缓冲区。因此在这里我们需要做两次测试：1）、检查是否到达缓冲区的末尾；2）、确定读入的字符是什么；解决这两个问题，我们可以在缓冲区的末尾增加一个“哨兵”，比如eof： 从这儿我们可以知道，对于编译器而言在进行词法分析的时候，需要通过lexemeBegin和forward来扫描缓冲区。如果匹配某一个词素时，比如很长的字符串（比如将一片短篇小说作为常量字符串放到一个变量中）时，那就会出现缓冲区长度不足的情况，因此在日常编码中将长字符串拆分成多个短的字符串。 这其实也算是学习编译原理，有助于提供编程效率的一个例子了。 总结在前面我们用正则表达式来表示一个模式，现在我们需要通过制定模式来识别对应的词法单元。下面是大部分词法单元，以及对应的模式： 词法单元 模式 digit [0-9] digits digit+ number digits(.digits)?(E[+-]?digits)? letter [A-Za-z] id letter(letter,digit)* if if then then else else relop &lt;,&gt;,&lt;=,&gt;=,==,!= ws(空白符) (blank,tab,newline)+ 由于这块儿markdown解析的问题（加了转义字符之后依然显示有点问题），我将”|”替换为”,”。在理解的时候只需要将”,”更改为”|”即可。 上表中的词法单元ws和其他词法单元不同。当我们识别到ws时， 我们并不将它返回给语法分析器，而是从这个空白符之后的字符开始继续进行词法分析。返回给语法分析器的是下一个词法单元 。 我们从前面的知识了解到，词法分析器通过对应模式识别到词法单元之后，会将词法单元名返回给语法分析器（空白符除外），以及对应词法单元的属性来确定某一特定实例。下表展示了对应词法单元，和对应属性： 词素 词法单元名字 属性值 任何空白符 - - if if - else else - id id 指向符号表条目的指针 number number 指向符号表条目的指针 &lt; relop LT &gt; relop GT … … … != relop NE 表格里面的relop词法单元，区分其具体实例是通过对应词法单元属性值进行。 这一节主要是了解了词法单元相关知识其中，包括有词法单元、词素和模式。为了能够了解模式，我们又学习了一下正则表达式。下一节则主要是讲解词法单元的识别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Malloc Tutorial]]></title>
      <url>%2F2019%2F02%2F17%2Fa_malloc_tutorial%2F</url>
      <content type="text"><![CDATA[前言本篇文章是对该文章的翻译，如有疑问可对照原文。 一、介绍什么是malloc？如果连这个名儿都没有听说的话，那么应该在读这篇文章之前先去学习一下Unix环境下的C语言。对于程序员来说，malloc是在C语言编程中分配一块内存的函数，然后大多数人并不知道其背后的真实情况，或者仅仅是认为这是一个syscall或者语言关键字。这篇文章中只需要一些C的技能和一些系统知识，就能了解到malloc也只不过是一个简单的函数而已。本文的主要目的是编写一个简单的malloc函数，来帮助我们了解底层概念。其目的并不是为了实现一个高效的malloc，仅仅提供基础功能。但是背后的概念能够帮助我们有效地去理解进程中内存是如何管理的，以及如何处理块的分配，再分配以及释放等等。站在教学的角度来说，这是一个很好的C语言编程练习。同样也是一个很好文档，它能够帮助我们理解指针怎么来的，它们在堆里面是怎样组织起来的。 malloc是什么12#include &lt;stdlib.h&gt; void *malloc(size_t size); malloc是一个标准C库函数，用于分配内存块。它遵循以下规则： malloc至少要分配请求字节大小（size）内存； malloc的返回的指针，指向一个已分配的内存（比如一个在编程时可读或者可写的空间）； 在该指针没有被释放之前，其他任何的malloc调用都不会分配该空间或者该空间中的任何一部分； malloc应该能很好处理，而且能够很快执行结束； malloc需要提供重新设置大小或者释放的能力； malloc函数返回的指针在失败或者没有可用内存空间的情况下为NULL。 二、堆和brk、sbrk系统调用在编写malloc之前，我们需要理解内存在多任务系统中是如何管理的。由于具体实现依赖于操作系统的实现细节，下面提到的内容更多是基于抽象的概念来进行阐述。 进程的内存每个进程都有它自己的虚拟地址空间，由MMU（内核）提供从虚拟地址空间到物理地址空间的转换。而该空间被分为多个部分，比如用户存储局部变量和volatile变量的栈，还有存储常量和全局变量的空间，以及用于存储程序数据，称为堆的散乱空间。 就虚拟地址而言，堆是一个连续的内存空间，它有三个划分的边界：起始点、最大值和称一个为break的终点。最大值的管理可以调用(原文中写成了sys/ressource.h)里面的setrlimit和getrlimit。break用于标记已映射内存空间的尾部，已映射内存空间指的是已经和实际内存一一对应起来的那部分虚拟地址空间（我的理解也就是对应的PTE里面有效位应该是为1，更或者TLB有对应的缓存的Page）。下图展示了内存组织的形式： 为了能够编写malloc函数，我们需要知道堆（heap）的开始位置和break的位置。当然我们还需要有能力去移动break，可以使用brk和sbrk系统调用来实现。 brk和sbrk我们可以在他们的手册（比如man brk）里面找到关于这些系统调用的描述： 12int brk(const void *addr);void *sbrk(int incr); brk函数通过传入的 addr 来设置brak的值，成功返回0，失败返回-1。使用全局errno来指明错误的原因（错误码对应的错误信息可以在\中查看）； 而sbrk通过传入的增量（以字节为单位）来移动break的位置。基于不同系统的实现，其返回值可能会返回老的地址，也可能返回移动之后新的地址。如果函数调用失败则返回-1，并且设置errno的值。在有些系统上sbrk支持传入一个负数用于释放那些已被映射的地址空间。 由于sbrk没有规范其返回值的意义，因此我们在 移动break的时候 不会去使用它返回值。但是我们可以使用特定情况下的sbrk，当调用sbrk其增量为0时，它的返回值就是实际的break地址（也就是老的地址和新的地址是同一个值）。因此sbrk用于获取堆的开始位置，也就是break的初始位置（上图中mapped Region长度为0的时候，也就是break的初始位置）。 因此我们将使用sbrk作为我们主要的工具。而我们的目的是在需要更多空间的情况下，我们要做的就是获取更多的资源来满足需求。 未映射区域和无人区（No-Man’s Land）我们看一下早期break标记已映射虚拟地址空间结束点的原理：在访问break之前的区域时会触发一个总线错误。在break点和最大限制（rlimit）之间的空间，系统（MMU和内核部分）是没有将物理内存和虚拟内存关联起来的。如果知道一点关于虚拟内存的知识的话，应该清楚内存是通过页的方式来进行管理：物理内存和虚拟内存通常情况下以固定大小的页面进行组织，而页的大小在实际系统中通常为4096Byte（4KB）。因此break点可能并不是在整页的边界上。说点题外话，在《现代操作系统》中介绍缺页处理程序是通过懒加载的方式来将物理内存和虚拟内存联系起来的。不考虑TLB的情况下，MMU是将VPN和PPN通过PTE来进行映射的 图二相比于图一，我们增加了页面边界的表示。可以看到break并没有和页边界吻合对应起来。那么处于break和下一页边界之间的内存是什么状态呢？实际上，这一段空间是可用的，我们可以对这段空间进行读写操作。但问题在于我们没有办法知道下一页边界的任何头绪，它的实现是非常依赖于特定系统的，所以对于可移植性来说，不建议这么去做。 无人区（no-man’s land）可能是大部分BUG的根源：在堆外面进行错误地指针操作时，对于小规模测试大部分时间是可以成功的，但是在更大量数据的时候该操作就会出现失败。 mmap尽管在这个教程中我们并不会使用它，但是我们应该要注意到mmap系统调用。mmap大部分情况用于将文件和内存映射起来，但是它可以以匿名模式来实现malloc（在某些特定情况下）。匿名模式下的mmap可以分配指定数量的内存（以页面大小为单位），munmap可以释放掉它们。使用这种方式实现的malloc相较于传统基于sbrk实现的malloc通过更加简单。 有些malloc使用mmap来实现大内存的分配（超过一页的大小）。OpenBSD的做法是使用mmap并搭配一些奇技淫巧来增加安全性（页与页之间在分配的时候增加边框来进行分配。这里翻译不太顺，加边框的意思是在页的边界处使用额外的空间来达到整页使用的效果，想象卷积的时候增加padding来读取矩阵左上角的数据。如果翻译有问题请联系我）。 三、Dummy malloc首先，我们会使用sbrk来假设一个malloc。这个版本的malloc可能是最差的一个，甚至是最简单的一个。 原理思想很简单，每次在调用malloc的时候，我们根据请求的空间大小来移动break，并且返回break之前的地址。这样做的确够简单，也够快。。。它仅仅只需要三行代码。但是这样的话我们没法去实现一个真实的free，当然realloc同样也不行。 这个版本的malloc会浪费很大一部分用过的内存块儿。在这儿只是出于科普的目的来指出如何sbrk系统调用，同样还将为malloc添加一些错误管理。 实现123456789void *malloc(size_t size)&#123; void *p; p = sbrk(0); /// 如果sbrk失败，返回NULL if (-1 == sbrk(size)) &#123; return NULL; &#125; return p;&#125; 四、组织堆（Organizing the Heap）在上一节我们写了第一个版本的malloc函数，但是并没有满足我们所有的需求（前面提到的free和realloc）。在这一节我们会尝试找到一个高效组织heap的方案，其中包括了malloc、free和realloc。 我们需要什么如果我们在编程上下文之外思考问题，能推断出在解决这个问题的时候我们需要哪些信息吗？来看个比喻：你拥有一片农场，并将他们划分成很多块农田区域出来。将这些分块的农田出租出去。租户希望租用连续的，但不同长度的农田（这里只使用长度这个维度来划分，不考虑面积）。当租户使用完成之后将其租用农田归还，以便下次继续向外出租。 在农场边提供了用于行驶“可编程”车的道路：输入距离开始点的偏移量和目的地（目的地是一块不是一个点，所以这里表达的是该块的开始点位）。因此我们需要知道每一块的开始点在哪儿，而且当我们处于某一块的起始点的时候，我们还需要知道下一块的地址。 其中一个解决方案是在每一块农田的开头部分放入一个标签来标明下一块的地址（和当前块的大小以避免不必要的计算），当租户将农田资源归还的时候，在空闲区域添加一个标记。好了，现在当租户想要固定大小农田的时候，我们可以带着他行驶在一处一处的标签那儿去。当我们发现一块标记为可用状态的农田，并且足够交付租户需求的时候，我们将该空闲标记从标签中移除。但是如果到达最后一块农田（也就是标签中没有下一个农田的地址），我们只需要到达该区域的末尾并添加一个新的标记。 现在我们将这个比喻转换到内存： 我们需要在每一块开始部分存储额外的信息，包括每一个块的大小、下一个块的地址、以及是否空闲等信息。 如何表示块信息我们需要在每一个大块（chunk）的开始部分包含一小段（block）用于容纳额外信息，这一小段我们成为“meta-data”；该段至少包含了下一块的指针、用于空闲块的标记、以及该块数据大小。当然，该段信息是在mallc函数返回的指针之前。 图三展示了一个堆组织的例子，含有已分配段前面的meta-data。 每一个大块（chunk）由数据块和meta-data组成，malloc函数返回的指针在上图下面由红色标记出来，需要注意的是该指针是指向的数据块，并不是完整的大块（chunk，不是指向meta-data的起始点）。现在我们需要怎样来把这些用C代码表示出来呢？这个看起来像传统的链表（实际上就是个链表）。我们编写一个链表类型，该类型成员用来表示所需的信息。我们使用 typedef来简化结构类型： 123456typedef struct s_block* t_block;struct s_block &#123; size_t size; t_block next; int free;&#125;; 在这儿看起来使用int型的free标记有点浪费空间，但由于struct默认是内存对齐的，因此它不会改变任何内容，稍后我们会看到如何缩小meta-data的大小。后续我们会看到malloc返回的地址必须是内存对齐的地址。这儿出现最频繁的问题是：我们如何在没有malloc的情况下去创建一个struct？答案很简单，我们只需要知道struct实际上是什么。在内存中，struct只是将一块儿区域结合了起来，所以结构s_block仅仅只是12字节（对于32位整型来说）。size字段对应前面的4字节，接下来的4字节是指向下一个block的next指针，最后4个字节是一个整型的free标记。当编译器遇到访问结构的域时（比如s.free或者p-&gt;free），将其转换为该结构的基地址加上该域之前长度的和。比如：p-&gt;free就是((char )p+8)，s.free就是((char )&amp;s+8)。我们所需要做的就是使用sbrk分配足够的空间块（包含了meta-data的大小和数据块的大小），并将老的break放入t_block类型的变量内： 12345678/* Example of using t_block without malloc */t_block b;/// 使用b保存老的breakb = sbrk(0);/// 添加所需空间/// size变量是malloc函数的参数sbrk(sizeof(struct s_block)+size);b-&gt;size = size; 五、首次适配策略的malloc“首次适配”是我采用《深入了解计算计算机系统》的翻译词。在这一节我们将会实现经典的首次适配策略的malloc函数。首次适配算法很简单：我们只要找到了一个空间大小足够满足请求分配的时候就停止遍历其他的块（chunk）。 指针对齐通常情况需要将指针和整型大小对齐（即 指针大小就是一个整型的大小）。此处我们只考虑32位的情况，所以指针是4的倍数（32bit = 4 byte，那当然是4的倍数）。因此我们的meta-data已对齐，我们仅仅需要做的只是去对齐数据块的大小。那我们该怎么做呢？这儿有几种方式，最有效的方式是使用算术技巧添加预处理宏。首先，算术技巧：给定任意正整数除以4，然后再将它乘以4得到最接近4的倍数。因此为了获得最接近且大于它时，只需要乘以4，然后在此基础上加4。这种方式的确很简单，但它没办法很好地工作在本身就是4的倍数上，结果会变成4的倍数的下一个（由于加了4）。再来使用一次算术，假设x是整型，并且满足： 1）、如果x是4的倍数，那么q = 0，并且满足： 运用上面说的，先除以4，然后乘以4，最后再加上4： 在这个推算过程是将上面x-1的表示用p来进行表示。这里需要注意一点的是，在整型除法中3/4结果为0； 2）、如果x不是4的倍数，此时q != 0： 同样运用上面的，先除以4，然后乘以4，最后再加上4： 因此，公式 _(x-1)/4 * 4 + 4_ 的结果是最接近并且大于或者等于4的倍数。 那么我们在C里面该怎么做呢？首先，注意到除法和乘法我们可以使用右移和左移移位操作符来解决（&gt;&gt;和&lt;&lt;），它们相对于简单乘法要快很多。因此我们的公式在C里面可以写成这样 ((x-1)&gt;&gt;2)&lt;&lt;2+4，但是在宏里面需要使用额外的括号： 1#define align4(x) (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4) 寻找块：首次适配算法找到一个足够长度的块非常简单：从堆的起始点开始（以某种方式会保存在代码，后续会看到）测试当前块，如果该块成功适配则返回该块的头部，否则继续向下一块寻找，直到最后一个块的头部。这里唯一的技巧是需要保存上一次遍历过的块，所以当没有找到合适的块的时候，malloc函数可以很轻松地去扩展堆的尾部（长度）。代码逻辑很直接，base是一个全局指针变量，指向堆的开始位置： 12345678t_block find_block(t_block *last, size_t size) &#123; t_block b = base; while (b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) &#123; *last = b; b = b-&gt;next; &#125; return b;&#125; 这个函数会返回一个合适的块，或者返回NULL（在没有找到的情况下）。函数执行后，last指针指向上一次访问过的块。 扩展堆现在，并不能总是找到合适的块，有时候（特别是最开始使用malloc函数）需要去扩展堆。实现同样很简单：移动break，并初始化新的block。当然还需要更新堆中上一个块的next域。在后续开发过程中需要知道struct s_block的大小，所以在这儿定义一个宏： 1#define BLOCK_SZIE sizeof(struct s_block) 下面代码没有什么可惊讶的，仅仅只是当sbrk失败之后返回NULL（没必要想这么做的原因）。注意，前面提到过我们不能确信sbrk函数返回的上一个break，因此我们首先保存break值，然后移动它。我们需要使用last和last-&gt;size来进行计算： 123456789101112131415t_block extend_heap(t_block last, size_t size)&#123; t_block b; b = sbrk(0); if ((void *)-1 == sbrk(BLOCK_SZIE+size)) &#123; /// sbrk失败 return NULL; &#125; b-&gt;size = size; b-&gt;next = NULL; if (last) &#123; last-&gt;next = b; &#125; b-&gt;free = 0; return b;&#125; 拆分块（block）注意到我们寻找首个可用的块，但并没有管它的大小（足够大）。假想一下，如果只需要2byte的大小，但是找到的块是256byte的，如果这样做会丢失很大一部分的空间。第一个解决方案是拆分块：当一个块足够宽到请求的大小加上一个新块大小（至少BLOCK_SIZE+4），那么向链表中插入一个新块。 下面的函数（split_block）会在空间可用的时候被调用。提供的大小(参数size)必须要是对齐的。在这个函数中我们会做一些关于指针运算，为了防止错误，我们将使用一些小技巧来确保我们所有的操作都以一个字节的精度完成（需要注意一下p+1是依赖于p的类型的，也就是不同类型指针加一的步长不一样）。我们只需要在struct s_block中添加一个字符数组的域。结构体中添加数组很简单：数组直接定义在结构的内存块中，因此数组指针的作用是指向meta-data的尾部。C禁止长度为零的数组，那么我们就定义个一字节长的数组： 123456struct s_block &#123; size_t size; t_block next; int free; char data[1];&#125;; 并且需要更新一下宏BLOCK_SIZE的值，由于扩展了s_block的data，如果还是使用sizeof的话将会把data字段也算进去。所以这里需要将BLOCK_SIZE固定位12字节（注意，现在说的32位整型）： 1#define BLOCK_SZIE 12 这里我说一下这里加了一个data域，为什么BLOCK_SIZE要设置为12，不随sizeof(struct s_block)呢？前面也说过结构只是把内存里面的各个字节赋予了含义而已，我们只是想把12字节认为是meta-data，而并不是硬生生得塞了一块数据到meta-data和数据块之间。加这个域只是为了我们在拆分block的时候方便，不加这个域同样也是可以操作的。 增加了这个扩展之后，并不需要明确为之前 extend_heap函数适配新增的data域。函数split_block：会根据传入的参数来拆分为所需大小的块。图四展示该函数的相关操作： 1234567891011121314/// 参数s必须要对齐的void split_block(t_block b, size_t s) &#123; if (!b) &#123; return; &#125; t_block new; new = b-&gt;data + s; new-&gt;size = b-&gt;size - s - BLOCK_SZIE; new-&gt;free = 1; new-&gt;next = b-&gt;next; b-&gt;size = s; b-&gt;next = new;&#125; 注意代码b-&gt;data+s，由于data域时char[]类型，所以我们能够精确地控制是以字节的步长进行增加。 malloc函数现在我们可以开始写malloc函数了，它主要是将前面讲到的函数封装起来。我们必须要将请求的size对齐，并测试是否是第一次调用malloc函数，以及已告知其余所需的条件。在上一节的find_block函数中使用了一个全局变量 base，下面是该变量的定义： 1void *base = NULL; 它是一个void *类型的指针，并初始化为NULL。在malloc中我们首先要做的就是判断base是否为NULL？如果为NULL那么就表示第一次调用malloc函数，否则就是用前面提到的相关算法。 malloc函数需要具备下面几行中的特性： 首先需要对齐请求的大小； 当base已经初始化： 搜索足够大小的空闲块； 如果找到该块的情况下： 尝试着去拆分该块（请求的大小和块的大小足够存储meta-data和最小块数据，比如4byte）； 标记该块为已是用(b-&gt;free = 0)； 否则：扩展堆；注意在find_block函数中使用的last指针，它用于记录上一次访问过的块（chunk），因此当我们在扩展块的时候就不用再重新去遍历整个链表。 否则：扩展堆（空指针）。注意此时工作在extend_heap函数时last=NULL。 也需要注意在每次失败之后，我们按照预期指定的malloc函数返回NULL。 1234567891011121314151617181920212223242526void *malloc(size_t size)&#123; t_block last,b; size_t align_size = align4(size); if (base) &#123; last = base; if ((b = find_block(&amp;last, align_size))) &#123; if (b-&gt;size - align_size &gt;= (BLOCK_SZIE + 4)) &#123;/// meta-data + 4 split_block(b, align_size); &#125; b-&gt;free = 0; &#125;else&#123;///查找heap失败，extend heap b = extend_heap(base, align_size); if (!b) &#123; return NULL; &#125; &#125; &#125;else&#123;///首次调用malloc函数，extend heap /// base = null; b = extend_heap(base, align_size); if (!b) &#123; return NULL; &#125; base = b; &#125; return b-&gt;data;&#125; 六、calloc, free和realloc函数calloc函数calloc函数： 首先调用malloc函数，并分配正确的大小； 将块里面的每一个字节设置为0； 这里使用一个小技巧：chunk中数据块的大小总是4的倍数，所以我们以4字节的步长进行迭代。因此我们把new指针当做无符号整型的数组： 123456789101112void *calloc(size_t number, size_t size) &#123; size_t *new; size_t s4,i; new = malloc(number*size); if (new) &#123; s4 = align4(number*size)&lt;&lt;2; for (i = 0; i &lt; s4; i++) &#123; new[i] = 0;/// new为size_t，所以这里+1的步长为size_t的字节数，在32位整型下面，size_t为4字节 &#125; &#125; return 0;&#125; free函数注：在下文提到的块在原文中的描述如果没有特殊注明均为chunk，而非在malloc一节大量使用的block。 快速实现free是很简单的，但简单并不意味着很方便就能完成。我们有两个问题：找到被释放的块，并且防止出现空间碎片。 碎片：malloc函数遗留问题malloc函数的一个重大问题是碎片：在多次使用malloc和free之后，堆被划分为许多块，这些块已经小到足够满足大的malloc，直到整个可用空间使用。这就是空间碎片的问题。在这个算法中我们虽然没有办法避免出现额外的碎片，但可以避免其他来源的碎片。当我们选择的空闲块足以容纳请求分配的量和另外的块时，我们会拆分当前块。在提供更好地内存使用率（新的块为空闲状态以备后用）的同时也引入了更多的碎片。解决碎片化的一个问题就是空闲块。当我们释放一个块时，如果临接的块同样是空闲状态时，我们合并他们成一个更大的块。在这儿我们所有需要的就是去测试前面块和后面块的状态。那么如何去获取之前的块（block）呢？下面有几个解决方案： 从头开始搜索，但非常慢（特别是我们已经搜了一些空闲块之后，再从头搜索）； 当我们搜索到当前块的时候，使用一个指针指向上一个访问的块； 双链表； 我们选择最后这个解决方案，该方案非常简单地去跟踪目标块。所以我们再一次去修改struct s_block（第一次修改是malloc的时候增加的data成员）。但由于我们还有另外一个待修改的地方（下一节），因此先不急着做修改。 所以我们现在要做的就是合并，我们先写一个简单的合并函数来合并块。在下面的代码中我们会用一个 prev域来作为直接前驱： 12345678910t_block fusion(t_block b) &#123; if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) &#123; b-&gt;size += BLOCK_SZIE + b-&gt;next-&gt;size; b-&gt;next = b-&gt;next-&gt;next; if (b-&gt;next) &#123; b-&gt;next-&gt;prev = b; &#125; &#125; return b;&#125; fusion函数很直截了当：如果下一个块是空闲块，那么就将当前块的size和下一个块的size，以及meta-data的大小。然后将next域指向当前变量后继的后继（b-&gt;next-&gt;next），此时如果当前的后继存在，那么久更新该后继的直接前驱（b-&gt;next-&gt;prev）。 找到正确的块关于其余释放带来的问题是如何高效地寻找由malloc函数返回的正确的块。实际上，这儿存在几个问题： 验证输入的指针（它是否真的是一个malloc指针）； 找到meta-data指针； 我们可以通过quick range test来消除无用的指针：如果该指针在堆外，那么它肯定不是一个有效指针。那么剩下的case和上一个case相关，我们如何确定该指针是由malloc函数获得？其中一个解决方案是在结构内使用一个魔数（magic number）。相对于魔数更优的一个方案是我们可以使用一个指针指向它自己。解释一下：我们有一个ptr域指向data域，如果b-&gt;ptr == b-&gt;data的时候，那么该指针大概率是有效块（block）。下面是扩展之后的结构，以及访问和校验给定的指针是否为相应的块（block）： 1234567891011121314151617181920212223242526typedef struct s_block* t_block;struct s_block &#123; size_t size; t_block next;/// 后继 t_block prev;/// 前驱 int free; void *ptr; char data[1];&#125;;t_block get_block(void *p)&#123; char *tmp; tmp = p; tmp = tmp-BLOCK_SZIE; p = tmp; return p;&#125;int vaild_addr(void *p) &#123; if (base) &#123; if (p &gt; base &amp;&amp; p &lt; sbrk(0)) &#123;/// sbrk(0)是获取当前break线，结合前面提到的图 return p == (get_block(p)-&gt;ptr); &#125; &#125; return 0;&#125; 实现free函数free函数到现在也渐渐揭开了神秘面纱：验证指针的正确性，并找到相应的块，然后将其标记为空闲块，最后如果有必要就进行合并操作。释放内存时，当我们处于堆的尾部，我们需要调用一下brk函数来调整break先到当前块的位置处。下面的代码展示具体实现，大致的逻辑如下： 如果指针有效： 获取block块的地址； 标记为空闲状态； 如果当前节点的直接前驱是空闲的，那么就合并两个块； 继续尝试合并直接后继块； 如果当前处于最后一个块，那么我们释放内存； 如果这儿没有更多的块了，那我们重置为原始状态（base设置为NULL）； 如果该指针不是有效指针的话，我们就什么也不做； 12345678910111213141516171819202122void free(void *ptr) &#123; t_block b; if (vaild_addr(ptr)) &#123; b = get_block(ptr); b-&gt;free = 1; /// 如果可以合并直接前驱 if (b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free) &#123; b = fusion(b-&gt;prev); &#125; /// 合并直接后继 if (b-&gt;next) &#123; fusion(b); &#125;else&#123; if (b-&gt;prev) &#123; b-&gt;prev-&gt;next = NULL; &#125;else&#123; base = NULL; &#125; brk(0); &#125; &#125;&#125; 使用realloc重置块的大小realloc函数和calloc函数差不多一样直接。基本上我们只需要一个内存拷贝的操作，在这里我们不使用里面的memcpy我们可以写一个更好的（大小以块为单位，并且已经对齐）。拷贝函数如下： 12345678910void copy_block(t_block src, t_block dst) &#123; int *sdata; int *ddata; size_t i; sdata = src-&gt;ptr; ddata = dst-&gt;ptr; for (i = 0; src-&gt;size &gt; 4*i &amp;&amp; dst-&gt;size &gt; 4*i; i++) &#123; ddata[i] = sdata[i]; &#125;&#125; 按照下面的做法可以实现一个非常幼稚（但是能工作）的realloc函数： 使用malloc根据指定的大小分噢诶一个新块； 将数据从旧内存数据复制到新内存地址处； 释放旧内存中的数据； 返回指向内内存地址处的指针； 当然我们还想做一点事儿让realloc函数更高效一点。当我们有足够的空间的时候，此时并不需要去分配新的空间。因此不同点有： 如果大小未发生变化，或者额外可用大小足够使用，那么我们什么也不做； 如果需要收缩块，那么拆分该块； 如果下一个是空闲块而且提供了足够的空间，如果需要的话我们可以合并或者拆分这些块； 下面是realloc函数的具体实现： 1234567891011121314151617181920212223242526272829303132333435void *realloc(void *p, size_t size) &#123; if (NULL == p) &#123; return malloc(size); &#125; size_t s; t_block b, new; void *newp; if (vaild_addr(p)) &#123; s = align4(size); b = get_block(p); if (b-&gt;size &gt; s) &#123; if (b-&gt;size &gt;= s+BLOCK_SZIE+4) &#123; split_block(b, s); &#125; &#125;else&#123; if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free &amp;&amp; (b-&gt;next-&gt;size + b-&gt;size + BLOCK_SZIE) &gt;= s) &#123; fusion(b); if (b-&gt;size - s &gt; BLOCK_SZIE+4) &#123; split_block(b, s); &#125; &#125;else&#123; newp = malloc(s); if (!newp) &#123; return NULL; &#125;else&#123; new = get_block(newp); copy_block(b, new); free(p); return newp; &#125; &#125; &#125; &#125; return p;&#125; 别忘了realloc(NULL, s)是可以直接提到malloc(s)的。 FreeBSD中reallocf函数FreeBSD提供了另外一个realloc函数的实现：reallocf，它会在任何情况下释放输入的指针（即使是再分配失败之后）。我们一样会调用realloc函数，但是只有我们在获得空的指针之后才会调用free函数。下面是具体的实现部分： 1234567void *reallocf(void *p, size_t size) &#123; void *ptr = realloc(p, size); if (!p) &#123; free(p); &#125; return ptr;&#125; 到这儿基本翻译完成，如有错误请及时来联系我，谢谢❤️]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细看objc-weak源码]]></title>
      <url>%2F2018%2F05%2F18%2Fsource_code_objc_weak_t%2F</url>
      <content type="text"><![CDATA[本文不看其他，只专注于weak的内部结构实现细节和源码解读，看了网上很多的文章都是贴上一篇open source里面的代码，并没有对实现细节进行解释。所以在这篇文章中，主要分为weak_entry_t、weak_table_t的源码解析，weak_entry_t和weak_table_t的相互关系，以及对应的操作函数。 下文的主要是基于两个对象来说的，一个是被引用的对象，一个是弱引用变量（也就是源代码中大量出现的指向指针的指针）。 我说一下我源码阅读的习惯，先把目光放在头文件中，因为头文件能够给我们一个整体基础结构。弄清楚具体的结构之后，然后再跳到实现文件中去看具体的实现细节。先交代一下我的编译环境和源代码版本： 编译环境：Apple LLVM version 9.1.0 (clang-902.0.39.1)Target: x86_64-apple-darwin17.5.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin源代码版本： objc4-723 头文件类关系和结构分析我先根据头文件画一个基本的UML类图： DisguisedPtr模板类先将视线放在weak_entry_t上面，结构weak_entry_t的第一个成员变量是referent，它是一个DisguisedPtr类模板实例化之后的变量（点开前面的链接吧，不然我讲不清楚，不然你会骂我的），这个成员其实就是保存被引用的对象。DisguisedPtr类里面看起来这个类并不复杂，有一个uintptr_t类型的成员变量，由此DisguisedPtr类的对象所占用的内存空间大小也应该为8字节。public下面主要是构造函数加三大函数中的两个：重载复制运算符，赋值构造函数；由于该类里面并没有涉及到动态new指针变量，所以其析构函数便使用了默认析构函数。除此之外还重载一些其他的操作符。主要看一下私有的两个成员函数： 123456static uintptr_t disguise(T* ptr) &#123; return -(uintptr_t)ptr;&#125;static T* undisguise(uintptr_t val) &#123; return (T*)-val;&#125; 其中disguise函数是将指针变量强转为uintptr_t的整形变量，具体怎么伪装呢？就是把该指针指向的内存地址（16进制数据比如：0x7ffeefbff4e8）强制转换为无符号长整型的十进制数据。由于其类型是无符号长整型，因此取负数是数据溢出之后取该类型取值范围内较大的长整型值达到伪装的效果（也就是不好去找到原内存地址）。 123456unsigned long ul_val = 2;unsigned long*bitl = &amp;ul_val;cout&lt;&lt;&quot;ul_val address: &quot;&lt;&lt;bitl&lt;&lt;endl;///0x7ffeefbff4e8///140732920755432 取负数 -&gt; 18446744069408184208cout&lt;&lt;&quot;disguise: &quot;&lt;&lt;disguise(bitl)&lt;&lt;endl;cout&lt;&lt;&quot;undisguise: &quot;&lt;&lt;undisguise(*bitl)&lt;&lt;endl;/// 0xfffffffffffffffe 1111...1110 其作用在源文件的注释中也说了，我通俗总结是：对那些比如leak这种内存检测工具进行伪装，然后这些检测工具可能就不好去跟踪被引用的对象。 weak_entry_t现在来看一下union的具体内存分布细节，怎么来解释这个问题呢？奉上objc-weak.h的源码，打开源码配合文章来看。 12345678910111213union &#123; struct &#123;/// 为了方便说明问题，我将该结构取名为：struct1 weak_referrer_t *referrers; uintptr_t out_of_line : 2; uintptr_t num_refs : PTR_MINUS_1;/// num_refs记录的是实际引用数量 uintptr_t mask;/// 记录当前referrers数组容器的大小 uintptr_t max_hash_displacement;/// 根据hash-key寻找index的最大移动数，这个在后面的append_referrer会讲 &#125;; struct &#123;/// 为了方便说明问题，我将该结构取名为：struct2 // out_of_line=0 is LSB of one of these (don&apos;t care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;;&#125;; 首先要有一个概念，union里面的多个成员是共享同一且相同大小的内存空间，在strcut1结构成员中算出其总共所占内存大小为64*4，也就是32个字节。其中我的机器是64位机，我的编译器对于指针类型所占内存大小的ABI实现为64位，而无符号长整型占用的内存大小也为64位。多说一句，在C++中结构和类的内存存储区域好像都是在堆上面，由低地址向高地址生长。基于此来画出inline_referrers和上面第一个结构大致的内存分布样式（关于inline_referrers的元素类型模板类DisguisedPtr所占内存大小在上面讲DisguisedPtr类时提到了）：在源码中注释也说了： 12345// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00// (disguised nil or 0x80..00) or 0b11 (any other address).// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state. out_of_line_ness是和inline_referrers[1]的低2位是等同的，out_of_line_ness和num_refs使用了位段，一共占用64位（2位和62位）。由于此时已经是结构内存对齐了，所以下一个结构成员mask的内存地址就刚好换行。上面还提到的0x0b10，它应该是经过DisguisedPtr伪装之后得到的值，并不是实际的等于0b10，一个只占两位内存空间的，怎么也存储不了16位的数据。out_of_line_ness == 0b10是标记使用out-of-line的状态。关于这个0b10我没有想清楚它的由来，有知道的同学麻烦告知于我！！！继续来看该结构的构造函数： 12345678weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent)&#123; inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; inline_referrers[i] = nil; &#125;&#125; 在创建weak_entry_t实例的时候，默认是使用inline_referrers的方式来管理对象引用的，并把其余的位上的数据清空。out_of_line_ness用来判断使用out_of_line的方式来进行引用管理，这个out_of_line_ness的值主要是依据于被引用的对象，其引用变量的个数决定的，具体的逻辑在下文会讲到。再看看struct1的referrers成员，看起来是一个指针变量，更具体的说是存储的引用变量数组的起始地址，而这些引用变量指针指向的地址被DisguisedPtr进行了伪装。 到这里我把weak_entry_t的内存分布讲了一遍（具体的含义在上面代码块中的注释里），然后下面来看一下weak_table_t。 weak_table_tweak_table_t在头文件中看不出什么特别的内容，但是从源码中可以看出，应该是一个基于C的结构，没有使用C++中结构独有的特性。 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries;/// 和weak_entry_t的num_refs概念类似 uintptr_t mask;///和 weak_entry_t的mask概念类似 uintptr_t max_hash_displacement;/// 和weak_entry_t的max_hash_displacement概念类似&#125;; 同样的，其weak_entries成员也应该是一个数组，存储着weak_entry_t变量的指针。针对该结构头文件中公开的操作函数有： 1234567id weak_register_no_lock(weak_table_t *weak_table, id referent, id *referrer, bool crashIfDeallocating);void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer);#if DEBUGbool weak_is_registered_no_lock(weak_table_t *weak_table, id referent);#endifvoid weak_clear_no_lock(weak_table_t *weak_table, id referent); 这看不了什么具体的内容，所以针对头文件的解读就到这里。下面去实现文件中看看具体的实现，看看网上为什么都在说的基于Hash表的一个存储结构。源码地址，老规矩，打开这个网页对照着源码来看。 objc-weak具体实现细节首先看两个hash函数： 12static inline uintptr_t hash_pointer(objc_object *key);static inline uintptr_t w_hash_pointer(objc_object **key); 它们会根据对象的指针（不管是指针还是指向指针的指针）调用一个fast-hash函数来生成一个key，其原理是基于fast_hash，而这个key的作用目前我们无从得知。 grow_refs_and_insert函数继续看源码，下面主要来看看一个很重要的函数： 12345678910111213141516171819202122232425262728293031__attribute__((noinline, used))static void grow_refs_and_insert(weak_entry_t *entry, objc_object **new_referrer)&#123; assert(entry-&gt;out_of_line); /** * #define TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0) * entry-&gt;mask用来记录referrers的数量 */ size_t old_size = TABLE_SIZE(entry); size_t new_size = old_size ? old_size * 2 : 8;/// 增长一倍的大小 size_t num_refs = entry-&gt;num_refs; weak_referrer_t *old_refs = entry-&gt;referrers; entry-&gt;mask = new_size - 1; entry-&gt;referrers = (weak_referrer_t *) _calloc_internal(TABLE_SIZE(entry), sizeof(weak_referrer_t)); entry-&gt;num_refs = 0; entry-&gt;max_hash_displacement = 0; /// 开始处理数据 for (size_t i = 0; i &lt; old_size &amp;&amp; num_refs &gt; 0; i++) &#123; if (old_refs[i] != nil) &#123; append_referrer(entry, old_refs[i]);/// 把老数据复制进新的entry里面 num_refs--; &#125; &#125; // Insert append_referrer(entry, new_referrer);/// 给entry插入新的数据 if (old_refs) _free_internal(old_refs);&#125; 由于基于C的数组其实都是定长的，为了能够动态地增加新元素就需要不断地去申请新的内存空间，并且还要是连续的内存地址（要是不连续的地址就去使用链表的方式，但是链表的索引明显弱于数组的）。正是因为新动态申请的连续内存空间，这就需要把老数据复制过来，并把需要新增的数据也追加进去，最后释放掉原内存空间：它其实和C++里面的动态数组的原理一样，为了不频繁地去申请（calloc）新的空间和频繁地数据移动。所以每次2倍增长来增加weak_entry_t的长度。为什么说是C++里面动态数组的做法，在《数据结构与算法实现-C++描述》里有提及这些内容。 append_referrer和remove_referrer在grow_refs_and_insert函数中调用了append_referrer函数，这个函数很明显是做插入操作的，默认使用inline的方式来增加新增的weak引用，如果使用inline的方式失败了，则是以outline的方式，并申请对应的存储空间，把entry-&gt;referrers指向新申请的内存地址，把inline_referrers数组里的数据拷贝到new_referrers中，其源码如下： 12345678910111213141516171819202122if (! entry-&gt;out_of_line) &#123; // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; // Couldn&apos;t insert inline. Allocate out of line. weak_referrer_t *new_referrers = (weak_referrer_t *) _calloc_internal(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[I]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = REFERRERS_OUT_OF_LINE; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0;&#125; 从这里就可以看出，当被引用对象的弱引用referrers个数小于WEAK_INLINE_COUNT时，其entry里面是以inline小数组方式来存储这些弱引用变量的，只有当inline_referrers全部装满之后，该entry out_of_line被设置为REFERRERS_OUT_OF_LINE，后续如若有变量继续引用该对象则是以outline的方式存储的。 union是在被引用变量的referrers个数小于等于WEAK_INLINE_COUNT时，使用inline数组的内存表现形式；当referrers个数超过了WEAK_INLINE_COUNT则以struct1的内存表现形式！ 由于使用inline的方式是使用小数组的方式，但是针对弱引用对象过多，那么它的存取性能就是考虑的一个重点。而散列是一种用于以常数平均时间执行插入、删除和查找的技术。下面这个过程我不是很确定，如有不同的建议希望指出。 123456789101112size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);size_t hash_displacement = 0;while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++;&#125;if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement;&#125;weak_referrer_t &amp;ref = entry-&gt;referrers[index];ref = new_referrer;entry-&gt;num_refs++; begin是通过引用new_referrer调用散列函数获取一个散列值，这个散列值就是散列表中的元素查找自己所在散列槽的key。从源码可以看出，通过散列值查找元素对应散列槽的方式好像是使用了线性探测法。简化上面的代码，配合下方这图来看一下把new_referrer指针查找正确index的过程：如上图，假设使用w_hash_pointer获取到的key为2，obj1成功插入到散列槽2中，obj2使用w_hash_pointer获取到的key也为2，此时散列槽2已经放入了obj1，那么只有正向地去寻找下一个散列槽，如果为空则放入obj2。回到源码中，在求begin值的时候。把hash值和entry-&gt;mask做了按位与的操作，但是这里为什么要对entry-&gt;mask做一次按位与操作呢？entry-&gt;mask存储着weak_entry_t的referrers数组大小，这样做能保证所得的散列值是小于当前数组的出界的，因为大于referrers数组大小对应的二进制位的高位全部被置为0，从而避免出现数组越界带来的问题。关于出界和入界的概念，可以在《C陷阱与缺陷》中关于一个介绍for循环越界导致的死循环一节，具体的记得不是很清楚了。针对出界这个概念还是蛮重要的，老板们可以去看一看。remove_referrer和append_referrer在源码上来看基本没有什么区别，区别只不过是一个赋值，一个置空而已。 weak_table_t的扩容和减容针对weak_table_t的扩容和减容源码相对来说比较简单，限于篇幅我没有提供对应的代码，所以在看的时候还麻烦自己打开上面提到的源码地址对照来看。在源码中主要提供了如下函数： weak_entry_insert；函数weak_entry_insert和上一节提到的append_referrer是类似的，weak_table_t的内部实现同样也是使用散列表的方式来管理所有的entry变量的。只是weak_entry_insert没有去尝试inline的那一步。 weak_resize；函数weak_resize和上面提到的grow_refs_and_insert函数类似，在调整大小时，都是创建一个新尺寸大小的内存空间，然后将原内存空间的数据移动到新的内存空间。weak_resize只有移动老数据，没有新数据的添加！最后释放掉原内存。 weak_grow_maybe；函数weak_grow_maybe是在原weak_table的entry数量大于了weak_table数组容量的3/4时，便调用weak_resize去扩充容量到原数组容量的2倍。 weak_compact_maybe；函数weak_compact_maybe是用来收缩容量的，当数组的容量内大部分都为空的话，则减容。 1234if (old_size &gt;= 1024 &amp;&amp; old_size / 16 &gt;= weak_table-&gt;num_entries) &#123; weak_resize(weak_table, old_size / 8); // leaves new table no more than 1/2 full&#125; weak_entry_remove；函数weak_entry_remove用来weak_table_t的entries里对应的entry 1234if (entry-&gt;out_of_line()) free(entry-&gt;referrers);bzero(entry, sizeof(*entry));weak_table-&gt;num_entries--;weak_compact_maybe(weak_table); sizeof(*entry)获取到了weak_entry_t所占用的内存大小，使用bzero是将该内存段全部置为0，使用bzero而不使用memset影响并不大，使用memset需要多传入一个参数来确定需要重置的值。在《Unix网络编程》里创建sockaddr_in结构变量时，把对应内存空间数据清空用到了bzero，并讲了一下和memset的区别，具体内容可以去看看这本书。 头文件暴露的四个函数在头文件中暴露了四个外部可用的函数，分别是：weak_register_no_lock、weak_unregister_no_lock、weak_is_registered_no_lock和weak_clear_no_lock，根据注释来看主要是针对weak_table_t的添加、删除和清空数据等操作。在这里以下面的代码为基础来讲解： 1__weak id refer = obj; 下面再来具体看看这几个函数在干什么？weak_register_no_lock源代码中提出，注册一个新的键值对，如果新的弱对象不存在则去新创建一个对应的entry。 1if (!referent || referent-&gt;isTaggedPointer()) return referent_id; 如果被弱引用指向的对象（obj）是isTaggedPointer，这里便不做相关操作，直接返回弱引用指向的对象（obj）。关于什么是Tagged Pointer，后面我再去细看一下里面的源码。从这里的源码可以看出，如果是TaggedPointer就不做后续操作，因为指针并没有指向真正的内存地址，返回的值则是被引用对象自身。 12345678weak_entry_t *entry;if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer);&#125;else &#123; weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry);&#125; 如果存在对应的entry则直接调用append_referrer进行插入。如果不存在，则调用weak_entry_t的构造函数创建一个新的对象，并查看是否需要针对weak_table进行扩容，将新的entry插入到weak_table中。下图是一个为对象增加弱引用，并将引用添加到weak_table中的简易流程： 现在来看一下weak_unregister_no_lock函数，针对weak_table的移除，必须确保entry已经存在于weak_table中，才会去进行后续的操作，同样把对应的流程图画出来：最后两个函数是一个是debug状态下用于判断某一entry是否存在于weak_table中，另一个函数则是对特定的被弱引用的对象（obj）的所有引用做清楚操作。 结语到这里objc-weak应该算是讲清楚了（天知道我的表达能力怎么样。。。），最后我从外层结构到内层结构来一一总结下：1、weak_table可以存储多个entry，而且它会根据其散列表中entry的个数来伸缩其所占内存大小；2、一个entry表示的是一个被弱引用的对象（上文提到的obj），该变量可以被多个变量弱引用（refer）。所以entry也存在一个散列表，其用来存储对应的弱引用变量的引用。也就是前面源码里面提到的指向指针的指针。3、entry的out_of_line_ness只有在弱引用变量大于WEAK_INLINE_COUNT时才会置为REFERRERS_OUT_OF_LINE。也就是只有在这时候union才会使用struct1结构内存布局。4、还有就是out_of_line_ness == 0b10没有看懂。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记一次LFU缓存实现]]></title>
      <url>%2F2018%2F01%2F17%2Flfu4cIniOS%2F</url>
      <content type="text"><![CDATA[这篇文章大多是我自己的基于iOS开发一个想法过程，实现并不难。不过我并不会贴出全部代码，天知道我组织文章的根据是什么，能看懂都是缘分。 前言讨论缓存时，都会分内存缓存和硬盘缓存，本文主要是基于内存缓存的，但是完全可以稍加改动便可以应用于硬盘缓存中。在做其他文件IO的时，会有很多情况会基于C。基于此，我选择了使用C来实现核心部分。而它的作用是主要用于WebView在内存中的缓存数据。 关于LFU的一些概念之类的东西就不说了，原理实现网上一大堆。基于自己单链表通过栈来实现LFU的方式实现一下，这不一定是最优解，也有可能是最差解。不管怎么说，先通过一个图阐述一下主要的数据结构： 多想一点儿东西在看了上图之后，首先的想法就是去把具体算法撸出来。但是在开动写代码之前，我们需要想的东西应该要更多。在面向过程的思想中想开来，使用栈的时候取出操作可以很快速的完成最快可以达到时间复杂度为O(1)，而在维护栈顺序的时候，最坏的时间复杂度为O(N)，其查找和位置更新是在同一个循环中完成的，避免了不必要的时间消耗。 加入到面向对象中显然用C来做业务逻辑开发始终有点儿蹩脚，所以得引入到面向对象中。我把这个类取名叫做PPWebFetchCache吧，既然都面向对象了，要不再弄点儿设计模式进去？考虑到易于操作性，对于PPWebFetchCache类，我做了一个单例，当然也可以自己生成一个对象。到了这里下面应该要想的就是对象的属性和操作方法等等事情，但是自己想着就用了一个单例模式这不是表明我设计模式很low吗？不过事实的确是这样，我没有什么好的设计模式拿出来~~~所以我就硬塞了一个简单工厂模式进去。它做什么呢？我想的是“现在只是做LFU，万一哪一天变化来了，让我用写一个LRU的缓存策略，那我不是死得很惨！”，所以我又创建了一个继承于PPWebFetchCache类的PPWebFetchLFUCache，和另一个用于将来实现LRU算法的PPWebFetchLRUCache类。并在最后给父类添加了属性maxMemoryCost、maxMemoryCountLimit和两个操作方法storeCacheInMemory、memoryCacheWithURL。 走进实现细节上面说的LFU是针对于某一个URL的使用次数。在思考如何使用最少时间拿到URL对应的数据时，显然散列表最理想的数据结构，而且在iOS中用散列表实现的代表便是Dictionary。所以大致的逻辑是： 使用NSDictionary来实现URL和数据一对一在内存中的存储。而LFU主要用于管理某一URL的使用次数，淘汰掉使用次数最少的URL，并在内存字典中删除对应的数据。 PPWebFetchCache对外暴露的接口只有存和取，而具体的加入和删除操作则是在内部通过maxMemoryCost、maxMemoryCountLimit控制实现。 异步环境显然在数据存取的时候，我们不应该放在主线程中去做这些事儿。因此我创建串行队列用来执行这些事务： 12345678910111213static dispatch_queue_t background_serialQueue()&#123; static dispatch_queue_t queue; if (!queue) &#123; char *const label = &quot;com.example.webprefetchCache&quot;; dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0); queue = dispatch_queue_create(label, attr); &#125; return queue;&#125;void async_inbackground(void(^block)(void))&#123; dispatch_async(background_serialQueue(), block);&#125; 为什么要用串行队列？因为在队列内部操作，我不需要关心会出现资源竞争的问题。而在串行队列以外其他队列中来操作单例的相关数据时，我就需要去关心的线程安全的问题。因此我直接使用适用于静态分配的的互斥量PTHREAD_MUTEX_INITIALIZER来保证数据的同步操作。反观如果我去使用pthread_mutex_init来动态生成一个互斥量的话，我还要操心什么时候去destroy掉它（当然这里得仔细思考造成死锁的问题）。 1234567891011static inline pthread_mutex_t mutext_lock(void)&#123; static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; return lock;&#125;static void safeProgressWith(void(^block)(void))&#123; pthread_mutex_t lock = mutext_lock(); pthread_mutex_lock(&amp;lock); block(); pthread_mutex_unlock(&amp;lock);&#125; 在加锁等操作时，尽量让其颗粒度更低。这样可以减少不必要的线程处于waiting状态，也就相应地减少出现低优先级线程饿死的情况发生（尽量减少CPU密集型线程的时间片）。 LFU的具体实现LFU只是针对于URL的淘汰策略，淘汰了URL之后，根据该URL到NSDictionary中找出对应的数据进行移除。这里使用链表的方式实现栈结构，其结构如下： 123456typedef struct __PPWebLFUFetchInlayerNode_ * _PPWebLFUInlayerNodeRef;typedef struct __PPWebLFUFetchInlayerNode_ &#123; char *url; int use_count; _PPWebLFUInlayerNodeRef next;&#125;_PPWebLFUFetchInlayerNode; 在PPWebFetchLFUCache类中保存了一个_PPWebLFUInlayerNodeRef的指针，这个指针指向栈顶： 123@interface PPWebFetchLFUCache:PPWebFetchCache&#123; _PPWebLFUInlayerNodeRef _lfuStack;&#125; 走到这里我们大可以直接使用_lfuStack成员变量来对栈进行相应的操作，但是我们可以更进一步！这里思维跳跃一下，当我们在插入一个节点时如何去判断当前节点是新增节点、还是存在于栈中的节点、抑或是需要删除的结点？如果只是简单的回答“我在插入节点时，先遍历一遍栈看元素是否存在于其中”，这样做毫无意义，而且平添一倍的时间消耗，因为后面的插入操作时，还要去遍历一次找到对应的节点位置。为了能够更好地在同一个循环中处理插入数据，查找数据，删除数据等操作。这里需要在执行C操作时在适当地点给我们回调，让我们有机会在一次循环中做完这些操作。为什么要用回调呢？我们完全可以把删除的相关逻辑放在某一次循环中，这样就需要我们在调用逻辑时传入一些判断条件。这无疑是增加了算法的局限性，从另一点来说，这个算法的适用范围就大大降低了。所以我引入了一个上下文环境，这个环境主要用于包裹相关信息数据和函数指针回调： 1234567891011121314151617181920212223typedef struct __PPWebLFUFetchCacheContext *PPWebLFUFetchCacheContextRef;typedef struct __PPWebLFUFetchCacheContext &#123; _PPWebLFUInlayerNodeRef *node;/// root void *info;/// 一般传入fetchCacher对象 void (*appendInStackRootCallback)(void *info, char *const key);/// 栈顶插入回调 void (*appendInStackBottomCallback)(void *info, char *const key);/// 栈底插入回调 void (*appendInStackCallback)(void *info, char *const key);/// 栈中插入回调&#125;PPWebLFUFetchCacheContext;/// 调用这个方法之后，如果不再需要使用这个指针，需要调用free来释放内存空间PPWebLFUFetchCacheContextRef PPWebLFUFetchCacheContextCreate(void *root, void *info, void (* _Nonnull appendInStackRootCallback)(void *info, char *const key), void (* _Nonnull appendInStackBottomCallback)(void *info, char *const key), void (* _Nonnull appendInStackCallback)(void *info, char *const key))&#123; PPWebLFUFetchCacheContextRef ctx = (PPWebLFUFetchCacheContextRef)malloc(sizeof(PPWebLFUFetchCacheContext)); ctx-&gt;node = root; ctx-&gt;info = info; ctx-&gt;appendInStackRootCallback = appendInStackRootCallback; ctx-&gt;appendInStackBottomCallback = appendInStackBottomCallback; ctx-&gt;appendInStackCallback = appendInStackCallback; return ctx;&#125; 至于这里为什么选择一个上下文？当我们需要多个回调时，完全没有必要把每一个回调都添加到函数参数中去，我们可以把这些参数包装起来。而且这样包装起来做还有一个优势，就是新增回调场景时就要方便许多！ 元素添加现在所有的条件都已具备，是时候来处理这些具体的逻辑了。就像是在学红黑树的时候一般都会把它那5个特性先提出来是吧。所以这里需要明确几点特性： 1、由链表实现的一个栈，只有一个根节点（上面提到的，包装在上下文中的lfustack）； 2、栈的深度是有限制的； 3、添加和删除操作是基于栈顶； 4、栈内元素的使用次数是从小到大，从上到下生长； 基于以上，我定义了一个元素添加函数的原型： 1bool _PPWebFetchLFUInlayerQueueAdd(PPWebLFUFetchCacheContextRef context,char *const url) 很明显传入的context是需要在外面创建好的一个指针变量，但是context的具体成员变量我们没有控制，全部传入NULL都可以（因为懒，不想对函数指针做非空判断，所以我把函数指针设置为_Nonnull。。。），这没有什么问题。因此首先要做的就是判断栈是否为空： 123456789101112if (!(*(context-&gt;node))) &#123;/// 创建栈顶指针 _PPWebLFUInlayerNodeRef node = allocNewNode(url); if (!node) &#123; return false; &#125; __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node); safeProgressWith(^&#123; *_broot = node; (context-&gt;appendInStackRootCallback)(context-&gt;info,url); &#125;); return true;&#125; 在上面这段代码中我们使用了context的一个函数指针回调，当在空栈中加入根节点，这是符合该函数指针回调语义的。此时的栈分布情况很简单，但还是画出来更加明显：在这之后插入结点时，我们便需要考虑新添加进来的URL是新节点还是在原有节点上增加使用次数。这里我们需要一个循环从根节点开始遍历栈，如果找到了对应的URL，便将其使用次数加一，如果走到栈底还是未能命中对应的URL，则需要以该URL为数据创建一个新节点，并将这个节点作为栈根。实现代码如下： 123456if (0 == strcmp(lead-&gt;url, url)) &#123; (context-&gt;node)-&gt;use_count++;&#125;else&#123; (context-&gt;appendInStackRootCallback)(context-&gt;info,url); return appendRootNodeInStack((context-&gt;node), url);&#125; 上面涉及到的函数appendRootNodeInStack主要用于生成一个节点之后，并将该节点设置为根： 12345678910111213bool appendRootNodeInStack(_PPWebLFUInlayerNodeRef *root ,char *const url)&#123; /// 在栈顶插入 _PPWebLFUInlayerNodeRef node = allocNewNode(url); if (!node) &#123; return false; &#125; __block _PPWebLFUInlayerNodeRef *_broot = root; safeProgressWith(^&#123; node-&gt;next = *_broot; *_broot = node; &#125;); return true;&#125; 所以现在会出现两种情况，如下所示：这段逻辑代码目前并没有放在循环中来做，它和栈中已经存在四个、五个节点的情况是类似的，但它的情况要简单许多，它只需要处理使用次数更新或者头节点插入的情况，不会涉及到删除（除非你不做缓存）、移位操作。到最后我会把这段代码合并起来，而那正是我设计这套算法的中心思想。 节点移动和删除针对节点的移动，需要考虑多个情况，包括：从栈顶移动到栈底、从栈顶移动到栈中某一个位置、从栈中某一个位置移动到栈中另一个位置、从栈中某一个位置移动到栈底、不移动。我把这些情况依次描述到图中，这样看着更直观：下面是后面两种情况：从上面虚线箭头到实线箭头的变化可以很明显看出来，是复杂了不少。而最后一种无变化的，我就没有列出来。看看前面四种情况变化后的栈元素排列情况，从左到右，从上到下依次是： 2-&gt;3-&gt;4-&gt;1; 3-&gt;2-&gt;4-&gt;1; 2-&gt;4-&gt;3-&gt;1; 2-&gt;3-&gt;1-&gt;4; 从上面四种情况来看，对于一个节点的移动可以分为两部拆开来看，分别是——取出、放入两个过程。我直接把中间的的算法列出来： 1234567891011121314151617181920212223242526272829303132333435363738_PPWebLFUInlayerNodeRef previous = lead;_PPWebLFUInlayerNodeRef pivot = NULL;_PPWebLFUInlayerNodeRef prepivot = NULL;do &#123; if (0 != strcmp(lead-&gt;url, url)) &#123; if (!pivot) &#123; continue; &#125; if (pivot-&gt;use_count &lt;= lead-&gt;use_count) &#123; break;/// 跳出循环去执行放入 &#125; if (*(context-&gt;node)==pivot) &#123; __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node); safeProgressWith(^&#123; *_broot = previous-&gt;next; &#125;); &#125;else&#123;/// 取出 prepivot-&gt;next=pivot-&gt;next; &#125; continue; &#125; lead-&gt;use_count++; pivot = lead; prepivot = previous;&#125; while ((void)(previous=lead),(void)(lead=lead-&gt;next),lead);if (!pivot) &#123;/// 在栈顶插入 (context-&gt;appendInStackRootCallback)(context-&gt;info,url); return appendRootNodeInStack((context-&gt;node), url);&#125;if (!lead) &#123;/// 处理栈底情况 previous-&gt;next=pivot; pivot-&gt;next=NULL; (context-&gt;appendInStackBottomCallback)(context-&gt;info,url);&#125;else&#123;/// 处理栈中的放入 pivot-&gt;next=previous-&gt;next; previous-&gt;next=previous==pivot?lead:pivot; (context-&gt;appendInStackCallback)(context-&gt;info,url);&#125; 这段代码把上面提到的if-else判断也一起合并进来了，这里pivot主要是用来记录找到目标URL的哨兵，而prepivot用来记录哨兵前面一个节点（如果使用双向链表完全可以不用这个零时变量）。到这里基本上是把该算法的核心部分说完了，该算法的最坏时间复杂度就是O(N)，这种最坏时间复杂度的情况分别是：新节点插入，栈顶一次直接移动栈底（这个情况是发生在使用次数都为1时，栈顶元素此时+1的情况）。最优的时间复杂度情况是O(1)，直接栈顶数据更新。最后就是节点的删除操作，仅仅只是删除操作时间复杂度肯定是O(1)的。但是事情往往没有这么简单，必须要考虑当前添加进来的元素是到达容量限制的新元素，还是栈里面已经存在的元素呢？难道我们又要去遍历一次栈然后来做删除操作吗？这是完全没有必要的，因为要出现删除节点的情况，肯定是发生在向栈中Push元素时发生。因此我将上面各个情况分为三种大体情况，并为这三种情况提供了三个回调，而这个三个回调都是放在上面的context中： 在栈顶插入元素（appendInStackRootCallback）； 处理栈底情况（appendInStackBottomCallback）； 处理中间节点（appendInStackCallback）； 基于这： 我们可以一次循环中完成新增、移动、删除操作！ 上面提到的三个回调，可以通过调用PPWebFetchLFUCache实例方法来看一下一个整体过程： 123456789101112131415161718192021- (BOOL)insertCacheMap:(NSData *)object forKey:(NSString *)key&#123; PPWebLFUFetchCacheContextRef ctx = PPWebLFUFetchCacheContextCreate( &amp;_lfuStack, (__bridge void *)(self), &amp;progressingAppendInStackRootCallback, &amp;progressingAppendInStackBottomCallback, &amp;progressingAppendInStackCallback); bool result = _PPWebFetchLFUInlayerQueueAdd(ctx, (char *)[key UTF8String]); if (result == false) &#123; PPWebLFUFetchCacheContextRelease(&amp;ctx); return NO; &#125; if (![self.cacheMap.allKeys containsObject:key]) &#123; safeProgressWith(^&#123; [self.cacheMap setObject:object forKey:key]; self.currentCacheUsage += object.length; &#125;); &#125; PPWebLFUFetchCacheContextRelease(&amp;ctx); return YES;&#125; 在上面创建上下文的代码中，第一个参数为保存在PPWebFetchLFUCache单例中的一个成员变量，而info参数主要用来传递self，这里用context时，_lfuStack会被context保留，而_lfuStack又会被PPWebFetchLFUCache单例保留，但是在函数返回之前会对context做release操作，会把对_lfuStack的保留置空，所以不要想着OC里面常出现的引用计数不会降为0的问题。而且也不会出现相互持有的关系。而回调函数中，主要来看progressingAppendInStackRootCallback的回调： 123456789101112void progressingAppendInStackRootCallback(void *info, char *const key)&#123; PPWebFetchLFUCache *cacher = (__bridge PPWebFetchLFUCache *)(info); if (!cacher) &#123; return; &#125; if (cacher.cacheMap.allKeys.count &gt;= kMaxMemoryCountLimit) &#123; [cacher deleteCacheMap]; progressingAppendInStackRootCallback(info, key); &#125;else&#123; return; &#125;&#125; 下面我直接把删除函数贴出来，这并没有什么难点： 1234567891011121314151617_PPWebLFUInlayerNodeRef _PPWebFetchLFUInlayerQueueDelete(PPWebLFUFetchCacheContextRef context ,char **url)&#123; if (!(context-&gt;node)) &#123; return NULL; &#125; _PPWebLFUInlayerNodeRef lead = NULL; lead = *(context-&gt;node); __block _PPWebLFUInlayerNodeRef *_broot = (context-&gt;node); if ((*_broot)-&gt;next) &#123; safeProgressWith(^&#123; *_broot = (*_broot)-&gt;next; &#125;); &#125; if (url) &#123; (*url) = (lead-&gt;url); &#125; return lead;&#125; 上面出现的deleteCacheMap方法中会把不再使用的节点free掉。 后语上面代码中很多地方都用到了safeProgressWith函数，其实现也在上面列出来了。使用它的目的有两个：第一个、PPWebFetchLFUCache类的操作是可以在多线程异步环境下操作的，所以我必须要保证cacheMap的数据同步；第二个、虽然基于C的操作我都是放在一个串行的队列中进行： 123456async_inbackground(^&#123; BOOL result = [self insertCacheMap:data forKey:url]; if (complete) &#123; complete(result); &#125;&#125;); 但是_lfuStack成员变量是可以通过hook的方法拿到，并让其在异步环境下去进行修改，这个我没法去控制，但是我要做到在LFU内做到一个同步操作，所以基于跟节点的操作都是在加锁状态下完成的。这里需要注意的就是不要出现互斥锁的嵌套使用，如果使用的是同一个锁变量的话，那肯定会造成死锁的。 完。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来唠嗑一下线程中的一些事儿]]></title>
      <url>%2F2017%2F11%2F16%2Ftalk_about_thread%2F</url>
      <content type="text"><![CDATA[由于前段时间的工作中，在一个并发编程题中栽了跟头,也因此增加了我对这一方面的理解。下面我会结合例子的方式来阐述一下我的一点儿小理解。 线程 对于并发编程可能首先想到的便是和多线程有关，这又需要涉及到线程的概念。维基百科上关于线程的解释，我提取一个我认为比较关键的概念： 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 每个线程存在自己的栈和寄存器集合，所以在这种情况下去保证线程相对安全的时候应该要使用violate变量（防止编译器缓存了被多个线程寄存器并发用到的变量，让编译器直接去变量地址获取）。 上面的重点在于“线程是包含于进程中，并且一条线程实际上一段代码的执行流”（代码区是被进程内多个线程共享的）。这里也就不过多深入地去解释了，贴一个我翻译的官方的多线程编程文档，并配合有创建线程不同方式的代码。我之所以专门把这个提出来是因为我在这个知识基础上遇到过一个面试题——“我们使用异步的方式从服务端获取到了我们需要的数据，然后我们如何去更新对应视图？”。如果不去细想的话直接扔出一段代码：12345678910 [self post:url aPara:nil completionBlock:^(id responseObject, NSError *error) &#123;#if defined(USE_GCD_UPDATE_UI) &amp;&amp; USE_GCD_UPDATE_UI == 1 dispatch_async(dispatch_get_main_queue(), ^&#123; /// 更新UI &#125;);#else /// updateView中更新UI [self performSelectorOnMainThread:@selector(updateView:) withObject:responseObject waitUntilDone:NO];#endif &#125;]; 为什么在子线程中更新UI是不安全的 他会继续追问你，我们为什么必须要把更新UI的任务放在主线程来做？放到子线程不可以吗？对于这个问题我只能用我浅显地认识来解释一下这个问题，因为操作系统相关的东西我几乎忘的差不多了。这里先抛出一个概念——基于UIKit的控件是线程不安全的。那么为什么苹果要把UIKit设计为线程不安全？ 最直观的来说，在牺牲性能为代价的前提下，使用同步能够确保代码的正确执行。在大多数情况下使用同步工具都会造成延迟。锁和原子操作通常会涉及到使用内存屏障和内核级的同步来确保代码正确执行。当出现锁竞争的情况下，线程可能会被阻塞从而导致体验上的延迟卡顿。所以我猜测有基于这个原因导致了苹果将UIKit设计成了线程不安全。这就回答了上面提出的“我们为什么必须要把更新UI的任务放在主线程来做？” 下面我通过画图的方式来表达一下在并行状态下UIKit不使用同步工具的情形：就如上图所示在主线程和子线程的消息队列中同时去修改同一内存空间中的值，如果不添加一个同步操作的话会发生意想不到的事情。Objective-C中的对象是存放在堆区，而堆区和前面我提过的代码区一样是线程共享的。现在我们知道为什么需要我们在主线程中去更新UI。而对于另一个问题：放到子线程不可以吗？或许在AsyncDisplayKit中能够找到子线程处理视图的答案。 子线程是如何实现在主线程中更新UI 现在回到最初的问题上来，子线程和主线程是怎样协调工作来更新视图的呢？更新的代码我在上面已经放出来了，但是面试官的目的是想要知道其底层实现，先来看一下官方文档中出现的一个图片：如果要完整的讲一下我的理解的话，需要以下这些假设。我们把右边绿色的这一部分当做是子线程，而左边紫色的部分当做是主线程；并且我们有自定义一个输入源（因为我想完整的模拟这个场景，而不是使用系统提供的封闭的输入源），我们要通过该输入源来给主线程的Runloop发送消息（你可能会问为什么要用输入源？我直接发消息不可以吗？不好意思，Runloop就人输入源或者定时器源）。 首先来创建一个自定的输入源，这个输入源负责从子线程给主线程的Runloop发送消息：123456/// .h@interface RunloopSource : NSObjectvoid runloopsrc_schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode);void runloopsrc_perform(void *info);void runloopsrc_cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode);@end 上诉头文件中的三个函数分别是： schedule表示注册成功并提供外部给子线程传递数据；perform是子线程通过输入源想要给主线程传输的主要出口；cancel是在我们异步处理完了之后，调用CFRunLoopSourceInvalidate函数告知主线程Runloop该输入源已经完成其职责。1234567891011121314151617181920212223242526272829303132333435363738394041///.m- (instancetype)init&#123; self = [super init]; if (self) &#123; CFRunLoopSourceContext ctx = &#123; .info = (__bridge void *)(self), .retain = NULL, .release = NULL, .copyDescription = NULL, .equal = NULL, .schedule = runloopsrc_schedule, .perform = runloopsrc_perform, .cancel = runloopsrc_cancel &#125;; &#125; return self;&#125;void runloopsrc_schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode)&#123; ...&#125;void runloopsrc_perform(void *info)&#123; RunloopSource *src = (__bridge RunloopSource *)info; [src sourceFire];/// 接口用c，但是处理数据，看习惯，习惯用OC&#125;void runloopsrc_cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode)&#123; ...&#125;- (void)sourceFire&#123; if (self.sourceFire_handle == nil) &#123; return; &#125; @synchronized (command_data) &#123; /// 处理数据 /// 回传给主线程数据 /// 在输入源中，也就是这个函数中去给主线程的Runloop发送消息，让其更新界面 /// - (void)performSelector:(SEL)aSelector onThread:waitUntilDone:modes: &#125; CFRunLoopSourceInvalidate(runloop_src);&#125; 到这里假设我们已经从- (void)URLSession: dataTask:didReceiveData:;（NSURLSessionDataDelegate协议）获取到了数据，此时在runloopsrc_perform 中调用performSelector方法给主线程Runloop发送消息。现在我们把注意力放在上图左边的紫色部分，可以看出它一直处于一个循环中。如果此时消息队列中存在消息，那么该Runloop会处理消息队列中的消息，如果消息队列为空，那么Runloop应该是处于一个休眠状态。当他收到了由我们从子线程的自定义输入源发来的消息时，他会被唤醒来处理该消息。此时在主线程中去执行更新UI的事件。 对于这一块儿我并没有十足的把握，如果有更好的理解麻烦告知与我，万分感谢。 我所了解的线程小常识到这儿了主要就说一点儿我所了解的线程，其中主要包括了线程优先级和调度问题，线程和他寄存器之间的一点儿恩怨！ 关于线程优先级和调度在多对一的线程模型中，一个内核线程对应了多个用户级线程，其实这时候的并发并不是真正意义上的并发，它应该是基于CPU轮转的方式来调度不同用户级线程，让他们每个都执行一小段时间，做到类似并发的效果。所以后面的线程模型都是基于多对多模型，它既可以实现真实的并发，又可以减少一对一模型中线程切换的消耗。 我们可以给线程设置不同的优先级来改变它们的先后执行顺序，除了我们指定的方式，系统会在以下两种情况下去更改线程优先级： I/O密集型线程会比CPU密集型线程更容易被系统提高优先级。因为I/O密集型线程会经常进入waiting状态，而进入waiting状态说明它的任务花费时间短。而CPU密集型线程则是耗费完时间片之后进入ready状态。 对于I/O密集型线程来说，如果给它分配了较低优先级。而CPU密集型线程分配了较高线程优先级，那么就会造成I/O密集型线程处于“饿死”状态。所以系统会将长时间没有运行线程的优先级提高。 编译器优化所带来的问题编译器为了能够让CPU在获取数据更快速，它会把一些需要经常访问的数据读取到寄存器中。为什么寄存器比内存快？，我的理解是由于寄存器存在于CPU内，内存和CPU之间相隔了一个北桥芯片，而它们是通过PCI总线来连接的，就距离上来说这可能是一个原因（我瞎扯淡）。因为这个优化会产生一些小问题，看下面一段代码：123456789101112NSThread thread1 = [NSThread detachNewThreadWithBlock:^&#123; NSLock *lock = [[NSLock alloc] init]; [lock lock]; i++; [lock unlock];&#125;];NSThread thread2 = [NSThread detachNewThreadWithBlock:^&#123; NSLock *lock = [[NSLock alloc] init]; [lock lock]; i++; [lock unlock];&#125;]; 这是线程安全的吗？我只能说不一定，因为这是一个偶然事件。下面我来说一下我理解的这个偶然事件是怎么发生的？ 【thread1】读取i的值到线程1的寄存器集合R1（R1 = 0）； 【thread1】R1++（由于之后可能还要访问i，所以thread1暂时不会把R1写回到i）； 【thread2】读取i的值到线程2的寄存器集合R2（R2 = 0）； 【thread2】R2++（R1 = 1）； 【thread2】将R2写回i； 【thread1】过了很久之后，将R1写回i（i=1）； 很明显这并不是我们想要的结果，这就是由于编译器的优化把值读取到了线程响应的寄存器集合中，改变的根本不是同一块儿内存上的值。所以为了解决这个问题可以使用前面提到的violate变量，以此来告诉编译器不要将该变量读取到寄存器中，而是直接在内存中进行操作。 并发与并行文章的最后我们唠叨一下并发这个词儿，关于并发和并行知乎上有一个回答解释的很通俗易懂。所以针对Apple的并发编程指南，指的是有能力同时去执行多个任务，但并不是指一定要同时执行多个任务。GCD就不说了，大部分时间都是在使用它（因为它在接口使用上易用）。重点来说一下NSOperation，它是即强大又难用。 在开始使用NSOperation之前，我们自己需要清楚“我们要干什么？Apple提供的NSOperation是否满足需求？我们自定义NSOperation子类是基于并行还是串行？等等”。这里提到的并行和串行就不解释了，再解释就是一篇科普文了。NSHipster上提到了关于NSOperation： NSOperation表示了一个独立的计算单元。作为一个抽象类，它给了它的子类一个十分有用而且线程安全的方式来建立状态、优先级、依赖性和取消等的模型。 所以NSOperation和NSOpertaionQueue不仅仅只是用于网络的情况，当然与之对应的GCD同样可以用于其他事物。试想一下我们是否可以把NSOperation用于一个加载动画。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中Native的方式集成Vuforia、其源码解读以及自定义模型]]></title>
      <url>%2F2017%2F09%2F13%2Fios_nativa_vuforia%2F</url>
      <content type="text"><![CDATA[随着前有Apple在iOS11中提供了ARKit，后有Google推出的ARCore，显然掀起了一股AR热潮（都是一堆废话，说白了就是公司要求做）。 由于Vuforia已经存在较长时间了，相对于EasyAR或者百度AR更为成熟一点儿，所以它成了第一个技术选择。EasyAR和百度的AR——DuMix AR后面再依次去学习。好吧，先开始来学习Vuforia吧！该文章同步发布在我的博客. 集成步骤由于这些步骤相对来说比较基础，我就直接罗列出来。 1、开发者官网https://developer.vuforia.com； 2、下载ios-sdk和ios-sample，并按照官方文档要求将ios-sample放入到ios-sdk的sample文件夹下 3、在vuforia的开发者官网上的License Manager和Target Manager，添加License-key和database 4、将上一步添加的License-key，放在ios-sample中的代码文件SampleApplicationSession.mm中的方法Vuforia::setInitParameters(mVuforiaInitFlags,&quot;&quot;);中。具体步骤见官网。 Vuforia::setInitParameters(mVuforiaInitFlags,"AT16FIX/////AAAAGVieZ/kg1UkghTnYAz5zXWs8+y5JjeF/NJRcjgVDoCSvsrSt+lWzFMcIVBbQ2YSFRF+6J0GceHoaz8NctXib3cndJEacXmR+1FyO5FhalO7sC4hE9d1/x72qTNDhkPs4rF04JulMYT876Grsnmg9C61oyaDVwBfSpzNZ7gx3NADkkV5q4NQs4ghZwVCdMhj6LVt1YTJcwiuULtDTEgpFZZeW/nC8yiC53hpUFOVxhH++ILx1T65jpY8yDn6ct++3mgVeVotg/5tWXYb5FYqBtJiwU/LJJxhJYqUWyy4pd9dHUJBQojuAE8FoW1DmjokrpDWgjOMMp3am4GjNT04hCg+o0Z3SByYx6VIqfSR9fsXw"); 5、将第3步中Target Manager创建的database，传入相关的图片文件。也可以不传，这步可选；怎样使用设备数据。我们在官方Developer创建，下载对应的Database，在添加图片时，对应的星星数越高表明识别度越高解压并将其引入到工程中：这一步可以不做，因为这只是在给后面打基础而已，如果只是运行demo的话是不需要做这一步的。如果做了这一步，在扫描你对应的图片的时候是没有任何效果的，具体的操作后面。 6、编译运行，由于需要使用到传感器，所以必须使用真机来运行。关于真机运行的相关事项查看apple developer 源码阅读顺序 源码说明：Voforia SDK版本：vuforia-sdk-ios-6-5-19iOS Samples版本：vuforia-samples-core-ios-6-5-20 如果不想看源码相关可直接跳过这部分，直接跟着“收尾”做自定义的tracker和模型（替换Teapot茶壶模型为自己的） 为何要阅读源码？因为在Voforia的官方文档中我没有找到我自己想要的信息。所以我们需要通过阅读源码，来找到怎样才能去修改贴在目标图像中虚拟模型。以sample中ImageTargetsViewController为例来解读！首先查看ImageTargetsViewController.h文件，我们先不看成员变量。先来看属性 属性 属性类型 初步作用 eaglView ImageTargetsEAGLView* 初步认定为一个展示视图 tapGestureRecognizer UITapGestureRecognizer* 一个点击手势 vapp SampleApplicationSession* 初步认定为一个会话层（类似于ISO网络七层模型中，在TCP可以归于应用层，也就是说想偷懒可以直接将其代码放入控制器中。个人理解） showingMenu BOOL 一个flag 从上表中出现的属性，我们先来分析一下属性eaglView和vapp。 SampleApplicationSession类在ImageTargetsViewController控制器类中，和下面会讲到的ImageTargetsEAGLView都有SampleApplicationSession类型的属性，所以我们有必要先来看看该类。同样的先看头文件，因为头文件能够让我们对于该类有大体的认识，而不拘于类具体的实现细节。 粗略来看，提供了一个初始化方法；一个初始化AR的方法；四个对AR的操作方法（它们不是我们需要的重点，等到需要的时候再来仔细阅读）；以及一个对Camera的方法：1234567- (id)initWithDelegate:(id&lt;SampleApplicationControl&gt;) delegate;- (void) initAR:(int) VuforiaInitFlags orientation:(UIInterfaceOrientation) ARViewOrientation;- (bool) startAR:(Vuforia::CameraDevice::CAMERA_DIRECTION) camera error:(NSError **)error;- (bool) pauseAR:(NSError **)error;- (bool) resumeAR:(NSError **)error;- (bool) stopAR:(NSError **)error;- (bool) stopCamera:(NSError **)error; 上述的initAR方法是通过异步实现的，当其AR初始化完成之后会调用方法下面会提到的代理方法onInitARDone。顺藤摸瓜，我们来看看该代理，那么该代理所需要处理的事务有哪些呢？这里先将SampleApplicationControl的所有方法先列出来：123456789101112@required- (void) onInitARDone:(NSError *)error;- (bool) doInitTrackers;- (bool) doLoadTrackersData;- (bool) doStartTrackers;- (bool) doStopTrackers;- (bool) doUnloadTrackersData;- (bool) doDeinitTrackers;- (void)configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;@optional- (void) onVuforiaUpdate: (Vuforia::State *) state; 该代理方法中大多是涉及到的是tracker。通过从初始化方法开始查看方法调用，得出了一个程序执行流程图，我们主动调用initAR方法，其结果会由回调方法onInitARDone反应给开发者。开发者可以用通过调用doInitTrackers来控制是否需要去加载tracker数据，如果可以加载数据则通过调用回调方法doLoadTrackersData来获取数据。关于该类中其他几个方法startAR , pauseAR, resumeAR, stopAR由调用人员主动调用，调用这些方法会触发对应的方法回调。现在我们需要把目光转向ImageTargetsEAGLView类，并去具体的看一下里面的相关细节。 SampleAppRenderer类这个类主要是做渲染相关的工作，其源码大多数为OpenGL。所以对于该类我只做具体的作用分析，而不去解释具体的源代码（因为我也不懂），如有需要的话，自行深究吧，哈哈哈😄。这里先将各个方法的作用罗列出来： 方法名 方法作用 initWithSampleAppRendererControl 类初始化方法 initRendering 渲染相关的初始化 setNearPlane:farPlane: 配置投影矩阵数据 renderFrameVuforia 由Vuforia调用，渲染数据帧到屏幕 renderVideoBackground 后台渲染视频 configureVideoBackgroundWithViewWidth:andHeight: 视频相关的配置 updateRenderingPrimitives 更新渲染数据 下面具体分析：老规矩，同样先看头文件，我们根据头文件暴露出来的方法一层一层往里剥。该类存在一个协议SampleAppRendererControl，和一个初始化方法initWithSampleAppRendererControl。使用这个方法需要传入一个遵守SampleAppRendererControl协议的类实例，第二个参数来决定VR/AR的模式，以及三个用于决定投影矩阵的参数。除了在初始化方法设置投影矩阵的参数，该类提供了一个public方法setNearPlane:farPlane:。进入到.mm文件中查看该初始化方法可以看出，只是对类内部私有属性进行相关的赋值操作以及对硬件设备进行相关的设置吧。 现在来看看方法initRendering，这个方法里面主要是做了一些OpenGLES的东西，我们只需要知道里面做了一些和具体业务逻辑无关的东西就行了。 接下来看renderFrameVuforia的作用是什么？源代码中说的很清楚：使用OpenGL绘制当前帧，当需要将当前帧渲染到屏幕上时，Vuforia会定期的在后台线程调用该方法。同样和业务逻辑无关，源码不细看。同样方法renderVideoBackground也是使用OpenGL来做，我们只需要从该方法的名字得知其用途（后台渲染视频）即可。 configureVideoBackgroundWithViewWidth:andHeight:方法从名字就可以知道其作用。updateRenderingPrimitives方法的作用是：当屏幕尺寸发生改变或者是设备朝向改变之后，调用该方法来更新渲染原始数据。 最后需要介绍一下该类很重要的的一个协议方法：renderFrameWithState，该方法被用于获取渲染相关的数据。通过对.mm文件可知，每渲染一次都会调用该方法一次。 ImageTargetsEAGLView类该类的头文件所暴露出来的初始化方法- (id)initWithFrame:(CGRect)frame appSession:(SampleApplicationSession *) app，我们以该方法入手来分析。第一个参数为当前视图的大小设置，第二个参数为前面我们讲到过的一个类实例。头文件中余下的方法还有：123456- (void)finishOpenGLESCommands;- (void)freeOpenGLESResources;- (void) setOffTargetTrackingMode:(BOOL) enabled;- (void) configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;- (void) updateRenderingPrimitives; 方法finishOpenGLESCommands , freeOpenGLESResources分别对应着结束OpenGL和释放OpenGL的资源。configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives和类SampleAppRenderer公开的方法名一样，这里我猜测它们作用是一样的。setOffTargetTrackingMode:方法作用目前还不是很清晰，需要去.mm文件中详查。 现在进入实现文件中，源码中提到了关于OpenGL线程安全的问题。iOS上的OpenGL ES是线程不安全的，在程序中Vuforia使用下面的方法来保证线程（OpenGL 上下文）安全： a、在主线程中创建OpenGL ES上下文。 b、Vuforia相机开始时，将其位于我们自己EAGLView视图上，并开启renderer线程。 c、Vuforia会在renderer线程上，定期调用我们的renderFrameVuforia（SampleAppRenderer类提到）方法。当第一次调用该方法的时候，defaultFramebuffer并不存在，调用createFramebuffer方法来创建它。createFramebuffer由主线程调用，而与此同时renderer线程会被阻塞。因此确保OpenGL ES上下文不会被并行使用 在initWithFrame:appSession:的实现方法中会进行session，OpenGL的context和Renderer的赋值，初始化和绑定工作。而方法configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives在其实现方法中的确只是简单的调用了一下SampleAppRenderer 类的实例方法。 现在主要来看看方法setOffTargetTrackingMode :，它的实现很简单只是对其私有成员变量NO。但是却在协议方法renderFrameWithState中大量的使用。该方法大部分是OpenGL相关的工作，我没有深究下去，只整理出来一个工作流程图：目前来看ImageTargetsEAGLView类的主要作用在于保证OpenGL在iOS中达到线程安全，创建buffer和对buffer的管理，提供了对OpenGL的控制，而实际的渲染则由SampleAppRenderer来实现。 ImageTargetsViewController类现在将目光回到ImageTargetsViewController类上面来。由于是一个控制器类，所以我直接从.mm文件中着手。根据ViewController的加载顺序来看具体的逻辑，首先查找loadView方法，如果没有则查找viewDidLoad。源码中，loadView方法主要创建了vapp，eaglView以及对vapp初始化了AR相关的事务（其他视图和手势等先忽略，只关心属性vapp,eaglView相关的逻辑），将ViewController的View设置为eaglView。 在loadView中将vapp的代理设置为控制器自身，此时通过上面介绍 SampleApplicationSession时对应的程序执行流程，将目光放在对应的部分协议方法上面。123456@protocol SampleApplicationControl- (void) onInitARDone:(NSError *)error;- (bool) doInitTrackers;- (bool) doLoadTrackersData;- (bool) doStartTrackers;@end 从图-1可以看出是由doInitTrackers的返回值来判断是否需要去加载tracker数据(doLoadTrachersData)，最后在onInitARDone方法流程结束。通过这个就确定了我们的源码查看顺序：1/// doInitTrackers --&gt; doLoadTrackersData --&gt; onInitARDone 那么在ImageTargetsViewController类中，其流程图如下：自此我们的源码阅读就告一段落，最后我们将要去实现开始提到的目的！ 收尾读到这里，自定义的数据集的切入点在方法doLoadTrackersData方法中，并且要doInitTrackers方法返回YES。如果没有执行“安装步骤”中的第5步的话，现在可以去做了！做完之后添加如下代码到工程中：12345678///ImageTargetsViewController.mm -&gt; doLoadTrackersDatadataSetCustom = [self loadObjectTrackerDataSet:@&quot;WillDB_Device.xml&quot;];/// 这个dataset为你自己的名字if (dataSetCustom == NULL) &#123; return NO;&#125;if (! [self activateDataSet:dataSetCustom]) &#123; return NO;&#125; 运行程序，扫描对应的图片发现是能够成功扫描对应的图片的。但是系统的图片能出来一个“茶壶”，而我们自己的图片上面什么也没有呢？在这里我不想又去使用这个烦人的“茶壶”OpenGL模型了，我选择的是一个皮卡丘的原型（在文末我会将改造过的demo传到Github可以去那里下载这个原型）。 模型obj到opengl数据的转换就目前我知道的来说，在Xcode中无法使用.obj的模型数据的。我在网上找到了一个工具obj2opengl，具体的使用方法见这里，我还是大体来说一下使用步骤：将下载好的文件放到特定的文件夹中，然后把对应的obj文件和它放在一起，使用终端进入obj2opengl.pl文件所在文件夹之后，输入如下命令：1./obj2opengl.pl yourobjfilename 成功后，它会生成一个头文件，这就是通过obj文件生成的纹理坐标代码，在该头文件中有3个数组，这三个数组分别对应着xxxVerts [], xxxNormals [], xxxTexCoords []，和一个xxxxNumVerts（xxx为你的obj文件名字），具体使用说明。 模型替换通过前面的源码阅读，我们知道ImageTargetsViewController类是用来加载tracker数据的，SampleAppRenderer类是做渲染相关的数据，SampleApplicationSession类是使用tracker数据并控制AR，最后只剩下一个ImageTargetsEAGLView类。在该类中会做如下操作： 1、在textureFilenames数组中，添加一个新的纹理。这个自己选择一个纹理图片，我是随便选的，所以看起来会很丑。 2、在ImageTargetsEAGLView类的头文件中添加一个私有成员变量pikachuModel。用它来代替例子中的buildingModel。并在SampleApplication3DModel.h文件中添加方法pikachu_ReWrite，并在SampleApplication3DModel.m文件中添加如下代码： 12345678- (void)pikachu_ReWrite&#123;#if kUse3DModel == 1 _numVertices = XY_PikachuMNumVerts; _vertices = XY_PikachuMVerts; _normals = XY_PikachuMNormals; _texCoords = XY_PikachuMTexCoords;#endif&#125; 3、在ImageTargetsEAGLView.mm的方法loadBuildingsModel中添加如下代码： 12pikachuModel = [[SampleApplication3DModel alloc] init];[pikachuModel pikachu_ReWrite]; 4、将ImageTargetsEAGLView.mm文件中所有的buildingModel替换为pikachuModel，最后调节一下变量kObjectScaleOffTargetTracking的值，这个值调节由自己决定。 上述的修改灵感大多是来自头文件Teapot.h，但是我们使用obj2opengl时生成的文件中并没有Teapot.h中teapotIndices对应的数组。相反多了一个无符号的整形变量xxxNumVerts，所以除了上诉的方法以外还有另外一种方法，具体的代码修改如下：123456/// ImageTargetsEAGLView.mm -&gt; renderFrameWithState方法中glVertexPointer(3, GL_FLOAT, 0, XY_PikachuMVerts);glNormalPointer(GL_FLOAT, 0, XY_PikachuMNormals);glTexCoordPointer(2, GL_FLOAT, 0, XY_PikachuMTexCoords);glDrawArrays(GL_TRIANGLES, 0, XY_PikachuMNumVerts); 在使用这个方法时其（用obj2opengl生成的头文件的数组中的）数值比例是需要修改的，而且还需要对模型进行翻转。这个方法具体见How do I replace the Teapot和Replace the teapot model。在修改源码时主要就是在修改方法renderFrameWithState，它在介绍ImageTargetsEAGLView类时在文件的最开头就有提到，它是在每捕捉到一次tracker之后就会运行一次。到这里一个很基本的Vuforia集成，源码的解读以及自定义tracker和模型就算完成了，最后附上Demo地址。 相关链接 obj2opengl obj2opengl Github OpenGL Transformation How do I replace the Teapot]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC与C的交互及其内存管理]]></title>
      <url>%2F2017%2F08%2F01%2Foc_bridge_c_memory%2F</url>
      <content type="text"><![CDATA[首先我们从最基本的C中三种链接属性，分别是：外部(external)、内部(internal)、无(none)。我们可以通过关键字extern、static来修改变量的链接属性。 extern关键将一个变量声明为外部的链接属性之后，便可以去访问其他文件中同名该变量。static关键字在用于代码块外部的变量时是将其设置为内部链接属性，如果是在代码块内部则将该变量声明为静态变量。 然后再来看看C中变量的存储类型。存储类型决定了变量的创建、销毁时机。存储变量的位置一共三个地方：普通内存、运行时堆栈、硬件寄存器。结合C中的三种链接属性，具体可以分为： 栈区：代码块中的变量在一般情况下为自动变量（由高地址向低地址生长） 堆区：由malloc、realloc、calloc等函数动态生成的变量。这些变量我们只能访问其地址，而且当我们不再使用之后需要收到去free掉（由低地址向高地址生长）。 全局区／静态区：代码块之外声明的变量总是存储于静态内存中（默认的链接属性为external）。未初始化的变量放在一起，已经初始化的紧挨地放着。由于函数实参总是在堆栈中进行传递，所以函数的形参不能设置为static。 常量区：常量字符串 代码区 在代码块内部声明的变量的缺省存储类型是自动的，即它存储于堆栈中，称为自动变量。如果代码块被多次执行，那么自动变量将会重复创建，每一次创建时，它们在内存中的位置可能会不同。 至于上面提到的寄存器中的变量，因为CPU对于寄存器的读取速度非常快，通常编译器会将使用频率很高的变量将其移到寄存器中。如果寄存器变量在多线程编程时出现了问题，我们可能需要显式将该变量声明为volatile，让编译器不对该变量进行优化。 12345678910111213141516171819/** 全局静态区 */int a = 10; /// externalextern int b;/// externalstatic int c;/// internalint d(int e)&#123;/// 函数d 默认为external int f = 15;/// auto 栈区 static int g = 20;/// 静态变量 静态区 return 0;&#125;static int h(int i)&#123;/// 函数h 修改为static，internal register int j;/// 寄存器类型，但是不一定起作用 int *k = malloc(sizeof(int));/// 堆区 free(k); const int m = 25;/// 常量区 return 1;&#125; C中各个类型变量的内存管理C语言中的内存管理与链接属性和所在内存区域都有直接关系。栈区的自动变量会在其作用域之后自动进行销毁；堆区的中由用户动态的创建的内存，需要手动调用free函数来释放（否则会造成内存泄漏）； 全局区／静态区中的变量由系统创建和销毁，它们在程序开始运行之前就创建好，静态区的变量在程序运行过程中我们不能去修改； 常量区程序结束后由系统释放。 关于堆的一点儿说明：如果我们在使用malloc和free时是无序的话，最终会产生堆碎片。而且被分配的内存是经过对齐的，一般为2的乘方。 堆的末端由一个称为break的指针来标识，当堆管理器需要更多内存时，它可以通过系统调用brk和sbrk来移动break指针。 OC与C的交互(__bridge) 当oc在和c相关的函数（CoreFoundataion、Runtime）进行交互时，我们需要将OC的类型传递到C中，也需要将C中的数据返回给OC使用。这其中就需要使用它们类型之间的转换。在id类型或者对象变量赋值给void *或者逆向赋值时都需要进行特定的转换，单纯的赋值我们可以使用 __bridge 。 123NSObject *obj = [[NSObject alloc] init];void *p_obj = (__bridge void *)(obj);NSObject * r_obj = (__bridge NSObject *)(p_obj); 相对于__bridge，我们可以使用``bridge_retained修饰符，它即可以进行转换，也能持有被转换的对象__（上例中的obj ``），因此该对象不会被废弃。其语法形式如下： 1__bridge_retained &lt;#CF type#&gt;)&lt;#expression#&gt; bridge中还有个``bridge_transfer ，它的作用和__bridge_retained相反，被转换的变量（上例中的p_obj ）所持有的对象（上例中的obj ）会在r_obj ``被赋值之后释放掉，其语法形式如下： 1__bridge_transfer &lt;#Objective-C type#&gt;)&lt;#expression#&gt; 把上诉例子进行修改： 123NSObject *obj = [[NSObject alloc] init];void *p_obj = (__bridge_retained void *)(obj);NSObject * r_obj = (__bridge_transfer NSObject *)(p_obj); 当我们在C语言的结构中，需要使用OC的类型作为结构成员，除了将OC的类型转换为void *之外，我们可以使用__unsafe_unretained修饰符（这个修饰符会在后面介绍）。 12345678910/// 在C中使用OC的对象方式typedef struct rls_temp_ctx&#123; NSObject __unsafe_unretained *obj; void *target;&#125; rls_temp_context;/// 在C中传入OC对象rls_temp_context tmp_ctxs = &#123; .obj = [NSObject new], .target = (__bridge void *)(self)&#125;; 但是在使用obj时，由于__unsafe_unretained存在悬浮指针的问题，必须要判断该值是否存在。 OC内存管理前面看了C的内存管理，还看了C和OC的交互，最后就来看看在OC中内存管理应该注意的事项。 现在我们讨论OC的内存管理是基于ARC的，其中对象变量的创建和释放问题和C的内存管理有点儿相似。大多数情况下系统会帮我们进行内存管理，我们只需要明确自己所声明的对象或者变量存在于什么区域（上面提到的内存区域），给它们添加合适的修饰符等等。 大部分情况下，对于栈区、堆区、全局静态区的变量对象和C是相同的，我们可以类比来分析OC中对象或者变量的创建和释放时机。ARC中栈区用autoreleasepool管理的变量和C中的自动变量的内存管理时机很相似。 在OC中使用基于C的函数时，通过malloc等函数声明的变量，都需要我们明确地调用free函数进行释放！抑或在使用CoreFondation、Runtime时，基本上如果遇到了包含有Copy， Create等关键字函数，在使用完成之后都需要手动释放内存。2017-09-13更新：当我们使用Runtime时，运用下面的方法来动态创建一个对象时，被创建的对象不会被释放，但是对应的release方法又是MRC时代的。所以我们可以使用如下方法来解决：1234567/// 创建对象id obj = ((id(*)(id,SEL))objc_msgSend)(((id(*)(id,SEL))objc_msgSend)([self class],@selector(alloc)),@selector(init));........./// 释放对象((id(*)(id,SEL))objc_msgSend)(obj,NSSelectorFromString(@&quot;release&quot;)); 内存管理关键字下面来介绍一下，在Objective-C的ARC中所涉及到的关键字。 1、__strong为默认值，在声明成员变量和方法参数时也可以使用！ 1__strong id obj_var = [[NSObject alloc] init]; 作用：默认的行为。 2、__weak是不会持有对象实例，__weak修饰符可以避免循环引用 1234567__weak id obj2 = nil;&#123; __strong id obj_var = [[NSObject alloc] init];/// 自己生成对象并持有 obj2 = obj_var;/// obj2持有对象的弱引用 NSLog(@&quot;__weak %@&quot;,obj2);/// 此时由于在obj_var变量可用域中，obj2此时有值&#125;NSLog(@&quot;__weak %@&quot;,obj2);/// 由于不在obj_var作用域之外，obj_var被释放。而且obj2是弱引用于obj_var的，所以此时obj2值为空 作用：避免循环引用，不持有对象实例 3、__unsafe_unretained修饰符的变量不属于编译器的内存管理对象。它和__weak类似，不会持有对象实例； 12345678__unsafe_unretained id obj1 = nil;&#123;/// 在obj_var作用域内，__unsafe_unretained和__weak是一样的 __strong id obj_var = [[NSObject alloc] init]; obj1 = obj_var; NSLog(@&quot;__unsafe_unretained %@&quot;,obj1);&#125;NSLog(@&quot;__unsafe_unretained %@&quot;,obj1);/// 此时变量已经被遗弃，成为悬浮指针 在使用__unsafe_unretained修饰符时，赋值给strong修饰符的变量时，需要检查被赋值的对象是否存在（也就是被unsafe_unretained修饰的变量） 作用：在iOS4之前__weak的替代品，但是在将其赋值给其他时，最好做非空判断 4、__autoreleasing修饰符的变量替代调用MRC时代的autorelease方法，该对象会被注册到autoreleasepool中。以下是__autoreleasing修饰符的使用场景： 1）、在生成对象时，编译器会检查方法名是否是以alloc/new/copy/mutablcopy开始（自己生成自由持有）。如果不是自己生成的则自动将返回值注册到autoreleasepool中。2）、对象作为返回值时，编译器会自动将其注册到autoreleasing中。3）、在使用weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。4）、id的指针或者对象的指针(NSObject /NSError )在没有显示指定时会被附加上__autoreleasing修饰符__。 12NSError *error = nil;BOOL result = [self performOperationWithError:&amp;error]; 最后还是去看看这套题，它的解释对于理解内存的释放很有益处。对于这套题我已经推荐了几次了，哈哈哈。 相关引用 ARC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从头认识GCD——相关函数的使用]]></title>
      <url>%2F2017%2F07%2F29%2Fgcd_func%2F</url>
      <content type="text"><![CDATA[在上一篇文章中，我们对GCD有了基本的认知，知道其中一些简单的类型，和一些简单函数。这本篇文章中，我们将继续学习GCD中我们在日常开发中使用较多的函数，及其使用方法。在本篇会介绍dispatch_after、dispatch_apply、dispatch_group_t、dispatch_semaphore_t和dispatch_barrier等相关函数。 dispatch_after／dispatch_time_t我先来说说dispatch_after，从某种意义上来说，它属于任务提交的一种方式。在刚刚接触iOS开发的时候，我一直在想“ 对于dispatch_after它是同步提交代码块还是异步提交的代码块的呢？ ”。后来看到Apple的文档中说到”This function waits until the specified time and then asynchronously adds block to the specified queue”，也就是说它的延迟执行，并不是马上就将代码块就提交到指定的队列中，而是等到指定的时间通过异步的方式将提其提交到指定的队列中去。因此从这段话中也可以看出它仅仅是dispatch_async的一种。该函数的声明如下： 1void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 到这里就需要来系统地说一说dispatch_after函数的第一个参数，一个dispatch_time_t类型的变量。dispatch_time_t实际是uint64_t类型。系统为该类型定义了两个特殊值，分别是DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER，其中DISPATCH_TIME_NOW表示值为0，而DISPATCH_TIME_FOREVER表示为无穷大（infinity）。除了这两个特殊值之外，我们可以使用函数dispatch_time()来创建相对于默认时钟的时间；或者使用dispatch_walltime()函数获取绝对时间。对于dispatch_time()函数，第一个参数我们传入DISPATCH_TIME_NOW或者DISPATCH_TIME_FOREVER值。 dispatch_time()函数第二个参数接受的是 基于纳秒级别的数值 。 这时候就需要将具体的数字乘以一个常数，在官方文档中列出了相关的常数。 常数 意义 具体数值 NSEC_PER_SEC 表示一秒能转换成多少纳秒 1000000000ull USEC_PER_SEC 表示一秒能转换成多少微秒 1000000ull NSEC_PER_USEC 表示一微秒转换成多少纳秒 1000ull 12345/// 使用相对时间，相对于现在延迟五秒dispatch_time_t time_t = dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC);dispatch_after(time_t, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Run&quot;);&#125;); 如果我们想要该代码块延迟到某一指定时刻去执行，我们只需要去修改dispatch_after中的dispatch_time_t类型中值，在这里我们使用函数dispatch_walltime来获取绝对的时间戳值。dispatch_walltime()函数的一个参数是struct timespec类型的一个变量，它是一个结构： 12345_STRUCT_TIMESPEC&#123; __darwin_time_t tv_sec; long tv_nsec;&#125;; 分别为秒和纳秒。timespec是基于纳秒级别的数值，关于dispatch_walltime具体是方式之一如下： 123456789/// 延迟到某一绝对时刻执行struct timespec __tp;double sec, n_sec;n_sec = modf(1500794750.797543543, &amp;sec);__tp.tv_sec = sec;__tp.tv_nsec = n_sec;dispatch_after(dispatch_walltime(&amp;__tp, 0), dispatch_get_main_queue(), ^&#123; ...&#125;); 上诉代码要等到时间戳为1500794750时才会将代码块提交到指定的事件队列中。 dispatch_applydispatch_apply是dispatch_sync函数配合不同的的dispatch_queue_t队列，来循环执行任务。 如果在dispatch_apply函数中传入的是一个并发队列，那么block中的任务就可以被并发的调用！相对于一般的for循环来说要高效许多。 12345dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, apply_queue, ^(size_t index) &#123; NSLog(@&quot;%zd&quot;,index);&#125;);NSLog(@&quot;End&quot;); 结果如下0, 2, 3, 1, 4, End。但是我们将上面的并发队列改成串行队列之后： 12345dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, apply_queue, ^(size_t index) &#123; NSLog(@&quot;%zd&quot;,index);&#125;);NSLog(@&quot;End&quot;); 返回的结果0, 1, 2, 3, 4, End和正常的for循环没有什么差距。但是不管是在并发的队列还是在串行的队列中，End总是最后才打印的。 dispatch_group_t相关函数使用dispatch_group可以把许多操作进行合并。在将多个任务block提交之后，我们可以在dispatch_group中获取到这些操作全部完成的时间（不管是串行执行还是并行执行）。现在我们有一个场景：第一步，我们需要将多个本地资源传递给服务器。我们用dispatch_group相关的技术来实现这个需求。创建一个dispatch_group_t类型的变量实现非常简单，不像其他GCD函数需要一些其他的参数： 1dispatch_group_t upload_group = dispatch_group_create(); 当创建好了dispatch_group之后，我们需要将这些任务进行提交，这里我使用上一节的dispatch_apply来将多个任务放在并发的队列中： 1234567dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123; /// 模拟网络请求 NSLog(@&quot;Upload %zd&quot;,index); &#125;);&#125;); 在大部分的应用中的上传请求，都有一个上传完成的标志。第二步，那么在这个场景中我们如何知道所有图片已经上传成功呢？我们使用同步的方式，用户的交互不起作用，静静地等待上传完成： 1234567891011dispatch_group_t upload_group = dispatch_group_create();dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123; dispatch_group_enter(upload_group); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求 NSLog(@&quot;Upload %zd&quot;,index); dispatch_group_leave(upload_group); &#125;);&#125;);dispatch_group_wait(upload_group, DISPATCH_TIME_FOREVER);NSLog(@&quot;Upload Complete&quot;); dispatch_group的管理是基于计数来做的。dispatch_group_enter会增加该Group内部的任务计数，dispatch_group_leave会减少该Group中未完成的计数，它们两个函数必须配对使用。dispatch_group_wait函数和我们在上一篇文中讲到的dispatch_block_wait函数功能类似，只不过dispatch_group_wait是针对多个block的同步方法，它会等到Group中所有的任务执行完毕之后才会去继续执行后面的内容。 既然上面提到了dispatch_group_wait函数对应dispatch_block_wait函数，那么很明显应该存在dispatch_block_notify函数对应的Group函数。我们将上面的函数进行稍加改动，将同步的方式改为异步的方式，让用户能够做其他的操作： 123456789101112dispatch_group_t upload_group = dispatch_group_create();dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123; dispatch_group_enter(upload_group); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求 NSLog(@&quot;Upload %zd&quot;,index); dispatch_group_leave(upload_group); &#125;);&#125;);dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Upload Complete&quot;);&#125;); 其实相对于使用繁琐的dispatch_group_enter、dispatch_group_leave，Apple给我们提供了更为简单的函数dispatch_group_async。我这样做的目的是为了在一开始就能让我们清楚，在Group内部是什么在决定着dispatch_group_wait 、dispatch_group_notify的触发时机，我们还是对上面的例子进行稍加修改： 12345678910dispatch_group_t upload_group = dispatch_group_create();dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123; dispatch_group_async(upload_group, upload_queue, ^&#123; NSLog(@&quot;Upload %zd&quot;,index); &#125;);&#125;);dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Upload Complete&quot;);&#125;); 很明显对于使用dispatch_group_async给我们带来便利的同时，在灵活性上也就出现缺失，再者就是在用Group做同步的时候使用dispatch_group_enter、dispatch_group_leave是更好的选择！ dispatch_semaphore_t相关函数在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来（来自维基百科）。通俗一点儿讲就是说在进程内部有一原子递增和递减的计数器（也就是该数据变量具有原子性）。如果触发了某个操作使得信号量小于等于0，那么该操作将会被阻塞，直到其信号量大于0。上面提到过，信号量是基于进程的。所以： 信号量不依赖于任何队列，它可以在任何线程中使用。 在GCD中，函数dispatch_semaphore_signal增加信号量计数，如果之前信号量计数小于等于0，该函数会唤醒当前正在等待的线程。相反，函数dispatch_semaphore_wait会减少信号量计数，如果当该信号量计数小于或者等于0之后，会阻塞当前线程，等待其他操作来增加信号量计数。 123456789101112131415161718192021- (NSArray *)downloadSync&#123; NSMutableArray *contents = [NSMutableArray array]; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_group_t upload_group = dispatch_group_create(); dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.download.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0)); dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123; dispatch_group_enter(upload_group); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123; NSString *cts = [NSString stringWithFormat:@&quot;%zd&quot;,index]; NSLog(@&quot;~ %@ ~&quot;,cts); [contents addObject:cts]; dispatch_group_leave(upload_group); &#125;); &#125;); dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return contents;&#125; 我们现在来看看上面这个方法可以正常的返回吗？除了dispatch_semaphore_t相关的代码，我都是直接从上面拷贝下来，没有做任何修改。当我跑起来之后，始终方法downloadSync不会返回，这里很明显的是造成了死锁的问题！由于dispatch_semaphore_wait函数会阻塞当前线程（它此时是处于主线程中），dispatch_group_notify函数的任务线程即为主线程对应的主任务队列。dispatch_semaphore_wait需要等到函数dispatch_semaphore_signal来增加信号量计数之后才会继续执行主线程，而dispatch_group_notify又要在主线程中执行（由于主线程被阻塞）之后才能去调用dispatch_semaphore_signal函数，因此就造成了死锁，程序永远不会继续执行！。解决办法也很简单，将dispatch_semaphore_signal放在一个并行的任务队列中进行： 123dispatch_group_notify(upload_group, dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0), ^&#123; dispatch_semaphore_signal(semaphore);&#125;); 上面使用信号量的相关函数，实现了异步转同步的需求。 dispatch_barrierdispatch_barrier的作用是在并发队列中实现同步操作。在并发队列中，任务的提交顺序会影响到执行顺序，当异步提交的任务在dispatch_barrier之后，该任务需要等到dispatch_barrier提交的任务执行完成之后才会开始执行。把上面的话用下面的图通俗的来解释一下： 用下面的伪代码来实现一下上图中的相关任务： 12345dispatch_async(task_queue, task_1);dispatch_async(task_queue, task_2);dispatch_async(task_queue, task_3);dispatch_barrier_async(task_queue, task_4);dispatch_async(task_queue, task_5); 函数dispatch_barrier_async中block参数，会被目标队列复制并持有，直到任务完成时被释放。官方文档中提到： 目标队列必须是用户手动创建的并发队列，如果传入的是串行队列或者是全局并发队列，那么这个函数就和dispatch_async类似。 dispatch_barrier_sync在做同步操作时和dispatch_barrier_async效果类似，但是它必须得等到block任务完成之后才会返回！而且dispatch_barrier_sync函数的目标线程不会复制和持有block。 dispatch_once在这篇文章的最后以dispatch_once来做一个结尾，对于dispatch_once我们iOS开发者用的太多了。该函数在多线程环境下同样也是安全的，如果是在多线程中进行调用，它会同步地等待block任务执行完成！官方文档中提出：对于dispatch_once函数的 第一个参数必须是存储在全局区或者静态区的变量 1234static dispatch_once_t predicate;dispatch_once(&amp;predicate, ^&#123; ... &#125;); 关于dispatch_once更多的文章见dispatch_once，以及对应的源码once.c。第三篇文章会在后面放出来，我准备写关于dispatch_source和dispatch_data以及dispatch_io等相关知识。 相关链接根据文中出现顺序 Apple Dispatch Github Dispatch Time Multiplier Constants Elapsed Time 信号量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从头认识GCD——派发队列基础]]></title>
      <url>%2F2017%2F07%2F29%2Fgcd_basic%2F</url>
      <content type="text"><![CDATA[本文包括了从最基础的获取任务队列开始，配置任务队列，创建任务，提交任务一步一步地来复习GCD中所涉及到的知识。（建议在PC端浏览） 包括使用较少的dispatch_qos_class_t 、dispatch_block_t等等知识点。 GCD任务队列能够让开发者能够更加专注于同步或者异步任务task，而不用把重点放在创建线程和具体同步和加锁等相关操作。但是如果我们想异步做更加灵活的任务的话（比如后台任务之类的），那选择线程肯定是更好的选择。毕竟操作简单带来就是灵活性的确实嘛！首先先来看看派发队列。 当用户向某一线程提交一个task时，_dispatch_queue_t_作为任务队列以用户期望的方式来管理这些task。 管理的任务的方式有两种类型，分别是串行队列(DISPATCH_QUEUE_SERIAL)和并行队列(DISPATCH_QUEUE_CONCURRENT)，它们两个是由宏定义的。 一、获取任务队列现在问题来了，我们既然知道有这么一个类型了，那我们总要有方式来得到它啊是吧。就目前而言，Apple给我们提供获取该类型变量的方式有三种，分别是： dispatch_get_main_queue：程序主线程的任务队列，这是一个串行队列（DISPATCH_QUEUE_SERIAL）。在程序main()函数被调用之前由系统自动创建。在官方文档中还提到了，我们可以主动去执行被添加到main_queue的任务task（也就是说我们可以主动来调用添加到主线程队列的block）。三个方法分别是：dispatch_main()、UIApplicationMain 、CFRunLoopRun()，选用其中一个。我尝试了一下使用dispatch_main()会导致程序中断。 dispatch_get_global_queue：由系统定义并管理的一个全局并行队列。在获取时，我们需要指定任务队列的系统等级（DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND）。 1dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 但是在iOS8以后，使用枚举qos_class_t的值，提供了细粒度更高的全局任务队列，关于QOS在后面统一梳理一下。 1dispatch_get_global_queue(QOS_CLASS_UTILITY, 0); 该函数的返回值上使用dispatch_resume、dispatch_suspend无效， dispatch_queue_create：除了上诉系统提供的两种类型的任务队列之外，我们还可以自己去创建任务队列。我们可以自己创建串行（DISPATCH_QUEUE_SERIAL）和并行（DISPATCH_QUEUE_CONCURRENT）两种类型的队列，但是它们都有一个变种DISPATCH_QUEUE_SERIAL_INACTIVE, DISPATCH_QUEUE_CONCURRENT_INACTIVE。它们同样会有涉及到QOS的创建方法，后面一起记录一下 1dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT); 上诉三种就是获得任务队列方法，我们在设置dispatch_ge_global_queue的第二个参数时一般设置为0。上面这三种方式是我们在日常开发中，使用并发编程时通过GCD的方式来获取任务队列的方法。在大部分时间使用并行的任务队列时，global_queue能够基本满足需求；对于我来说创建线程的场景，主要是当我们需要一个串行的任务，但是又不想在主线程去执行时使用。既然我在上面提到了QOS，下面我们就系统的来认识一下QOS。 二、通过QOS配置队列 由于在我们的程序中，存在各种各样的场景，比如用户界面刷新，网络请求，资源下载，缓存存取之类的。为了能够保证程序的高效响应，需要对不同的任务对资源的消耗做出一些调整。此时我们就可以使用QOS来解决不同任务的资源分配问题，QOS可以用于dispatch_queue, NSOperation, NSOperationQueue, NSThread ,pthreads中，这篇文章中主要讲一下在dispatch_queue中的使用场景。 在官方文档中也说，关于QOS的只能在iOS8以后使用 QOS_CLASS 执行时机 相关使用场景 USER_INTERACTIVE 必须是要及时处理 等级最高。主要用户用户交互，比如主线程上的刷新用户界面等等。 USER_INITIATED 需要很快完成工作 它主要用于比如已经开了一个任务，此时需要立刻执行的场景。意思就是说需要瞬间完成的工作 ❌ DEFAULT —— 这个我们一般不使用，dispatch_get_global_queue就是这一等级。 UTILITY 可能需要相当长一段时间 不需要及时响应，比如下载操作之类的，但是用户是可以看见进度之类的 BACKGROUND 长时间类型任务 完全是后台执行，用户不知道进度的 ❌ UNSPECIFIED —— 开发人员没有指定，系统根据情况进行选定QOS等级 上诉QOS对应OC参数如下： QOS-Class 对应OC USER_INTERACTIVE NSQualityOfServiceUserInteractive USER_INITIATED NSQualityOfServiceUserInitiated UTILITY NSQualityOfServiceUtility BACKGROUND NSQualityOfServiceBackground 在dispatch_queue中，如果我们想要指定QOS的等级的话，我们可以使用函数dispatch_queue_attr_make_with_qos_class。在创建任务队列时使用方法如下： 12dispatch_queue_attr_t attr_qos = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INTERACTIVE, 0);dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, attr_qos); 因为 QOS对于dispatch_queue来说是无法变更的属性，以致于我们无法去更改已存在任务队列的QOS属性。但是我们可以使用dispatch_queue_get_qos_class函数来获取任务队列的QOS： 123456dispatch_qos_class_t qos_class = dispatch_queue_get_qos_class(the_queue, 0);/// 一般用于 根据已知队列来获取同qos等级的全局任务队列dispatch_get_global_queue(dispatch_queue_get_qos_class(the_queue, nil), 0);/// 或者是 根据已知的全局任务队列来创建与其qos相等的任务队列dispatch_queue_t the_global = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);dispatch_queue_t the_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, dispatch_queue_get_qos_class(the_global, 0), 0)); 当我们要获取全局队列时，在此之前可以使用DISPATCH_QUEUE_PRIORITY_HIGH、DISPATCH_QUEUE_PRIORITY_DEFAULT、DISPATCH_QUEUE_PRIORITY_LOW、DISPATCH_QUEUE_PRIORITY_BACKGROUND。现在我们可以使用QOS来获取一个全局的并发任务队列，因此我们有必要来了解一下它们之间的差异和共性： 以前 现在QOS Main Thread QOS_CLASS_USER_INTERACTIVE DISPATCH_QUEUE_PRIORITY_HIGH QOS_CLASS_USER_INITIATED DISPATCH_QUEUE_PRIORITY_DEFAULT QOS_CLASS_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW QOS_CLASS_UTILITY DISPATCH_QUEUE_PRIORITY_BACKGROUND QOS_CLASS_BACKGROUND 具体使用方法如下： 1dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0); 除此之外，我们还可以在dispatch_block中对每一个人任务块来设置Qos等级，这里我先将dispatch_block提出来，后面我会对其进行较为详细的解释。 1234dispatch_block_t the_block = dispatch_block_create_with_qos_class(0, QOS_CLASS_UTILITY, -8, ^&#123; ...&#125;);dispatch_async(the_queue, the_block);///dispatch_sync, dispatch_after等等需要用到dispatch_block的地方 三、创建任务 前面两点说了任务的执行地点和怎样来创建和配置任务的执行地点，但是我们必须得知道任务是什么？怎么创建任务？在GCD中使用block来作为任务提交给特定的任务队列，例如_dispatch_block_t_或者直接是一个简单的block。对于dispatch_block_t类型的变量，首先我们得要知道怎么去创建它。首先根据我们的尝试（下面的例子出自Apple官方），对block进行直接赋值： 123456789101112dispatch_block_t error_block;NSInteger x = 0;if (x) &#123; error_block = ^void(void)&#123; NSLog(@&quot;TRUE&quot;); &#125;;&#125;else&#123; error_block = ^void(void)&#123; NSLog(@&quot;FALSE&quot;); &#125;;&#125;error_block();/// unsafe 官网中解释到：“ 由于该dispatch_block_t变量是在栈内存上声明的，如果执行过该变量作用域之后就有可能导致该变量被释放 ”。到这里我们还是不得不提一下block在MRC和ARC下的区别，我们先看一篇测试，在这篇测试中很明显的一个点便是：“ MRC中有NSStackBlock类型，NSMallocBlock类型，NSGlobalBlock类型同时存在。但是在ARC中不再存在NSStackBlock类型，而是直接声明为NSMallocBlock类型” 。也就是说在ARC中就算是在函数方法中声明的block变量也是被声明为NSMallocBlock类型。 NSMallocBlock类型就不存在上诉官网中提到的变量被提前释放的问题，这一步我并没有去实践，所以上诉结论是否为真，既然官方不建议这么做，那便放弃使用该方法。使用一下两种方式来创建dispatch_block_t变量： dispatch_block_create dispatch_block_create_with_qos_class 当我们在使用上诉两种方法来创建dispatch_block_t变量时，遇到的第一个便是dispatch_block_flags_t参数。它是一个枚举类型： 枚举类型 作用 DISPATCH_BLOCK_ASSIGN_CURRENT 说明该块会被分配在创建该对象的上下文中（直接执行该块对象时推荐使用） DISPATCH_BLOCK_BARRIER 类似于在做同步操作时的barrier DISPATCH_BLOCK_DETACHED 表明dispatch_block与当前的执行环境属性无关 DISPATCH_BLOCK_ENFORCE_QOS_CLASS 当dispatch_block提交到队列或者直接提交执行做同步操作时，该值是默认值 DISPATCH_BLOCK_INHERIT_QOS_CLASS 异步执行的默认值，优先级低于DISPATCH_BLOCK_ENFORCE_QOS_CLASS。可以用该值来覆盖原来QOS类 DISPATCH_BLOCK_NO_QOS_CLASS 表明dispatch_block不分配QOS类 来创建dispatch_block变量： 12345678/// 第一种使用QOS的方式来创建dispatch_blockdispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;RUN&quot;);&#125;);/// 直接创建dispatch_blockdispatch_block_create(DISPATCH_BLOCK_NO_QOS_CLASS, ^&#123; ...&#125;); 对于dispatch_block_create_with_qos_class方法中relative_priority的参数的规则是：relative_priority的值需要在0到QOS_MIN_RELATIVE_PRIORITY（-15）之间。 我们创建的block会被拷贝到堆上，并由dispatch_block_t类型的变量所持有。创建完成之后，我们可以将其提交到对应的任务队列中（下一节提到的dispatch_async等等函数…），也可以直接去执行（比如：task_block()）。 既然可以直接去输入一个block块，那为什么我们还需要去使用dispatch_block_t？存在即有价值，那么最明显的优势便是：我们可以对该任务块执行取消操作！例如： 12345dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;RUN&quot;);&#125;);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), task_block);dispatch_block_cancel(task_block); 但是如果dispatch_block已经开始执行，便无法取消该任务的执行。比如下面的例子中，我们对上面的代码进行一点小小的修改： 1234567891011dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;RUN&quot;);/// 成功执行 /// 模拟一个长时间的耗时任务 [NSThread sleepForTimeInterval:3]; NSLog(@&quot;End&quot;);/// 成功执行&#125;);dispatch_async(dispatch_get_main_queue(), task_block);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; /// 保证dispatch_block_t已经开始执行 dispatch_block_cancel(task_block);&#125;); 在这里我们是无法去取消已经执行的块。dispatch_block_testcancel函数的作用是让我们能够知道当前任务块是否已经被取消。 在调用dispatch_block_cancel函数时，我们必须要确定即将被cancle的块没有捕获任何其他外部变量，如果持有将会造成内存泄漏。 除此之外我们来认识一下dispatch_block_wait 函数，它的作用是以同步的方式执行并等待，得等待指定的任务块执行完成之后，抑或者是超时之后然后去执行当前线程的后续任务。如下： 123456789dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;Start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;End&quot;);&#125;);dispatch_async(dispatch_get_main_queue(), task_block);NSLog(@&quot;Before Wait&quot;);dispatch_block_wait(task_block, DISPATCH_TIME_FOREVER);NSLog(@&quot;After Wait&quot;); 此时运行并不会得到Start。由于dispatch_block_wait函数是使用的同步的方式，只要是在该线程的执行流中，它不管你是同步提交还是异步提交（这两种提交方式在下面一节马上会讲）的方式，dispatch_block_wait函数如果是在被执行的block之前执行，后续的代码都会被挂起，并不仅仅是dispatch_block_wait函数后的代码，也包括block中的代码。因此也就导致了在同一个任务队列中（都处于main_queue中）的dispatch_block_t永远不会执行。解决办法也很简单，第一种我们先让block执行起来；第二种我们让它们处在不同队列中即可： 12345678910dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;Start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;End&quot;);&#125;);dispatch_queue_t block_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_async(block_queue, task_block);NSLog(@&quot;Before Wait&quot;);dispatch_block_wait(task_block, DISPATCH_TIME_FOREVER);NSLog(@&quot;After Wait&quot;); 我们可以利用这个方法来做由异步转同步的需求（后面还会介绍dispatch_semaphore_t，它同样可以达到这个效果）。 最后来看一下函数_dispatch_block_notify_，它的作用是当指定的dispatch_block_t变量执行完了之后，通知到给特定的任务队列。在上面的例子中，我们在block_queue中去执行了我们的任务块，但是我们想要在它执行完了以后在main_queue中来执行相关的操作，比如我们需要在main_queue中更新UI界面之类的： 12345678910dispatch_block_t task_block = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_INHERIT_QOS_CLASS, QOS_CLASS_USER_INITIATED, -8, ^&#123; NSLog(@&quot;Start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;End&quot;);&#125;);dispatch_queue_t block_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));dispatch_async(block_queue, task_block);dispatch_block_notify(task_block, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Notify&quot;);&#125;); 四、将任务提交到队列 在文章的最后，我们来看看怎样把已经创建好的任务提交到特定的任务队列中去！对于提交操作主要涉及到的函数有：dispatch_async、dispatch_sync、dispatch_block_perform、dispatch_group_async、dispatch_barrier_async、dispatch_barrier_sync。在这篇文章中先讲前面三个。再后面文章中详解dispatch_group_t、dispatch_barrier时在进行对应的学习。 dispatch_async使用异步地方式去提交任务块，何为异步？异步方法调用它通过使用一种立即返回的异步的变体并提供额外的方法来支持接受完成通知以及完成等待改进长期运行的(同步)方法（出自维基百科）。dispatch_sync使用同步的方式取提交任务块。下图是根据我自己的理解来解释了一下异步和同步的差异性。 上诉函数分别有对应的版本，分别是dispatch_async_f、dispatch_sync_f。它们两个和前面的区别在于，这两个函数不使用block的方式，而是使用C函数指针的方式来执行任务。它们中的context是以void *类型的变量作为参数，传递给函数指针指向的具体函数。 123456789101112131415161718/// 异步使用blockdispatch_async(queue, ^&#123; ...&#125;);/// 同步使用blockdispatch_sync(queue, ^&#123; ...&#125;);/// 异步使用函数指针dispatch_async_f(dispatch_get_main_queue(), (__bridge void * _Nullable)(self), task_place);void task_place(void *data)&#123; ...&#125;/// 同步使用函数指针dispatch_sync_f(block_queue, (__bridge void * _Nullable)(self), task_place);void task_place(void *data)&#123; ...&#125; 最后我们来看看本应属于dispatch_block_t中应该讲解的函数dispatch_block_perform，但是它作为一个提交任务的函数，放在这里讲我觉得要更为合适一点。它会创建一个dispatch_block_t变量，并在该任务队列中以同步的方式来执行block中的内容。 12345dispatch_block_perform(DISPATCH_BLOCK_BARRIER, ^&#123; NSLog(@&quot;Start&quot;); [NSThread sleepForTimeInterval:3]; NSLog(@&quot;End&quot;);&#125;); 上面的代码以下代码效果一样（取自Apple官方文档）: 123dispatch_block_t b = dispatch_block_create(flags, block);b();Block_release(b); 但是dispatch_block_perform方法可以以更加高效的方式来进行以上步骤，而不需要在对象分配时将block拷贝到指定堆中。 到这里把最基础的部分算是走了一遍，可以说是走了最小的一步，但是本文的目的是力求以清晰地路线把每一步所涉及到的知识深挖严查。在后续的文章中会继续介绍GCD中的其他函数和相关的使用方法。 相关链接以文章中出现顺序： Prioritize Work with Quality of Service Classes Concurrency Programming Guide Objective-C Blocks Quiz Transitioning to ARC Release Notes 异步调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最大堆（创建、删除、插入和堆排序）]]></title>
      <url>%2F2017%2F05%2F09%2Fdata_struct_max_heap%2F</url>
      <content type="text"><![CDATA[什么是最大堆和最小堆？最大（小）堆是指在树中，存在一个结点而且该结点有儿子结点，该结点的data域值都不小于（大于）其儿子结点的data域值，并且它是一个完全二叉树（不是满二叉树）。 注意区分选择树，因为_选择树（selection tree）_概念和最小堆有些类似，他们都有一个特点是_“树中的根结点都表示树中的最小元素结点”_。同理最大堆的根结点是树中元素最大的。那么来看具体的看一下它长什么样？（最小堆这里省略） 这里需要注意的是：在多个子树中，并不是说其中一个子树的父结点一定大于另一个子树的儿子结点。最大堆是树结构，而且一定要是完全二叉树。 最大堆ADT那么我们在做最大堆的抽象数据类型（ADT）时就需要考虑三个操作：（1）、创建一个最大堆；（2）、最大堆的插入操作；（3）、最大堆的删除操作；最大堆ADT如下： 123456789struct Max_Heap &#123; object: 由多个元素组成的完全二叉树，其每个结点都不小于该结点的子结点关键字值 functions: 其中heap∈Max_Heap,n,max_size∈int,Element为堆中的元素类型，item∈ Element Max_Heap createHeap(max_size) := 创建一个总容量不大于max_size的空堆 void max_heap_insert(heap, item ,n) := 插入一个元素到heap中 Element max_heap_delete(heap,n) := if(heap不为空) &#123;return 被删除的元素 &#125;else&#123;return NULL&#125;&#125;///其中:=符号组读作“定义为” 最大堆内存表现形式 我们只是简单的定义了最大堆的ADT，为了能够用代码实现它就必须要考虑最大堆的内存表现形式。从最大堆的定义中，我们知道不管是对最大堆做插入还是删除操作，我们必须要保证插入或者删除完成之后，该二叉树仍然是一个完全二叉树。基于此，我们就必须要去操作某一个结点的父结点。 第一种方式，我们使用链表的方式来实现，那么我们需要添加一个额外的指针来指向该结点的父结点。此时就包括了左子结点指针、右子结点指针和父结点指针，那么空链的数目有可能是很大的，比如叶子结点的左右子结点指针和根结点的父结点指针，所以不选择这种实现方式（关于用链表实现一般二叉树时处理左右子结点指针的问题在线索二叉树中有提及）。 第二种方式，使用数组实现，在二叉树进行遍历的方法分为：先序遍历、中序遍历、后序遍历和层序遍历。我们可以通过层序遍历的方式将二叉树结点存储在数组中，由于最大堆是完全二叉树不会存在数组的空间浪费。那么来看看层序遍历是怎么做的？对下图的最大堆进行层序遍历：从这里可以看出最后得到的顺序和上面图中所标的顺序是一样的。 那么对于数组我们怎么操作父结点和左右子结点呢？对于完全二叉树采用顺序存储表示，那么对于任意一个下标为i(1 ≤ i ≤ n)的结点：（1）、父结点为：_i / 2（i ≠ 1）_，若i = 1，则i是根节点。（2）、左子结点：_2i（2i ≤ n）_， 若不满足则无左子结点。（3）、右子结点：_2i + 1(2i + 1 ≤ n)_，若不满足则无右子结点。 最终我们选择_数组_作为最大堆的内存表现形式。 基本定义: 1234567#define MAX_ELEMENTS 20#define HEAP_FULL(n) (MAX_ELEMENTS - 1 == n)#define HEAP_EMPTY(n) (!n)typedef struct &#123; int key;&#125;element;element heap[MAX_ELEMENTS]; 下面来看看最大堆的插入、删除和创建这三个最基本的操作。 最大堆的插入最大堆的插入操作可以简单看成是“结点上浮”。当我们在向最大堆中插入一个结点我们必须满足完全二叉树的标准，那么被插入结点的位置的是固定的。而且要满足父结点关键字值不小于子结点关键字值，那么我们就需要去移动父结点和子结点的相互位置关系。具体的位置变化，可以看看下面我画的一个简单的图。 12345678910void insert_max_heap(element item ,int *n)&#123; if(HEAP_FULL(*n))&#123; return; &#125; int i = ++(*n); for(;(i != 1) &amp;&amp; (item.key &gt; heap[i/2].key);i = i / 2)&#123;/// i ≠ 1是因为数组的第一个元素并没有保存堆结点 heap[i] = heap[i/2];/// 这里其实和递归操作类似，就是去找父结点 &#125; heap[i] = item;&#125; 由于堆是一棵完全二叉树，存在n个元素，那么他的高度为:_log2(n+1)_，这就说明代码中的for循环会执行_O(log2(n))_次。因此插入函数的时间复杂度为：_O(log2(n))_。 最大堆的删除最大堆的删除操作，总是从堆的根结点删除元素。同样根元素被删除之后为了能够保证该树还是一个完全二叉树，我们需要来移动完全二叉树的最后一个结点，让其继续符合完全二叉树的定义，从这里可以看作是_最大堆最后一个结点的下沉_操作。例如在下面的最大堆中执行删除操作： 1234567解答：1）、对于最大堆的删除，我们不能自己进行选择删除某一个结点，我们只能删除堆的根结点。因此在图a中，我们删除根结点20；2）、当删除根结点20之后明显不是一个完全二叉树，更确切地说被分成了两棵树。3）、我们需要移动子树的某一个结点来充当该树的根节点，那么在(15,2,14,10,1)这些结点中移动哪一个呢？显然是移动结点1，如果移动了其他结点（比如14，10）就不再是一个完全二叉树了。4）、此时在结点（15，2）中选择较大的一个和1做比较，即15 &gt; 1的，所以15上浮到之前的20的结点处。5）、同第4步类似，找出（14，10）之间较大的和1做比较，即14&gt;1的，所以14上浮到原来15所处的结点。6）、因为原来14的结点是叶子结点，所以将1放在原来14所处的结点处。 这图中是用temp分别和图中的max做比较，来看temp是否会下沉 12345678910111213141516171819element delete_max_heap(int *n)&#123; int parent, child; element temp, item; temp = heap[(*n)--]; item = heap[1]; parent = 1,child=2; for(;child &lt;= *n; child = child * 2)&#123; if( (child &lt; *n) &amp;&amp; heap[child].key &lt; heap[child+1].key)&#123;/// 这一步是为了看当前结点是左子结点大还是右子结点大，然后选择较大的那个子结点 child++; &#125; if(temp.key &gt;= heap[child].key)&#123; break; &#125; heap[parent] = heap[child];///这就是上图中第二步和第三步中黄色部分操作 parent = child;/// 这其实就是一个递归操作，让parent指向当前子树的根结点 &#125; heap[parent] = temp; return item;&#125; 同最大堆的插入操作类似，同样包含n个元素的最大堆，其高度为:_log2(n+1)_，其时间复杂度为：_O(log2(n))_。 总结：由此可以看出，在已经确定的最大堆中做删除操作，被删除的元素是固定的，需要被移动的结点也是固定的，这里我说的被移动的元素是指最初的移动，即最大堆的最后一个元素。移动方式为从最大的结点开始比较。 最大堆的创建为什么要把最大堆的创建放在最后来讲？因为在堆的创建过程中，有两个方法。会分别用到最大堆的插入和最大堆的删除原理。创建最大堆有两种方法：（1）、先创建一个空堆，然后根据元素一个一个去插入结点。由于插入操作的时间复杂度为_O(log2(n))_，那么n个元素插入进去，总的时间复杂度为_O(n * log2(n))_。（2）、将这n个元素先顺序放入一个二叉树中形成一个完全二叉树，然后来调整各个结点的位置来满足最大堆的特性。现在我们就来试一试第二种方法来创建一个最大堆：假如我们有12个元素分别为： 1&#123;79,66,43,83,30,87,38,55,91,72,49,9&#125; 将上诉15个数字放入一个二叉树中，确切地说是放入一个完全二叉树中，如下：但是这明显不符合最大堆的定义，所以我们需要让该完全二叉树转换成最大堆！怎么转换成一个最大堆呢？ 最大堆有一个特点就是其各个子树都是一个最大堆，那么我们就可以从把最小子树转换成一个最大堆，然后依次转换它的父节点对应的子树，直到最后的根节点所在的整个完全二叉树变成最大堆。那么从哪一个子树开始调整？ 我们从该完全二叉树中的最后一个非叶子节点为根节点的子树进行调整，然后依次去找倒数第二个倒数第三个非叶子节点… 具体步骤在做最大堆的创建具体步骤中，我们会用到最大堆删除操作中结点位置互换的原理，_即关键字值较小的结点会做下沉操作_。 1）、就如同上面所说找到二叉树中倒数第一个非叶子结点87，然后看以该非叶子结点为根结点的子树。查看该子树是否满足最大堆要求，很明显目前该子树满足最大堆，所以我们不需要移动结点。_该子树最大移动次数为1_。 2）、现在来到结点30，明显该子树不满足最大堆。在该结点的子结点较大的为72，所以结点72和结点30进行位置互换。_该子树最大移动次数为1_。 3）、同样对结点83做类似的操作。_该子树最大移动次数为1_。 4）、现在来到结点43，该结点的子结点有{87,38,9}，对该子树做同样操作。由于结点43可能是其子树结点中最小的，所以_该子树最大移动次数为2_。 5）、结点66同样操作，_该子树最大移动次数为2_。 6）、最后来到根结点79，该二叉树最高深度为4，所以_该子树最大移动次数为3_。 自此通过上诉步骤创建的最大堆为: 所以从上面可以看出，该二叉树总的需要移动结点次数最大为：10。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void create_max_heap(void)&#123; int total = (*heap).key; /// 求倒数第一个非叶子结点 int child = 2,parent = 1; for (int node = total/2;node &gt; 0; node--) &#123; parent = node; child = 2*node; int max_node = 2*parent+1; element temp = *(heap + parent); for(;child &lt;= max_node &amp;&amp; max_node &lt;= total; child = child * 2,max_node = 2*parent+1)&#123; if ((*(heap + child)).key &lt; (*(heap + child + 1)).key) &#123;/// 取右子结点 child++; &#125; if (temp.key &gt; (*(heap + child)).key) &#123; break; &#125; *(heap + parent) = *(heap + child); parent = child; &#125; *(heap + parent) = temp; &#125;&#125;/** * * @param heap 最大堆； * @param items 输入的数据源 * @return 1成功，0失败 */int create_binary_tree(element *heap,int items[MAX_ELEMENTS])&#123; int total; if (!items) &#123; return 0; &#125; element *temp = heap; heap++; for (total = 1; *items;total++,(heap)++,items = items + 1) &#123; element ele = &#123;*items&#125;; element temp_key = &#123;total&#125;; *temp = temp_key; *heap = ele; &#125; return 1;&#125;///函数调用int items[MAX_ELEMENTS] = &#123;79,66,43,83,30,87,38,55,91,72,49,9&#125;;element *position = heap;create_binary_tree(position, items);for (int i = 0; (*(heap+i)).key &gt; 0; i++) &#123; printf(&quot;binary tree element is %d\n&quot;,(*(heap + i)).key);&#125;create_max_heap();for (int i = 0; (*(heap+i)).key &gt; 0; i++) &#123; printf(&quot;heap element is %d\n&quot;,(*(heap + i)).key);&#125; 上诉代码在我机器上能够成功的构建一个最大堆。由于该完全二叉树存在n个元素，那么他的高度为:_log2(n+1)_，这就说明代码中的for循环会执行_O(log2(n))_次。因此其时间复杂度为：_O(log2(n))_。 堆排序 堆排序要比空间复杂度为_O(n)_的归并排序要慢一些，但是要比空间复杂度为_O(1)_的归并排序要快！ 通过上面最大堆创建一节中我们能够创建一个最大堆。出于该最大堆太大，我将其进行缩小以便进行画图演示。最大堆的排序过程其实是和最大堆的删除操作类似，由于最大堆的删除只能在根结点进行，当将根结点删除完成之后，就是将剩下的结点进行整理让其符合最大堆的标准。 1）、把最大堆根结点91“删除”，第一次排序图示：进过这一次排序之后，91就处在最终的正确位置上，所以我们只需要对余下的最大堆进行操作！这里需要注意一点： ⚠️⚠️⚠️注意，关于对余下进行最大堆操作时：并不需要像创建最大堆时，从倒数第一个非叶子结点开始。因为在我们只是对第一个和最后一个结点进行了交换，所以_只有根结点的顺序不满足最大堆的约束，我们只需要对第一个元素进行处理即可_ 2）、继续对结点87进行相同的操作：同样，87的位置确定。 3）、现在我们来确定结点83的位置： 4）、经过上诉步骤就不难理解堆排序的原理所在，最后排序结果如下： 经过上诉多个步骤之后，最终的排序结果如下： 1[38、43、72、79、83、87、91] 很明显这是一个正确的从小到大的顺序。 编码实现这里需要对上面的代码进行一些修改！因为在排序中，我们的第0个元素是不用去放一个哨兵的，我们的元素从原来的第一个位置改为从第0个位置开始放置元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void __swap(element *lhs,element *rhs)&#123; element temp = *lhs; *lhs = *rhs; *rhs = temp;&#125;int create_binarytree(element *heap, int items[MAX_SIZE], int n)&#123; if (n &lt;= 0) return 0; for (int i = 0; i &lt; n; i++,heap++) &#123; element value = &#123;items[i]&#125;; *heap = value; &#125; return 1;&#125;void adapt_maxheap(element *heap ,int node ,int n)&#123; int parent = node - 1 &lt; 0 ? 0 : node - 1; int child = 2 * parent + 1;/// 因为没有哨兵，所以在数组中的关系由原来的：parent = 2 * child =&gt; parent = 2 * child + 1 int max_node = max_node = 2*parent+2 &lt; n - 1 ? 2*parent+2 : n - 1; element temp = *(heap + parent); for (;child &lt;= max_node; parent = child,child = child * 2 + 1,max_node = 2*parent+2 &lt; n - 1 ? 2*parent+2 : n - 1) &#123; if ((heap + child)-&gt;key &lt;= (heap + child + 1)-&gt;key &amp;&amp; child + 1 &lt; n) &#123; child++; &#125; if ((heap + child)-&gt;key &lt; temp.key) &#123; break; &#125; *(heap + parent) = *(heap + child); &#125; *(heap + parent) = temp;&#125;int create_maxheap(element *heap ,int n)&#123; for (int node = n/2; node &gt; 0; node--) &#123; adapt_maxheap(heap, node, n); &#125; return 1;&#125;void heap_sort(element *heap ,int n)&#123; ///创建一个最大堆 create_maxheap(heap, n); ///进行排序过程 int i = n - 1; while (i &gt;= 0) &#123; __swap(heap+0, heap + i);/// 将第一个和最后一个进行交换 adapt_maxheap(heap, 0, i--);///将总的元素个数减一，适配成最大堆，这里只需要对首元素进行最大堆的操作 &#125;&#125; 调用：123456/// 堆排序int n = 7;int items[7] = &#123;87,79,38,83,72,43,91&#125;;element heap[7];create_binarytree(heap, items, n);heap_sort(heap, n); 在实现堆排序时最需要注意的就是当没有哨兵之后，父结点和左右孩子结点之间的关系发生了变化：12parent = 2 * child + 1;///左孩子parent = 2 * child + 2;///右孩子 关于对排序相关的知识点已经整理完了。其时间复杂度和归并排序的时间时间复杂度是一样的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈（Stack）和堆（Heap）]]></title>
      <url>%2F2017%2F03%2F21%2Fstack_heap_with_c%2F</url>
      <content type="text"><![CDATA[目前来说我们知道怎么去声明一个基础类型的变量，比如int，float，等等。以及复杂数据类型数组和结构，声明它们的时候C会把这些变量放在栈上。每个线程都有一个栈，而程序通常只有一个堆。 栈（Stack） 什么是栈？它是内存中一块特殊的区域，用于保存在函数中声明的零时变量（其中也包括main()函数）。栈是LIFO(Last in First Out 后进先出)的数据结构，进出操作是由CPU来管理和优化的。每当函数声明了一个变量，该变量就会被推入(Pushed)栈中。每当函数退出时，所有的变量都会被函数推出栈，并被释放掉(Free)。一旦变量被释放，该内存区域就可以被其他栈变量使用。 使用栈的优势是它会为你管理内存，而不需要你手动去分配或者释放内存。更进一步说，由于CPU可以有效地管理栈内存，所以从栈中读写变量是很快的。 理解栈的关键是需要知道函数什么时候退出，此时栈中所有的变量被推出，因此栈变量是局部的（也就是局部变量）。C中经常出现的一个错误就是，在函数返回以后去访问函数内部中栈变量。 如果使用太多的栈空间会导致溢出，比如在使用递归的时候，该函数使用了太多的局部变量在递归过程中就有可能造成栈溢出。 总结 栈是LIFO数据结构； CPU管理内存，而不需要手动去管理。正是因为这个原因从栈中读写变量很快的； 栈变量是局部的（也就是局部变量）； 栈的容量会随着函数的Push和Pop变化； 堆（Heap） 堆也是内存中一块特定区域，但是CPU并不会自动管理相关的操作，而且它的空间大小会有一定的浮动。在堆上分配内存的时候，在C中使用malloc()和calloc()函数。在不需要堆上这块内存之后，需要使用free()函数释放掉它。如果不释放的话就会造成内存泄漏，这块内存就会被闲置。 和栈不同之处在于，堆内存数据的读写速度会比栈慢。 栈（Stack）和堆（Heap）的差异配置堆栈大小 堆的大小在程序启动时分配，数值在不同操作系统中可能有所不同。 在Cocoa中想要修改线程的栈大小的话，可以使用NSThread的实例方法setStackSize:，如果使用POSIX线程技术创建的线程的话，想要设置栈大小的话使用pthread_attr_setstacksize函数。 ⚠️如果要设置栈大小就必须要在创建线程之前完成。 123456789101112131415/// 第一种NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(backgroudMethod:) object:nil];[thread setStackSize:1024];[thread start];/// 第二种pthread_attr_t attr;pthread_t posix_tread_id;int returnVal;returnVal = pthread_attr_init(&amp;attr);returnVal = pthread_attr_setstacksize(&amp;attr, 1024);/// 在创建线程前设置堆栈大小char *data;data = &quot;To ensure that a thread knows what work to do&quot;;int thread_error = pthread_create(&amp;posix_tread_id, &amp;attr, posix_thread_mainroutine, data); 生命周期 栈是和线程相关联的，意思就是说当线程退出时，栈被回收。而堆通常是在启动程序时分配，当程序退出之后被回收。 什么时候使用栈什么时候使用堆 需要申请较大内存空间（比如struct，array之类的），而且需要该变量存在较长时间，就是将该变量放在堆中； 如果需要动态修改struct或者array的大小，将该变量放在堆上。使用malloc()，calloc()，realloc()和free()等函数来管理内存； 如果使用相对较小的变量，并且只在函数中使用它们，此时该变量就存在于栈上。这样做会更快而且更简单；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动画中关于KVC官方文档翻译]]></title>
      <url>%2F2017%2F03%2F08%2Fanimation_kvc_translate%2F</url>
      <content type="text"><![CDATA[CoreAnimation让CAAnimation和CALayer都遵守NSKeyValueCoding协议，因此为它们增加了一些默认的keys（对应的value），添加的keyPath中包含了了CGPoint,CGRect,CGSize和CATransform3D类型。 1.键值编码兼容的容器类CAAnimation和CALayer类就是作为键值编码兼容的容器类，我们可以根据任意的keys来设置对应的value，即便这个key不是CALayer公开的属性，比如：1[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@&quot;someKey&quot;]; 同样也可以通过任意已知的keys来查找对应的values，可以使用下面的代码通过预先设置好的somekey来检索values：1someKeyValue=[theLayer valueForKey:@&quot;someKey&quot;]; 2.默认支持的valueCoreAnimation在键值编码时规定：一个类可以给没有value的key提供一个默认值。CAAnimation和CALayer类都提供了类方法defaultValueForKey。 对于为key提供了默认value的类，在创建这个类的子类时必须要重写它的defaultValueForKey方法。 当你在实现这个方法的时候，需要检查key的参数列表，并且返回一个合适的value值，下面提供了一个例子，layer提供了defaultValueForKey:方法，为maskToBounds属性设置默认值：12345+ (id)defaultValueForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;masksToBounds&quot;]) return [NSNumber numberWithBool:YES]; return [super defaultValueForKey:key];&#125; 3.封装当一个key的数据是由一个标量值或者一个C的数据结构时，你必须要在其被分配到layer之前对其进行封装。同样的，当要访问这些Type时，也必须检查对象，然后使用合适的方法来打开合适的值。下表显示了Objective-c和c类型封装 C type 输入 CGPoint NSValue CGSize NSValue CGRect NSValue CATransform3D NSValue CGAffineTransform NSAffineTransform (OS X only) 不同类型封装的类 4.为KeyPath的提供的结构CAAnimation和CALayer类使用KeyPath来访问指定的字段，这功能可以让你在做动画时为特定的KeyPath提供数据。使用setValue:forKeyPath和valueForKeyPath:方法设置，然后用valueForKeyPath:获取相应的值。 (1)、CATransform3D KeyPaths你可以使用更强大的KeyPath，查找包含了CATransform3D类型属性的值。在需要指定layer的transforms完整的KeyPath时，我们可以根据下表中提供的数据，使用transform和sublayerTransform的值。例如，我们需要制定绕着layer的z轴旋转时，我就需要指定KeyPath为transform.rotation.z。 Field Key Path 描述 rotation.x 围绕X轴，旋转值为弧度，NSNumber类型 rotation.y 围绕y轴，旋转值为弧度，NSNumber类型 rotation.z 围绕z轴，旋转值为弧度，NSNumber类型 rotation 围绕z轴，旋转值为弧度，NSNumber类型，它和设置rotation.z一样 scale.x x轴缩放，NSNumber类型 scale.y y轴缩放，NSNumber类型 scale.z z轴缩放，NSNumber类型 scale 三个轴缩放的平均值，NSNumber类型 translation.x x轴位移，NSNumber类型 translation.y y轴位移，NSNumber类型 translation.z z轴位移，NSNumber类型 translation x，y上面位移，NSSize 和CGSize 下面展示了怎样通过setValue:forKeyPath方法来修改一个layer，这个例子设置了layer在x轴上位移了10个像素点，来显示layer在x轴上的移动:1[myLayer setValue:[NSNumber numberWithFloat:10.0] forKeyPath:@&quot;transform.translation.x&quot;]; ⚠注意：通过keyPath来设置value值的时候不能像Objective-C里面对属性的赋值，必须配合KeyPath字符串使用setValue:forKeyPath方法来进行赋值。 (2)、CGPoint KeyPath如果当前给的是一个CGPoint类型，则可以根据下表进行设置。例如，当我们想要修改layer的position的x值时，可以在KeyPath中写position.x。 Structure Field 描述 x x的分量 y y的分量 (3)、CGSize KeyPath Structure Field 描述 width size的width值 height size的height值 (4)、CGRect KeyPath例如，要更改layer的bounds属性的width值，可以写入关键路径bounds.size.width Structure Field 描述 origin 坐标，类型CGPoint origin.x 坐标的x值，类型CGFloat origin.y 坐标的y值，类型CGFloat size 大小，类型CGSize size.width size的width值 size.height size的height值 结语翻译这篇文章的目的因为我在做动画中需要每次都差到对应的KeyPath，很麻烦，索性我就将其翻译出来。到目前为止，这片文章大部分翻译算是完成了，看起来很粗糙，能看懂就最好了。 原来地址：Key-Value Coding Extensions]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unicode和UTF-8、UTF-16以及UTF-32]]></title>
      <url>%2F2017%2F03%2F02%2Funicode%2F</url>
      <content type="text"><![CDATA[写在前面如果你是iOS开发者，并且在处理NSString字符上遇到了一些问题，强烈建议去看看Objc中国上关于 NSString 与 Unicode。上面介绍了一些关于NSString相关的东西，比如characterAtIndex:返回的可能是包含组合序列（emoji最为常见）等等。 简介Unicode对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。这是维基百科对Unicode下的定义。Unicode的实现方式包含了UTF-8、UTF-16（字符用两个字节或者四个字节表示）和UTF-32（用四个字节来表示），下面对面一一进行介绍。 UTF-8UTF-8的最明显的一个特点是它是变长的，它可以使用1到4个字节表示一个符号，根据不同的符号变化字节长度。先把阮一峰在《字符编码笔记：ASCII，Unicode和UTF-8》中对UTF-8的编写规则的一个总结放出来。 ️️️UTF-8的编码规则很简单，只有二条：1、对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2、对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 我的解释：第一个字节前面n为设1是为了知道当前字符占用多少字节，而后面字节的前两位为什么要设置为10下面会马上进行解释。现在我们来具体的分析一下Unicode的不同范围：下面中前两个描述是否为ASCII，后两个描述多字节序列 U+0000到U+007F（ASCII）从U+0000到U+007F被编码为0x00~0x7F的单字节，这是ASCII码的所有字符，一共128个字符，所以Unicode是完全用来容纳ASCII的。对于上面结论中提到的后面字节的前两位一律设为10因为必须要大于7F才和ASCII码分开。 大于 U+007F（非 ASCII）所有大于 U+007F 的字符被编码为一串多字节序列，这样就可以区分一串多字节序列是多字节码还是 ASCII 码。 0xFE 和 0xFF 不会被用于 UTF-8 编码中。 多字节序列的第一个字节在0xC0~0xFD中，剩余字节在0x80~0xBF内。这里解释一下为什么第一个是在0xC0~0xFD中，理解这里需要再回去看看上面注意中提到的Unicode编码规则。因为表示的是多字节就表明n是大于1的，所以第一个字节最小的值为：11000000即C0（每四位表示一个十六进制数，这也是为什么在编程的时候喜欢用十六进制数的原因），如果在没有限制的情况下，通过上面的结论我们可以得到第一个字节能表示的最大的数是0xFE（11111110），就是前面7位设置1最后一位设置为0，但是上面一条中提到不包含FE，所以第一个字节的最大值为0xFD(11111101)。同理因为后面字节的前两位一律设为10所以多字节除了第一个字节的其他字节最大值为10111111(BF)。 总结UTF-8 编码字符最长可达六个字节 1234567Unicode 字符: UTF-8 码:U-00000000 - U-0000007F: 0xxxxxxx ///表示ASCIIU-00000080 - U-000007FF: 110xxxxx 10xxxxxx ///U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxxU-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxxU-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxxU-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 举个例子：汉字“王”的Unicode码为U+73B8转换为二进制为:0111 0011 1010 1000，”73b8”位于上面的第三类，把转换的16个二进制依次放入（一定是依次放入不管空格的）上诉的x中： 123411100111 10001110 10101000/// 同样我们来验证一下阮一峰举例的“严”字/// 4E25 同样属于上诉的第三类 ，对应的二进制 =&gt; 0100 1110 0010 0101/// 11100100 10111000 10100101 得到的结果和他文章中的一样。 到这里我自己觉得应该是把UTF-8的编码方式说清楚了，最后再来一个编码的顺序（很适合于我的方式） 编码的顺序对于单字节：直接将其转换为八位的二进制就可以了；对于多字节：1.找到Unicode码对应的二进制数据2.查看该Unicode码在分类中属于第几类3.一次填入二进制码 UTF-16UTF-16是Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为”storage format”）的一种实现方式。即把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。这里需要说明一下基本多文种平面-BMP和辅助平面-SMP，在维基百科中每一个平面相关的图片下面都说了”每个写着数字的格子代表256个码点”，即00~FF。例如：位于BMP中00格子中的一个码点表示为:0x00E5。下面同样用一下阮一峰的规则总结： 基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。 为了能够区分它本身是一个字符，还是需要跟其他两个字节放在一起解读。在BMP中，从U+D800到U+DFFF之间BMP的区段是永久保留不映射到字符（从维基百科的图中D8~DF之间表示unallocated code points）。 UTF-16结论(D800~DFFF)具体来说，辅助平面的字符位共有pow(2,20)个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小pow(2,10)），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小pow(2,10)），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。1HHHH HHHH HHLL LLLL LLLL ️注意-结论高位：D800~DBFF;低位：DC00~DFFF; 所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。（这里我就直接引用阮一峰的解释，因为他解释很通俗易懂。） 解释一下这里为什么是pow(2,20)，在基本平面之外有16个辅助平面（即pow(2,4)），而每一个辅助平面pow(2,16)个码位（辅助平面和基本平面一样，每个码位里面都包含了256个码点）。123///辅助平面字符，转码公式。H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00 H为上文提到的高位，L位上文提到的低位。举例说明一下:1234567/// 对于小于0xFFFF的即基本平面的字符，为两个字节U+8D9E = 0x8D9E ///对应的二进制格式为:10001101 10011110/// 对出于辅助平面的字符/// 对于U+1D306H = Math.floor((0x1D306-0x10000) / 0x400)+0xD800 = d834L = (0x1D306 - 0x10000) % 0x400 + 0xDC00 = df06 UTF-32因为UTF-32对每个字符都使用4字节，就空间而言，是非常没有效率的。特别地，非基本多文种平面的字符在大部分文件中通常很罕见，以致于它们通常被认为不存在占用空间大小的讨论，使得UTF-32通常会是其它编码的二到四倍。 结论所以当我们在使用字符串的时候，通常使用length的时候，要看他的编码方式，并不是一个字符就代表了一个字节有可能是两个字节、四个字节甚至可能最多能到6个字节都是有可能的，这应该就能理解Swift中对于字符串的处理了。 参考文献Unicode代码图表字符编码笔记：ASCII，Unicode和UTF-8什么是UTF-8Unicode与JavaScript详解Unicode编码及其实现：UTF-16、UTF-8，and moreUTF-16UTF-32]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3 Unsafe[Mutable]Pointer]]></title>
      <url>%2F2017%2F03%2F02%2Fswift3_pointer%2F</url>
      <content type="text"><![CDATA[这篇文章水准不高，可能因为我自己能力有限，英文水平也就这样，自己能看懂，可能存在误人子弟的可能性，所以如果有人有机会看到了这边文章就当是一个小白的入门级的笔记吧！如果需要更深入的了解请查看文末的参考链接为了将我的PhotoCutter适配Swfit3一看到一大堆的Unsafe[Mutable]Pointer的错误就是脑壳疼！最头疼的事没有找到这方面的中文资料，只有自己来弄了，然后记录一下，现在项目还是用OC，一天不写就生疏,怕以后来自己又忘记了，然后自己纪录一下吧… 这里我先粗略地介绍：1.我的理解:UnsafeMutablePointer其实就是UnsafePointer的可以变化的类型，但是UnsafePointer又不允许你去改变指针元素 2.Unsafe[Mutable]RawPointer:在swift3以前为Unsafe[Mutable]Pointer&lt;Void&gt;,也就是c中的void * 3.Unsafe[Mutable]BufferPointer表示一连串的数组指针 withUnsafePointer/withUnsafeMutablePointer比如下面我用c的方式创建和销毁了一个int型的指针a: int \*a = malloc(sizeof(int)); \*a = 10; free(a) 假设在swift中`var a:Int = 10`,现在我们的目的是想创建一个指针a,我们需要将`a`转成`*a`，我们需要怎么做呢？这里可以用到`withUnsafePointer/withUnsafeMutablePointer` 这两个函数会以swift类型和一个block为参数，而这个目的指针就是这个block的参数。也就是说你想将某一个swift类型的参数转换为一个指针result，这个result就是你想获得的指针，也就是下面两个例子中的ptr，希望我这个描述没有把你绕晕！ 这里我也以swift.org上面的socket例子来写吧! var addrin = sockaddr_in() 创建UnsafeMutablePointer withUnsafeMutablePointer(to: &addrin) { ptr in //ptr:UnsafeMutablePointer\ } 创建UnsafePointer withUnsafePointer(to: &addrin) { ptr in //ptr: UnsafePointer\ } withUnsafeBytes/withUnsafeMutableBytes通过withUnsafeBytes/withUnsafeMutableBytes获得的bytes只能在在函数closure里面进行使用，这个函数只相对于Data类型来获取bytes使用！ func unsafebytes() { guard let data = ".".data(using: .ascii) else{ return } data.withUnsafeBytes { (byte:UnsafePointer) -> Void in print(byte) } } unsafebytes() withMemoryRebound我们可以使用withMemoryRebound函数，来将一个类型的指针转换为另外一个类型的指针，使用这个函数的时候也有一些需要注意点，在[UnsafeRawPointer Migration] (1)的介绍中说到:Conversion from UnsafePointer&lt;T&gt; to UnsafePointer&lt;U&gt; has been disallowed，所以只能将UnsafePointer&lt;Int&gt;转换为UnsafeMutablePointer&lt;UInt8&gt;. UnsafePointer -&gt; UnsafeMutablePointer var a = 10 withUnsafePointer(to: &a) { a_pt in a_pt.withMemoryRebound(to: UInt8.self, capacity: 1, { a_pt_uint8 in //a_pt_uint8:UnsafeMutablePointer }) } 具体的使用场景:在使用socket的时候需要bind或者connect的时候这个函数的具体使用场景在[UnsafeRawPointer Migration] (1)中也有提到。sockaddr_in －&gt; sockaddr var addrin = sockaddr_in() let sock = socket(PF_INET, SOCK_STREAM, 0) let result = withUnsafePointer(to: &addrin) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { connect(sock, $0, socklen_t(MemoryLayout.stride)) } } assumingMemoryBound将UnsafeRawPointer转换为UnsafePointer&lt;T&gt;类型，也就是swift3之前的UnsafePointer&lt;Void&gt;到UnsafePointer&lt;T&gt;。这个和前面提到的函数withMemoryRebound的区别就是: assumingMemoryBound可以看成是withMemoryRebound的一个特例，即:assumingMemoryBound为UnsafePointer&lt;Void&gt;到UnsafePointer&lt;T&gt;，withMemoryRebound为UnsafePointer&lt;U&gt;到UnsafeMutablePointer&lt;T&gt; 代码示例: let strPtr = UnsafeMutablePointer\.allocate(capacity: 1) let rawPtr = UnsafeRawPointer(strPtr) let intPtr = rawPtr.assumingMemoryBound(to: Int.self) bindMemory绑定一个类型\到已经被分配的内存空间，返回一个绑定在self内存上UnsafePointer&lt;T&gt;的指针，需要注意的是这个函数是用于Unsafe[Mutable]RawPointer。 /// - Precondition: The memory is uninitialized. /// - Postcondition: The memory is bound to 'T' starting at `self` continuing /// through `self` + `count` * `MemoryLayout.stride` /// - Warning: Binding memory to a type is potentially undefined if the /// memory is ever accessed as an unrelated type. 操作 内存状态 类型 rawptr = allocate() uninitialized None tptr = rawptr.bindMemory(T) uninitialized bound to T tptr.initialize() initialized bound to T 从上面的表格结合文档里面对于bindMemory的说明来看，我对于bindMemory的理解就是，使用函数之前这块内存空间是没有被初始化的，使用bindMemory的目的是将T绑定到self后面self + count MemoryLayout&lt;T&gt;.stride长度的的这块内存空间上来。但是绑定上来并不代表初始化了，此时这个内存空间仍然是没有初始化的，所以最后需要调用函数initialize的函数来初始化!用这个函数同样可以把`void `的C类型转换为Swift的类型。关于Custom memory allocation这个函数的使用可能会有问题…先上一段我自己理解的代码吧 let a = 100 let a_rawptr = UnsafeMutableRawPointer.allocate(bytes: MemoryLayout\.size, alignedTo: MemoryLayout\.alignment) let bind_rawptr = a_rawptr.bindMemory(to: Int.self, capacity: MemoryLayout\.stride) bind_rawptr.initialize(to: a) unsafeBitCast返回一个翻译成某一特定类型的值！,这个会破坏Swift的类型系统！ 特别注意️:不到万不得已不要使用这个函数 实战PhotoCutter为了适配Swift3，这其中大部分和指针相关的东西需要适配，我开始看到这些也是懵逼的，根本不懂怎么改，只有自己去慢慢学。我的方法可能很差，就目前而言是适配了，下面贴上我的修改的代码吧! Swift2.x options = CFDictionaryCreate(kCFAllocatorDefault, UnsafeMutablePointer(UnsafePointer(keys)), UnsafeMutablePointer(UnsafePointer(values)), 2, &kcKeysBack, &kcValuesBack) Swift3.0 fileprivate func buffer(to type:T.Type, source:[T]) -> UnsafeMutablePointer{ var buffer = UnsafeMutablePointer.allocate(capacity: source.count) for idx in 0..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建一个更轻的ViewController]]></title>
      <url>%2F2017%2F03%2F02%2Flight_viewcontroller%2F</url>
      <content type="text"><![CDATA[现在的项目越来越臃肿，一个控制器的代码量越来越多，业务最繁重的一个控制器代码量已经达到了1000多行！这就导致给控制器瘦身是一定要做的。说实话这种的是很不好组织语言的，但是还是按照惯例还是在这里来记录一下自己想法经历和结果。 注意:文中会同时出现Swift代码和objc代码，出现这个的原因是为了演示针对使用AF进行网络请求和数据处理，就用了其他工程的代码来进行演示。样例工程是用Swift写的没有集成AF库，只是模拟了一个网络请求，但是Swift的代码同样适用于objc，这里大多的管理类都是继承自NSObject，希望见谅吧。 目标现在我们的目的是来分离一个登录页面的Controller。我先把这个界面的效果图放出来 分析这个页面比较简单，一个简单的输入用户名称和密码，然后登录给出正确还是错误的结果！这里需要简单处理一下用户名密码的输入情况来绝对按钮的颜色的交互情况。我将一个业务场景进行划分可以分为以下5个： 1.控制器 ———-Controller2.视图 ————-ViewOperator3.网络请求——-Request4.数据处理——-DataManager5.协议代理——-Delegate 职责划分1.控制器(Controller)控制器的职责需要统调视图(ViewOperator),网络请求(Request),数据处理(DataManager),代理协议(Delegate)以及不同控制器之间的联系。 2.视图(ViewOperator)ViewOperator的作用是将控制器里面与视图相关的操作剥离出来。同时也包括了按钮的点击。 3.协议代理(Delegate)剥离出controller中的delegate的回调，比如登录界面UITextField的相关代理操作，也可以是TableView的delegate和dataSource的分离。 4.网络请求(Request)分离控制器中的网络请求部分，比如在一个包含了tableView的界面，数据加载，下拉刷新，上拉加载的相关方法. 5.数据处理(DataManager)在网络请求完成的回调，回调回来的数据是不需要放在网络请求里面去做的，所以将网络请求数据回调放在DataManager中来。数据处理完成是需要给Controller一个数据回调的。 第一步来分离Controller中的视图通常视图相关的操作如果都放在Controller会产生很多行的代码的，所以第一步我们需要将控制器和视图相关操作分离出来。在使用StoryBoard来创建一个ViewController时，需要在控制器中拖一些button,label,textfield等等控件，这些控件的定制以及交互等等都要拖出代码进行处理。所以这里我可以给当前控制器的Scene添加一个object 然后自定义个LoginViewOperator来继承自NSObject，将这个object的CustomClass改为LoginViewOperator。此时你可以将上诉的控件都拖到这个class里面，比如: public class LoginViewOperator:NSObject{ @IBOutlet var fields: [UITextField]! @IBOutlet weak var login_btn: UIButton! @IBOutlet weak var indicator: UIActivityIndicatorView! @IBAction func login(_ sender: UIButton) { } } 同时我也可以直接将LoginViewOperator拖到Controller中，来让Controller来管理LoginViewOperator `。 class LoginViewController { @IBOutlet var view_operator: LoginViewOperator! } 如果有自定义视图的话，自定义视图的相关操作可以放在这个类中去做，或者可以给这个视图添加一个helper(CustomViewHelper)通过他来做自定义视图的相关操作 第二步来分离Controller中的代理协议加入在一个业务场景中有一个tableView，或者textfield，或者其他的系统的控件等等，和他们打交道肯定需要回调的，把这些放在控制器中也是很占位置的，必须将他们分离出来。在当前场景主要是UITextFieldDelegate的分离，我们需要创建一个类继承自NSObject,并让他遵守UITextFieldDelegate。 public class EDLoginTextFieldDelegate:NSObject{ public var textdidChange:((UITextField)->Void)? } extension EDLoginTextFieldDelegate:UITextFieldDelegate{ public func textFieldDidChange(_ textField: UITextField){ textdidChange?(textField) } public func textFieldShouldReturn(_ textField: UITextField) -> Bool { return true } public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { return true } } 上面方法中textFieldDidChange是通过在LoginViewOperator中的UITextField添加的target-action的，这个会在接下来讲到。此时在LoginViewOperator新建一个变量delegate: lazy var delegate:EDLoginTextFieldDelegate = EDLoginTextFieldDelegate().then{ //text did change $0.textdidChange = {[unowned self] in //在这里处理当textfield在发生变化时，视图需要做出的改变，也就是上面gif中通过判断输入框中是否有值来改变button的alpha和enable的操作 } //text did end //text did begin } 同时将delegate赋值给UITextField的delegate，修改上面outlet出来的fields变量： @IBOutlet var fields: [UITextField]!{ didSet{ fields.forEach{ $0.delegate = delegate //给每一个field都添加一个target-action，这个action不要写在`LoginViewOperator`中，因为这个实际上和delegate是类似的，不是一个视图操作，所以我这里绕了一圈在delegate的textdidChange进行了回调。 $0.addTarget(delegate, action: #selector(delegate.textFieldDidChange(_:)), for: .editingChanged) } if let username = User.mine.name{ fields.first?.text = username } } } 上面就是我在分离一个UITextFieldDelegate所做的操作。在这里看来额外添加的这个delegate可能多此一举，因为操作相对比较少，但是如果是在tableView中的话，你需要在numberOfSections,numberOfRowsInSection,cellForRowAt以及willDisplayCell中需要写一大堆的逻辑，在这里就会体现出协议代理的分离带来的好处。 在这里建议：如果在使用数据回调的时候可以使用delegate而不是block，这样就可以把放在controller中的block代码分离到CustomDelegate中来，后面在分离数据处理部分会用到delgate。 第三步来分离Controller中的网络请求这一步我用objc的代码来进行讲解，因为在样例工程是没有涉及到网络请求的，所以我将我们公司项目的中的网络请求部分的分离代码贴出来。同样我们需要创建一个类DailyProhRequst来继承于NSObject，该类分离控制器的网络请求。 @interface DailyProhRequst : NSObject @end 并为DaulyProhRequst添加三个方法: 下拉加载 + (NSInteger)headerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators; 上拉刷新的网络操作 + (NSInteger)footerRefresh:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators; 简单的数据加载 + (NSInteger)reloadData:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators;如果需要上拉加载下拉刷新数据请求之类的，可以直接调用上面上个方法中的一个，在上面方法中还提到了dataOperator，它是用来整理数据的，这部分放到后面来讲。这三个方法只进行网络并把数据传给dataOperator，request对controller是没有回调的！在上面的分离视图部分，我们将登录按钮的@IBAction放在了LoginViewOperator中，我们需要将这个按钮事件回调给控制器。其实严谨来讲，我们是没有必要将按钮的IBAction放在视图中来的，这里是我的失误。所以在控制器中点击按钮进行一个网络请求的操作就是[DailyProhRequst headerRefresh:@{} currentPage:weakSelf.currentPage dataOperator:weakSelf.dataOperator]，网络请求的分离相对来说比较简单。 第四步创建数据操作类来管理数据同上面一样适用objc的代码进行讲解。这里数据可以分为网络请求返回的数据和抽取本地db的数据，我主要讲一下通过网络获取数据进行数据处理的数据管理类。首先我们同样需要创建一个类来继承自NSObject，并添加一个方法从Requst中获取原始的网络数据: @interface DailyProhDataOperator : NSObject @end 同时我们给DailyProhDataOperator类添加一个获取数据的方法- (void)fetchData:(id)responseobject requstFailed:(NSError *)error;而且我们的目的是必须要将处理好的数据（可能是你自己定一个数据模型）返回给Controller来更新View（由ViewOperator来更新操作）,所以需要创建一个delegate： @protocol DailyProhDataOperatorHandler @end 并给协议添加两个回调方法- (void)dataOperatorSuccess:(DailyProhDataModel *)dataSource;- (void)dataOperatorFailed:(NSError *)error;然后给DailyProhDataOperator类添加一个代理属性@property (weak ) id&lt;DailyProhDataOperatorHandler&gt; handler;并在网络请求分离中的方法中进行修改: +(NSInteger)reloadData:(NSDictionary *)para currentPage:(NSInteger)page dataOperator:(DailyProhDataOperator *)operators{ //在网络请求或者失败的回调中添加数据处理类的入口 //[operators fetchData:responseObject requstFailed:nil]; return 0; } 在DataOperator中进行数据处理完成的回调[self.handler dataOperatorSuccess:data];这个delegate可以通过上面已经讲过的协议代理分离放在CustomDelegate的类中，由CustomDelegate和ViewOperator进行通信来达到根据数据来修改视图的效果。 结果虽然在样例工程中没有网络请求的部分，但是实际上网络请求在控制器中所占的代码就仅仅一个跳转相关的逻辑的代码而已，所以经过上诉的方式对controller进行瘦身之后，一个完整的功能的登录界面代码量为： 图中的request是我模拟的一个假的网络请求。 总结通过上诉的方式可以很大程度上将控制器代码进行缩减，而且指责划分也很明确。最后来说一下他们之间的关系： Controller &lt;-&gt; ViewOperator通过ViewOperator修改视图，Controller相关交互之后通过ViewOperator来进行界面更行 Controller &lt;-&gt; Delegate由delegate来分担Controller中的相关代理协议的工作，包括从delegate拿取数据等等， Controller &lt;-&gt; Requst由Controller来发起Requst Requst &lt;-&gt; DataOperatorDataOperator从Request获取数据，并对数据进行整理 Delegate &lt;-&gt; DataOperatorDataOperator把整理好的数据返回给Delegate Delegate &lt;-&gt; ViewOperatorDelegate把数据传给ViewOperator之后，由ViewOperator更新视图 这个只是罗列出了在当前业务逻辑下面他们之间的相互关系，只是为了梳理一下思路，在不同的逻辑下有不同的组合，但是一个业务场景在代码实现层面可以大体分成五种或者更多的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BLUEPILL在项目中的实践]]></title>
      <url>%2F2017%2F03%2F02%2Fbluepill%2F</url>
      <content type="text"><![CDATA[Bluepill借助于CoreSimulator解决稳定性和可扩展性问题。使用CoreSimulator实现了将Bluepill从Xcode模拟器中隔离出来，并使Bluepill可并行使用多种模拟器运行测试。这里Xcode模拟器是一种随每次Xcode的更新而不断进化的黑盒。（来自InfoQ介绍bluepill时的一段话） 在bluepill的Release可以下载到的压缩包解压，然后在终端中敲入命令: ./bluepill -a ./Sample.app -s ./SampleAppTestScheme.xcscheme -o ./output/ 很简单，对于这最基本的命令，我们只需要有.app和.xcscheme这两个文件，然后将上面下载下来的压缩包解压之后的两个文件放在恰当的位置，应该就可以了。如果真的是这样，这篇文章也就没有存在的价值了，在这篇文章中将要做下面这几件事： Xcode工程项目结构体系； 如何获取上面提到的两个文件并使用上面这个最简单命令跑起来（是否包含了Test，如果没有需要添加Test）； Xcode中Test的基本操作； 相关参数说明； 当前环境:macOS Sierra 版本 10.12.3Xcode Version 8.2.1在我使用bluepill时，它只能在iOS 10.2环境下运行，查看Xcode支持的模拟器版本:xcrun simctl list runtimes 实践前需要知道的概念下面介绍的这几个概念在Apple Developer都可以找到，我仅仅把我认为比较有用的信息罗列出来一下。更多关于设置和使用方面我在文末列出来了，可以自己查看！ Xcode Project project包含了需要构建一个应用程序需要的所有的文件，资源和相关信息，而workspace是能够包含多个project的。 注意一个project是可以包含多个targets的！ 每个project都定义了一个默认的build settings。因为每个project包含了多个targets，所以我们可以为每个targets设置不同的build settings（在文档中特别说明了每个targets的build settings是重写了其所属的project的build settings）。 Xcode WorkspaceWorkspace是可以包含任意个project 的，但是一个project又可以属于多个WorkSpace。对于处于同一个Workspace的不同project，由于workspace中所有project的所有文件都是位于同一个文件目录中，因此并不需要拷贝它们到每一个project文件夹中。对于Workspace的这个共同目录，我们是可以自己指定一个构建目录（build directory）的，但是如果指定了构建目录在build project时，这个project所在的所有workspace的构建目录都将覆盖这个指定的构建目录！ targettarget指定了要构建的目标，在bluepill中会包含samepleApp、samepleApp_Test等targets。同时我们可以修改target的build setting和build phases，target会继承project的build setting，但是我们为target指定不同的build settings来覆盖project的build setting。 schemescheme是需要被build的target的集合。可以在Xcode中选择不同的scheme来指定当前需要build的target(在Xcode中同时只能选择一个scheme)。 实践开荒阶段在开荒阶段是没有使用WorkSpace的，一切的基础都是在Project上。 1.创建一个不包含Test和UITest的空项目 创建一个文件夹用来保存工程项目和下载的blupill解压出来的两个文件：bluepill和bp； 学过C语言的都知道，在使用cc xxx.c文件之后会生成一个.o文件，当然也可以使用cc xxx.c -o selfpill来重命名这个-o文件，使用selfpill文件的命令是：./selfpill（因为c的main的参数就是接收的终端命令），所以我猜测这其实c的一个-o文件，为了使用这两个文件，就需要将上述提到的bluepill和bp和工程项目放在同一个文件夹下。 这一步中我们创建不包含Test和UITest的空项目即不要勾选那两个和test相关的Checkbox，你肯定会疑问为什么要这么做，当我在看BLUEPILL的README的时候特别指出如果是使用终端进行build(使用xcodebuild，后面我会把这一步放在脚本中)的话需要使用build-for-testing，我猜测应该和test是有关的。所以我先测试一下没有test的情况是否会出错，如果出错，错误是什么？ 2.编译这个空项目 项目创建好之后编译一下之后第一目的就是在终端中输入上文提到的命令，但是这里有两个疑问：-a的参数.app的路径是什么？-s的.xcscheme的路径是什么？.app就是前面我们通过编译一次获得的一个文件夹，这个文件夹的地址是/Users/xxxx/Library/Developer/Xcode/DerivedData/在 DerivedData文件夹下找到刚刚创建的项目并点击进去，.app文件夹就在Build/Products/Debug-iphonesimulator/，如果你在创建好之后没有编译Products就是一个空文件夹；而.xcscheme在工程项目所在文件夹/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme路径中提到的xxx是你在创建项目时的用户名。好了，现在我们可以在终端中数据命令: ./bluepill -a /Users/xxx/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/xxx/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/xxx.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -o output敲回车之后我这里出现如下报错： ERROR: There is no 'Plugins' folder inside your app bundle at: /Users/Wil/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app Perhaps you forgot to 'build-for-testing'? (Cmd + Shift + U) in Xcode. Also, if you are using XCUITest, check https://github.com/linkedin/bluepill/issues/16 出现这个问题的原因是在.app文件夹下面没有Plugins文件夹。就算是按照提示说使用Cmd + Shift + U或者使用xcodebuild build-for-testing仍然是行不通的。走到这里我们有两条路，可以删除当前工程重新建一个包含了Test和UITest的项目，也可以在现有的Project中添加Test和UITest的Targets。我选择第二条，因为在我实际项目在这之前也是没有包含相关Test的。 3.在包含Test的Project中实践 现在我们需要在既有Project中添加一个Targets，File/New/Target.../iOS Unit Testing Bundle创建并在Scheme Menu中选择New Scheme选中刚刚我们添加的Targets。编译一下（这里可以使用Cmd + Shift + U或者选择Test的scheme并build，也可以使用build-for-testing命令: xcodebuild build-for-testing -project bluepill_sameple/bluepill_sameple.xcodeproj/ -scheme bluepill_sameple -sdk iphonesimulator10.2 -derivedDataPath build/进入.app文件夹下查看是否已经有了PlugIns文件夹，如果存在该文件夹则继续执行上一次出错的那个命令，运行成功，到这里已经能够使用最基础的命令。 前面提到可以选择Test的scheme并build，可能会出现一点问题:The scheme &#39;bluepill_samepleTests&#39; is not configured for Running。因为添加了这个Test的Target之后需要编辑一下对应的Scheme使它能够进行Running操作！具体的操作如下所示： 设置之后Cmd + B成功运行！ 完善阶段基本参数解释和使用 -a/-s/-o:这是三个最基本的参数，在前面使用的时候应该知道如何使用，这里不再进行解释！ -c:读取一个自定义的config.json文件作为bluepill的运行参数，例如:./bluepill -c config.json -l :获取在当前project中存在的testcase，它的打印结果是存在于.../bluepill_sameple.app/PlugIns文件夹下面！现在我为了演示多建立了一个Test Target(添加Scheme)然后编译：./bluepill -a /Users/用户名/Library/Developer/Xcode/DerivedData/bluepill_sameple-hdwawthuaefpnyecnudlxrpzozyq/Build/Products/Debug-iphonesimulator/bluepill_sameple.app -s /Users/用户名/Desktop/bluepill_new_build/bluepill_sameple/bluepill_sameple.xcodeproj/xcuserdata/Wil.xcuserdatad/xcschemes/bluepill_sameple.xcscheme -l打印结果: bluepill_samepleTests.xctest bluepill_samepleTests_target.xctest文件夹: -x/-i:-x在运行bluepill的时候不包含某一个testcase，-i和-x相反，它则是要包含某一个testcase，-x的优先级是大于-i的。 ./bluepill -a xxxx.app -s xxxx.xcscheme -x bluepill_samepleTests.xctest -r 'iOS 10.2'; ./bluepill -a xxxx.app -s xxxx.xcscheme -i bluepill_samepleTests.xctest -r 'iOS 10.2'; 其中关于-x和-i的参数可使用-l命令来获取！ -d/-n:使用命令：xcrun simctl list devices来获取当前可用的模拟器设备，在得到这些设备之后可以使用-d来指定需要启动的设备！其中-n可以指定同时运行的模拟器数量。比如： ./bluepill -a xxxx.app -s xxxx.xcscheme -r 'iOS 10.2' -d 'iPhone 5s'; 其中命令前面是一样的，这里先省略！对于真机：在bluepill的Issue页面指出blupill不支持真机！ 目前对于bluepill的实践先到这里，后续还会继续更新遇到的相关问题！ 相关链接: Configuring Your Xcode Project Xcode Build Settings Reference]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP持久连接]]></title>
      <url>%2F2017%2F02%2F27%2Fhttp_keep_alive%2F</url>
      <content type="text"><![CDATA[HTTP/1.1允许http设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的http请求重用现存的连接。在事务处理结束之后仍然保持打开状态的TCP连接被称为持久连接。持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭。已经打开的连接可以避免慢启动的拥堵适应阶段。以便更快的进行数据传输。 持久以及并行连接并行连接的缺点: 每个事务打开／关闭一个新的连接，会耗费时间和宽带的； 由于TCP慢启动，每条新连接的性能都会有降低； 可打开的并行连接数量实际上是有限的。 持久连接降低了时延和建立连接的开销，但是持久连接时可能会累积出大量的空闲连接。所以需要配合使用持久连接和并行连接。 HTTP/1.0+ keep-alive连接客户端实现了HTTP/1.0 keep-alive连接的客户端可以通过包含Connection: Keep-Alive首部请求将一条连接保持在打开状态。 服务端如果服务器愿意为下一条请求将连接保持在打开状态，就在通用首部中包含相同的内容。如果没有包含Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。 ⚠️注意keep-alive首部只是请求将连接保持在活跃状态。在发出keep-alive请求之后，客户端和服务器可以在任意时刻关闭空闲的keep-alive连接，并可以限制keep-alive连接所处理事务的数量。 通用首部Keep-Alive选项 参数timeout是在Keep-Alive响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。 参数max是在Keep-Alive响应首部发送的。它估计了服务器还希望为多少个事务抱持此连接的活跃状态。 Keep-Alive首部还可支持任意未经处理的属性。语法为：name [=value] Keep-Alive首部只有在提供了Connection:Keep-Alive时才能使用。例如：12Connection:Keep-AliveKeep-Alive:max=5, timeout=120 Keep-Alive连接的限制和规则 在HTTP1.0中，keep-alive并不是默认使用的。客户端必须发送一个Connection:Keep-Alive请求首部来激活keep-alive连接； 代理或网关必须将报文转发或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身。 不应该与无法确定是否支持Connection首部代理服务器建立keep-alive连接，以防止出现哑代理。 HTTP/1.1 持久连接(Persistent Connection)HTTP/1.1 持久连接在默认情况下是激活的，要在事务处理结束之后将连接关闭，HTTP/1.1应用程序必须向报文中显示的添加一个Connection:close首部。不然HTTP/1.1 连接就仍然维持在打开状态。 ⚠️不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。 持久连接的限制和规则 发送了Connection:close请求首部之后，客户端就无法在那条连接上发送更多的请求了。 如果客户端不想再连接上发送其他请求，就应该在最后一条请求中发送一个Connection:close请求首部。 只有当连接上所有报文的实体主体部分的长度和首部字段Content Length一样（或者用分块传输编码方式），这样连接才能持久保持 HTTP1.1的代理服务器不应该与HTTP1.0客户端建立持久连接。 HTTP1.1设备可以在任意时刻关闭连接，尽管是出于传输报文的过程中关闭连接。 管道化连接HTTP1.1允许在持久连接上可选的使用请求管道。这是在keep-alive连接上的进一步性能优化。在响应到达前，可以将多条请求放入队列中，这样做可以降低网络的环回时间，提高性能。 管道化连接的几个限制 如果http客户端无法确认连接是持久的，就不应该使用管道； 必须按照与请求相同的顺序回送http响应。 http客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。 http客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。 关闭连接在连接管理中需要知道什么时候关闭连接以及如何去关闭连接。 “任意”接触连接所有的HTTP客户端、服务器或者代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接。 但是，服务器永远都无法确定在它关闭“空闲”连接那时候，在客户端有没有数据要发送。如果出现这种情况，客户端就会在写入半截请求报文时发现出现连接错误的请求。 Content-Length及截尾操作每条HTTP响应都应该有精确的Content-Length首部，用以描述响应主题的尺寸。客户端或者代理受到一条随连接关闭而结束的http响应，且实际传输的实体长度与Content-Length并不匹配，接收端就应该质疑长度的正确性。如果接收端是缓存代理，接收端就不应该缓存这条响应。代理应该将有问题的报文原封不动地转发出去，而不应该试图去“校正”Content-Length。 连接关闭容限，重试以及幂等性如果客户端执行事务的过程中，传输连接关闭了，那么除非事务处理会带来一些副作用，否则客户端就应该重新打开连接，并重试。 幂等如果一个事务，不管是执行一次还是多次，得到的结果都是相同的，那么这个事务就是幂等的。 GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法都是的。 客户端不应该用管道化的方式传送非幂等请求(就是说比如POST请求不应该使用管道化方式)。 正常关闭连接TCP连接都是双向的。tcp连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。 完全关闭和半关闭应用程序可以关闭tcp输入和输出信道中的任意一个，或者将两者都关闭了。 套接字调用close()会将tcp连接的输入和输出信道都关闭，这就是完全关闭。用shutdown()单独关闭输入或者输出信道，被称为半关闭。 TCP关闭及重置错误总之，关闭连接的输出信道总是很安全的。连接另一端的对等实体会在其缓冲区中读出所有数据之后收到一条通知，说明流结束了。关闭连接的输入信道比较危险，除非你知道另一端不打算再发送其他数据。如果另一端向你已关闭的输入信道发送数据，操作系统会向另一端的机器回送一条TCP“连接被对端重置”。 大部分操作系统都会将这种情况作为严重错误来处理，删除对端还未读去的所有缓存数据。但是这样做对于管道化来说简直就是噩梦，因为:比如你已经在一条持久连接上发送了10条管道式请求，响应已经收到了，正在操作系统的缓存区中存着。但是你发送了第11条请求，但是服务器认为你使用这条连接的时间太长，决定将其关闭，这个重置信息会清空你的缓冲区。 正常关闭实现正常关闭的应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都告诉对方它们不会再发送任何数据之后，连接就会被完全关闭，而不会有重置风险。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之数组和指针]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case4%2F</url>
      <content type="text"><![CDATA[记录指针和数组直接的关系!当前C语言环境: Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 一维数组数组名数组名的值是一个指针常量，也是数组第一个元素的地址。 注意⚠️数组具有确定的数量的元素，而指针只是一个标量值，_只有数组名在表达式中使用时，编译器才会为他参数一个指针常量(意思就是你不能修改这个指针的值)_。 指针常量所指向的是内存中数组的起始位置，如果修改这个指针常量，唯一可行的操作就是把整个数组移动到内存的其他位置，但是在程序完成链接之后，内存中数组的位置是固定的，所以当程序运行时，在想移动数组就晚了。 数组名不作为指针常量来表示的两种场景 注意：这里说的是不作为指针常量。 1.数组名作为sizeof操作符：sizeof返回整个数组所占用的字节，而不是每个元素所占用的字节，也不是指向数组的指针的长度。 2.数组名用于单目操作符&amp;时：返回一个指向数组的指针，而不是一个指向指针常量的指针。 int a[10]; int *c; c = &a[0];c = a;//这里赋值的是一个指针的拷贝。 下标引用和指针(间接取值操作)array[3]，*(array + 3)出了优先级之外，下标引用和间接访问完全相同。 int array[10]; int *ap = array + 2; 1.ap:这是一个指针地址，所以该表达式和&amp;array[2]或者array+2相同。 2.*ap:间接访问，与array[2]和*(array + 2)相同。 3.ap[6]:C的下标引用和间接访问表达式是一样的，所以ap[6]和*(ap + 6)相同，与array[8]和*(array + 8)相同。 4.ap + 6:ap为一个指针地址，地址向后偏移6，则ap + 6和&amp;array[8]，array + 8相同。 5.*(ap + 6):上面说过ap+6为一个地址，由此可以得出*(ap+6)为间接求得地址对应的值，它和array[8]和*(array+8)相同，其实它和2&gt;.类似。 —&gt;6.ap[-1]:使用-1的偏移量使得道它前一个元素，也就是array[1]或者*(array + 2 - 1)。 上面说这么多，其实只要抓住：当前表示的地址，元素还是间接获取操作就可以了。 注意⚠️:上面提到的“C的下标引用和间接访问表达式是一样的”。 思考题:2[array]，这个表达式中的array是上文中的array。在这个上下文环境中，2[array]表达的意思是什么： 解答:因为前面我一直在强调，下标引用和间接表达式求值是相同的，所以: 第一步：我们可以把2[array]改写成*(2 + array) 第二步:由于加法运算符的两个操作数是可以交换位置的，所以把上面的表达式改写为:*(array + 2);也就是说2[array]其实和array[2]是相等的。 关于指针间接操作符和下标操作的比较 相对于指针的间接访问和下标操作，在可读性方面下标的方式更好，但是在执行效率上面_下标不会比指针更有效率，但是指针有时候比下标效率更高_。 具体的效率比较为: 1.当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。 2.声明为寄存器变量的指针通常比用于静态内存和堆栈中的指针效率更高。关于如何将变量声明为寄存器变量，我们可以使用register关键字来声明，比如:register int *p1;，register：这个关键字请求编译器尽可能的将变量存在CPU 内部寄存器中而不是通过内存寻址访问以提高效率。register 变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register 变量可能不存放在内存中，所以不能用取址运算符“&amp;”来获取register 变量的地址。 3.像&amp;array[2]或者array+2这种在运行时求值的常量表达式代价很高。 数组的初始化数组的初始化需要一系列的值，例如： int array[5] = {1,2,3,4,5};//如果在初始化的时候，初始化的个数比数组的大小小的话，空余的元素将会被赋值为0。 int array[] = {1,2,3,4,5};//如果在声明中没有给出数组的长度，编译器会把数组的长度设置为刚好能够容易所有初始值的长度。 对于静态数组：存储于静态内存的数组只初始化一次，当程序执行时，静态数组已经初始化完毕。如果数组没有被初始化，数组元素的初始值将会自动设置为0。对于自动变量：由于自动变量位于运行时堆栈，所以自动变量在缺省的情况下是未被初始化的。所以这里需要思考的是：当数组的初始化在一个函数中，程序在每次进入该函数的时候，是否值得每次都对该数组重新进行初始化。如果不需要的的话，我们可以把该数组声明为static。 指定初始化器(c99)只初始化数组中的指定元素，方法是：在初始化列表中使用带方括号的下标指明待初始化的元素。1int array[5] = &#123;[5] = 23&#125;;//把array[5]初始化为23 多维数组如int xy[3][2]数组维数不止一个的称为多维数组。数组xy[3][2]在内存中的存储顺序为: (0,0) (0,1) (1,0) (1,1) (2,0) (2,1)//多维数组中的元素存储顺序按照最右边的下标率先变化的原则，称为__行主序__。关于是把第一个下标(上面定义的数组xy中的3)解释为行还是解释为列，都可以的，只要你在使用这个数组的时候使用同一种就可以。如果你把第一个下标解释为行第二个下标解释为列，那么当你按照存储顺序逐个访问数组元素时，所获得的元素是按行排列的，相反则是按列排列的。 数组名和下标int xy[3][2]，数组名xy是一个指向包涵2个整型元素的数组的指针（指向数组的指针）。下面我们来看看数组的下标和指针之间的关系: 1.xy:在三个包含两个整型元素的数组中，xy为指向第一个子数组。（注意：这是指针，说明了指向） 2.xy + 1:在三个包含两个整型元素的数组中，xy为指向第二个子数组，+1是根据包含2个整型元素的数组长度进行调整的，所以是指向第二个子数组。（注意：同上，这是指针，说明了指向） 3.*(xy + 1):获取指向第二个子数组的指针，通过间接操作符得到这个子数组，或者可以把该表达式写为xy[1]（即表示的是第二个子数组）。 4.*(xy + 1) ＋ 1：在第三点中我们取得了第二个子数组，记得我们在上面讲一维数组的时候，获取数组第n个元素的地址的办法是:array + n或者&amp;array[n]，在和*(xy + 1) ＋ 1进行对比之后不难发现，其表达的意思就是获取第二个子数组中第2个元素（因为数组下标是从0开始）的地址或者可以把该表达式写为xy[1] ＋ 1（注意：同上，这是指针，是一个地址） 5.*(*(xy + 1) + 1)：由间接操作符，获得第4点中的指针指向的具体元素。同上我们可以写为:*(xy[1] + 1)，进一步改写xy[1][1]; 指向数组的指针 int vector[10]; int matrix[3][4]; int \*vp = vector; int (\*mp)[10] = matrix;//下标引用的优先级是高于间接引用的，所以我们需要在间接引用这里手动加上括号才行 所以mp是一个指向整型数组的指针，vp是指向整型变量的指针。 这里需要注意一下：一定不要把指向数组的指针和指针数组浓混了，那个确保算术优先级的括号是很重要的，int (*mp)[10]代表的是指向数组的指针，而int *mp[10]表示的是指针数组。 当数组作为函数的参数的时候，多维数组和一维数组相同，都是用指针作为参数进行传递，这个指针是指向数组第一个元素的指针。 一维数组作为函数参数的函数声明形式实参：int vectors[10];函数声明:void vector(int *vec);或者void vector (int vet[]) 多维数组作为函数参数的函数声明形式实参：int matrixs[3][10];函数声明:void matrix(int (*mat)[10]);或者void matrix(int mat[][10]);void matrix(int mat[][10]);这里的关键在于编译器必须知道第二个及以后各维的长度才能对各下标进行求值，因此在原型中必须声明这个维的长度 关于多维数组初始化 第一种方式:int xy[3][2] = {1,2,3,4,5,6};这种就是在声明变量的时候就在后面跟着一长串的初始数据。 第二种方式: int xy[3][2]; xy[0][0] = 1; xy[0][1] = 2; ... xy[2][0] = 5 xy[2][1] = 6;这和第一种的差别就在于，这一种是对数组元素一个一个的去赋值，这种存储顺序是以最右边下标率先变化的（前面注释提到的行主序）。 第三种方式:因为多维数组可以看成是每个元素由一个子数组组成，所以我们可以按照一个子数组为一个个体来初始化。 int xy[3][2] = { {1,2}, {3,4}, {5,6} }; 这样看起来和第一种的方式是有点类似的。 总结 1 .数组变量是const指针，所以是不能被赋值的； 2.如果指针指向的不是一片连续的空间，那么对地址进行加操作（或者减操作）是没有意义；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之指针]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case3%2F</url>
      <content type="text"><![CDATA[指针。当前C语言环境: Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 粗略的总结一下知识点 1.变量标识符与内存位置之间的关联并不是硬件提供的，而是编译器为我们提供的，硬件仍然通过地址访问内存位置。 2.数组中的元素存储于连续的内存地址中。 3.NULL指针作为一个不指向任何东西的特殊指针。在对指针进行解引用操作之前，必须确保它不是NULL指针(因为对一个NULL指针进行解引用是非法操作)。 4.指针的指针中，操作符具有从右向左的结合性，所以这个表达式相当于`(*c)`，所以可以从里向外求值。对于如下代码中:int a = 10; int *b = &a; int **c = &b; 表达式 相当的表达式 a 10 b &amp;a *b 12,a c &amp;b *c &amp;a,b **c 12,a,*b 注意⚠️在指针没有被初始化之前，一定不要对这个指针变量使用间接操作符。 习题练习纪录 1.字符串查找相关，两个字符串中找出第一个相同的字符串。解答: char *find_char(char const *source,char const *chars){ if (source == NULL || chars == NULL) { return NULL; } char const *f_p = chars; do { do { if (*source == *chars) { char *result = (char *)source; char *cp; *cp = *result; return cp; } } while (*chars++ != '\0'); chars = f_p; } while (*source++ != '\0'); return NULL; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之操作符和表达式]]></title>
      <url>%2F2017%2F02%2F22%2Fc_and_pointer_note_case2%2F</url>
      <content type="text"><![CDATA[这篇主要记录操作符和表达式相关的只是！当前C语言环境:1234Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 移位操作符左移操作符&lt;&lt;,右移操作符&gt;&gt;;而且位移的操作数必须是整数类型。其中右移操作符存在两种情况：算术移位和逻辑移位；这里主要来说一说算术移位。 逻辑移位左边移入的位用0填充 算术移位算术移位也就是说会考虑到符号位，即左边移入的位由原值的符号位决定，如果符号位为1则移入的位为1，符号位为0则移入的位为0；对于移位操作，还必须知道数字在计算机中是以二进制的形式存在的，而且负数的表示形式还稍有不同。 负数在计算机中的二进制表示形式 假设在当前计算机中，int型占8位。比如要知道数字-10在计算机的表现形式，第一步：数字10的二进制值为00001010，第二步用100000000来减去00001010。得到的就是-10在二进制中的表现形式为:11110110。更多关于负数补码的介绍阮一峰的网络日志－－关于2的补码 这里我举例说明一下移位操作: int uint = 10; //00001010 int sint = -10;//11110110 printf("%d\n",uint >> 2);//00000010 printf("%d\n",sint >> 2);//11111101 在当前环境下： Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 打印的结果分别为2和-3,所以从这里看出来编译器对于左移操作是算术移位。 ++和—操作符对于这两个操作符的计算就很简单了，还是来举例说明一下: int a,b,c,d; a = b = 10; c = ++a; d = b++; 但是需要来理解这其中的原理: ++和—操作符原理抽象的说，前缀和后缀形式的增值操作符都复制一份变量值的拷贝，这些操作符的结果不是被他们所修改的变量，而是变量值的拷贝。 逗号操作符逗号操作符将多个表达式分隔开，这些表达式从左向右逐个进行求值，__整个逗号表达式的值就是最后那个表达式的值。 int (^f1)(int) = ^(int value){ return value + 1; }; int (^f2)(int) = ^(int value){ return value + 2; }; int (^f3)(int,int) = ^(int a,int b){ return a + b; }; int x,a,b,c; x = 0; //从这里开始 a = f1(x); b = f2(x + a); for (c = f3(a,b); c < 10; c = f3(a,b)) { printf("while statements c is:%d\n",c); a = f1(++x); b = f2(x + a); } //到这里结束，这其中的代码将会被修改 上面为原始的代码片段，现在我们需要使用逗号操作符来简化上面的代码，同时我选择用while循环来代替for循环。 while (a = f1(x),b = f2(x + a),c = f3(a,b),++x,c < 10) { printf("while statements c is:%d\n",c); } 现在，循环中用于获得下一个值的语句只需要出现一次，逗号操作符使源码更易于维护。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《C和指针Note》之基础]]></title>
      <url>%2F2017%2F02%2F20%2Fc_and_pointer_note_base%2F</url>
      <content type="text"><![CDATA[C存在两种不同的环境：翻译环境和执行环境;翻译环境是将源代码转换为可执行的机器指令，而执行环境用于实际执行代码。 翻译其中翻译阶段主要包括了编译和链接两部分。 __ 编译将源代码转换为目标代码的过程，在这个过程中包含了预处理（预处理相关操作，比如define替换为实际值）和解析（判断源代码的意思），在最后生成目标代码（机器指令的初步形式）。 链接链接器会把各个目标文件捆绑起来形成一个可执行程序。在这个过程中会引入c函数库。 执行程序载入到内存中，并初始化在堆栈中没有初始化的变量。 __ 运行时堆栈用户保存函数的局部变量和返回值。 静态内存存储在静态内存中的变量将会在程序执行期间一直保留！ 程序的终止可以是main函数完成返回，也可以是主动执行了exit。 一个技巧如果在使用注释的时候/**/嵌套了多层会导致注释失效，这时候我们可以在最外层添加:123#if 0//中间为代码#endif 而且在使用注释的时候并不会把注释掉的部分从源代码中删除，只是不去执行而已，使用if endif的话是在逻辑上删除了这一段代码的。这在后面的预处理器那一节会讲更多。]]></content>
    </entry>

    
  
  
</search>
