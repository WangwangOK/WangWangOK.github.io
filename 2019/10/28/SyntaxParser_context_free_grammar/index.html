<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 语法分析——文法的基础概念 · 凌云壮志幾多愁</title><meta name="description" content="语法分析——文法的基础概念 - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://legacy.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">语法分析——文法的基础概念</h1><div class="post-info">Oct 28, 2019</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在语法分析一章中会出现很多的专业术语，我会在这一节将语法分析涉及到的术语都大致捋一遍。这些专业术语是学习语法分析的必备技能，务必记住并理解，下面我们进入正题。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>语法分析通常用于编译器中。在我们的编译器模型中，语法分析器从词法分析器获得一个词法单元组成的串，并验证这个串可以由源语言的文法（比如上下文无关文法，在后面会详细解释）生成。</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/1.png" alt=""></p>
<p>处理文法的语法分析器大体上可以分分为三种类型：通用的、自顶向下的和自底向上的。而编译器中常用的的方法分为自顶向下和自底向上。顾名思义：</p>
<p>1）、自顶向下的方法从语法分析树的根节点开始向底部构造语法分析树；</p>
<p>2）、自底向上则从叶子结点开始，逐渐向根节点方向构造。</p>
<p>这两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号。</p>
<p>最高效的自顶向下方法和自底向上方法只能处理某些文法子类，但其中的子类，特别是 <strong>LL、LR</strong> 它们的表达能力已经足以描述现代程序设计语言大部分的语法构造了。</p>
<blockquote>
<p>手工实现的语法分析通常使用LL文法。处理较大的LR文法类的语法分析器通常是使用自动化工具构造得到。</p>
</blockquote>
<p>这里的第一个L表示从左向右扫描，第二个的L和R分别表示最左推导和最右推导。有关于推导的概念下面就会展开来说，在前面我们提到了文法，所以现在还是先看看上下文无关文法。</p>
<h2 id="一、上下文无关文法（Context-Free-Grammar）"><a href="#一、上下文无关文法（Context-Free-Grammar）" class="headerlink" title="一、上下文无关文法（Context-Free-Grammar）"></a>一、上下文无关文法（Context-Free-Grammar）</h2><p>文法自然地描述了大多数程序设计语言构造的层次化语法结构，比如if-else之类的。一个上下文无关文法由四个元素组成：</p>
<ul>
<li><strong>终结符号</strong>：也称为词法单元。词法单元由两个部分组成：名字和属性值。我们常常把这些词法单元名字称为终结符号。因此我们在语法分析中，通常将词法单元和终结符当做一个意思；</li>
<li><strong>非终结符号</strong>：也称为语法变量，每个非终结符号表示一个终结符号串的集合；</li>
<li><strong>产生式</strong>：包括产生式头、一个箭头，和一个产生式体；</li>
<li><strong>开始符号</strong>：指定一个非终结符号为开始符号；</li>
</ul>
<p>如下图的上下文无关文法：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/2.png" alt="上下文无关文法"></p>
<p>对此，我们需要一些约定来表示不同的符号，以便后续行文方便：</p>
<p><strong>终结符号</strong>：</p>
<p>Ⅰ）、小写字母，a、b、c等等；</p>
<p>Ⅱ）、运算符号，比如 + 。 - ， * ，/ 之类的；</p>
<p>Ⅲ）、标点符号，比如括号、逗号等等；</p>
<p>Ⅳ）、数字；</p>
<p>Ⅴ）、黑体字符串，比如 <strong>id</strong>，<strong>if</strong>。每个这样的字符串表示一个终结符号；</p>
<p><strong>非终结符</strong>：</p>
<p>Ⅰ）、大写字母，A、B、C等等；</p>
<p>Ⅱ）、小写，斜体的字符串。比如 <em>expr</em> ， <em>stamt</em> 等等；</p>
<p><strong>产生式体</strong>：</p>
<p>使用小写的希腊字母，比如α、β、γ表示文法符号串。比如 A -&gt; α，其中A为产生式头部，α为产生式体。</p>
<p><strong>可选体</strong>：</p>
<p>具有相同头部的产生式 A -&gt; α<sub>1</sub>，A -&gt; α<sub>2</sub>，… ,A -&gt; α<sub>k</sub>，可以简写为 A -&gt; α<sub>1</sub> | α<sub>2</sub> | … | α<sub>k</sub>。在这里我们把α<sub>1</sub>，α<sub>2</sub>，α<sub>k</sub>称作A的可选体。这个可选体概念不太重要，只需要记住相同产生式头部的简写形式即可。</p>
<p>因此，运用前面的约定，我们可以看出这里一共有三个产生式；其中E、T、F为非终结符；+、*、(、)、id为终结符；其中非终结符E为开始符号。</p>
<hr>
<h3 id="1、推导——最左推导、最右推导"><a href="#1、推导——最左推导、最右推导" class="headerlink" title="1、推导——最左推导、最右推导"></a>1、推导——最左推导、最右推导</h3><p>从开始符号出发，每个重写步骤把一个非终结符替换为它的某个产生式的体。比如下面关于非终结符E的文法：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/3.png" alt=""></p>
<p>产生式 <code>E --&gt; -E</code> 表明，讲一个E替换为 -E 的过程写作： </p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/4.png" alt=""> </p>
<p>读作 “E推导出-E” 。同样的我们可以按照任意顺序对单个E不断地应用各个产生式，得到一个替换序列，比如：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/5.png" alt=""></p>
<p><strong>句型</strong>：是指推导过程中出现的各种表达式，其中可以包含终结符号，也可以包含非终结符号，当然也有可能是空串；</p>
<p><strong>句子</strong>：是不包含非终结符的句型；</p>
<p>一个终结符号串存在于文法G的的语言L(G)中，当且仅当该符号串是文法G的一个句子。可以由文法生成的语言，称为上下文无关语言。</p>
<blockquote>
<p>如果两个文法生成相同语言，那么这两个文法是等价的。</p>
</blockquote>
<p>比如串 <code>-(id+id)</code> 是文法 </p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/3.png" alt=""> </p>
<p>的一个句子，这是因为存在推导过程：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/6.png" alt=""></p>
<p>串E、-E、… 、-(id+id) 都是这个文法的句型。在上诉的推导过程中，每一个推导步骤上都需要做两个选择，我们要选择替换掉哪个非终结符号。下面是另外一种推导：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/7.png" alt=""></p>
<p>这一个推导和上一个推导稍有不同，我们推导的第四步，选择替换掉的是右边的非终结符。基于此我们的推导有两种推导形式：</p>
<p><strong>最左推导</strong>：总是选择每个句型最左边的非终结符号进行替换。如果α =&gt; β 是一个推导步骤，且被替换的是α中的最左非终结符号。我们用 <code>α =&gt;lm β</code>  （这里lm应该是在推导符号=&gt;的下方，由于不太好书写，因此这里用放在符号右边的形式）；</p>
<p><strong>最右推导</strong>：总是选择每个句型最右边的非终结符号进行替换。此时我们写作 <code>α =&gt;rm β</code>（同上）；</p>
<p>使用最左推导得到的句型称为最左句型。最右推导也被称为 <strong>规范推导</strong>。</p>
<h3 id="2、语法分析树和推导"><a href="#2、语法分析树和推导" class="headerlink" title="2、语法分析树和推导"></a>2、语法分析树和推导</h3><p>语法分析树是推导的图形表示，它过滤掉了推导过程中对非终结符号应用产生式的顺序。语法分析树的每个内部结点表示一个产生式的应用。该内部结点的标号是产生式头中的非终结符号。</p>
<p>这里可以再对语法分析树和词法分析树进行一次对比。上一章词法分析中使用正则表达式构造DFA时提及抽象语法树中每个内部结点为正则表达式中的一个运算符，该内部结点子树的左右子节点分别表示该运算符的运算分量。</p>
<p>比如 <code>-(id+id)</code> 的语法分析树为：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/8.png" alt=""></p>
<p>该语法分析树对应的推导过程是上面提到的两个推导：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/6.png" alt=""></p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/7.png" alt=""></p>
<p>一颗语法分析树的叶子结点既可以是非终结符号，也可以是终结符号。从左到右排列这些符号就可以得到一个句型，它成为这颗树的 <strong>结果</strong>。在这里我们从左到右读取每一个叶子结点并排列起来，得到的结果是：<code>- ( id + id )</code> 。</p>
<p><strong>二义性文法</strong> ，如果一个文法可以为某个句子生成多颗语法分析树，那么它就是二义性的。换句话说，二义性文法就是对同一个句子有多个最左推导或者最右推导的文法。</p>
<p>到这儿，我们可以先看一个例子。</p>
<h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p>对于文法 <script type="math/tex">S \rightarrow\ a\ S\ b\ S\ |\ b\ S\ a\ S\ |\ ε</script>，有一串<code>aabbab</code>。尝试写出最左推导和最右推导出该的语法分析树。</p>
<p>最左推导语法分析树：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/10.png" alt=""></p>
<p>最右推导语法分析树：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/11.png" alt=""></p>
<p>从语法分析的结构，我们不难看出来该文法是二义性文法。</p>
<h3 id="3、上下文无关文法和正则表达式"><a href="#3、上下文无关文法和正则表达式" class="headerlink" title="3、上下文无关文法和正则表达式"></a>3、上下文无关文法和正则表达式</h3><p>文法是比正则表达式表达能力更强的表示方法。即每个可以使用正则表达式描述的构造都可以使用文法来描述，但反之则不成立。我们可以根据正则表达式构造出对应的文法，下面则是从正则表达式构造对应文法的大致步骤。如下：</p>
<p>1）、对于NFA的每个状态i，创建一个非终结符A<sub>i</sub>；</p>
<p>2）、如果状态i有一个在输入a上到达状态j的转换，则加入产生式 <script type="math/tex">A_{i} \rightarrow a A_{j}</script> 如果状态i在输入 ε 上到达状态j，则加入产生式 <script type="math/tex">A_{i} \rightarrow A_{j}</script>；</p>
<p>3）、如果i是一个接受状态，则加入产生式 <script type="math/tex">A_{i} \rightarrow ε</script>；</p>
<p>4）、如果i是自动机的开始状态，令 A<sub>i</sub>为所得文法的开始符号；</p>
<p>比如正则表达式 <strong>$(a|b)^{*}abb$</strong> ，它对应的DFA为：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/9.png" alt=""></p>
<p>从上面步骤我们可以得到一共有4个状态，因此对于对应文法则有4个非终结符，分别为 <script type="math/tex">A_{0},A_{1},A_{2},A_{3}</script> 。根据上图的转换我们得到文法为：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/12.png" alt=""></p>
<hr>
<h2 id="二、设计文法"><a href="#二、设计文法" class="headerlink" title="二、设计文法"></a>二、设计文法</h2><p>如果前面看到的，任何能够使用正则表达式描述的东西都可以使用文法来描述。因此在这儿来列举4点关于正则表达式和文法的异同：</p>
<p>1）、将一个语言的语法结构分为词法和非词法两部分可以很方便地将编译器前端模块化，将前端分解为大小合适的组件；</p>
<p>2）、一个语言的词法规则通常很简单，我们不需要使用像文法这样功能强大的表示方法来描述这些规则；</p>
<p>3）、和文法相比，正则表达式通常更加简洁，并且更容易理解；</p>
<p>4）、根据正则表达式自动构造得到的词法分析器效率要高于文法得到的分析器；</p>
<p>根据上诉4点来说明，既然正则表达式都可以使用文法来描述，而在词法分析中我们依然选择了正则表达式来描述词法单元；</p>
<blockquote>
<p><strong>正则表达式更适合描述标识符、常量、关键字、空白这样的语言构造的结构；文法更适合描述嵌套结构，比如if-else之类的</strong>；</p>
</blockquote>
<h3 id="1、左递归"><a href="#1、左递归" class="headerlink" title="1、左递归"></a>1、左递归</h3><p>左递归是指 <strong>产生式体的最左边符号和产生式头部的非终结符号相同</strong> 。对于产生式 </p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/16.png" alt="上下文无关文法"></p>
<p>产生式的头部是E，同时E也是产生式体的最左边的非终结符号，因此该推导将会被将被递归调用。</p>
<p>同样的，右递归也就是指的产生式头部的非终结符号和产生式体最右边的终结符相同的情况。</p>
<p>该文法无法用于自顶向下的语法分析中，这是因为自顶向下的语法分析是基于LL文法的。而对于LL文法来说，第一个L指的是从左到右扫描语法分析树的一层的每个结点，遇到非终结符则应用对应非终结符的产生式。第二个L指的是最左推导。前面我们已经知道了最左推导，即每一次替换掉产生式最左边的非终结符，因此这也就和左递归的定义吻合了。关于更详细的自顶向下的语法分析将在后面进行详细讲解。</p>
<p>既然存在左递归，那么消除左递归肯定是有必要的。</p>
<h4 id="消除立即左递归："><a href="#消除立即左递归：" class="headerlink" title="消除立即左递归："></a><strong>消除立即左递归</strong>：</h4><p>比如存在立即左递归的产生式：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/14.png" alt="上下文无关文法"></p>
<p>其中 $\beta _{i}$ 都不以A开头。因此我们可以用下面的技术来消除立即左递归：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/15.png" alt="上下文无关文法"></p>
<p>需要特别注意的是：<strong>第二个产生式到空串的产生式</strong> 。非终结符号A生成的串和替换之前生成的串一样，但不再是左递归的。这个过程消除了所有$A$和$A_{1}$产生式相关联的左递归。</p>
<p>比如我们对文法</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/2.png" alt="上下文无关文法"></p>
<p>应用消除立即左递归的技术上面文法的左递归，得到的结果为：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/13.png" alt="上下文无关文法"></p>
<h4 id="消除一般左递归"><a href="#消除一般左递归" class="headerlink" title="消除一般左递归"></a><strong>消除一般左递归</strong></h4><p>但并不是所有的文法都是立即左递归的，有可能是经过多次推导之后才发现递归的情形。比如下面的文法就不是立即左递归：</p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/17.png" alt="上下文无关文法"></p>
<p>对于推导 </p>
<p><img src="/uploads/SyntaxParser_context_free_grammar/18.png" alt="上下文无关文法"></p>
<p>可以看出非终结符号S是左递归的，但它并不是立即左递归。那么对于这种情况的左递归如何消除呢？</p>
<ul>
<li><p>1）、首先将文法的所有非终结符，从开始符号按出现顺序，依次对它们进行编号为A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, …,A<sub>n</sub>；</p>
</li>
<li><p>2）、从A<sub>1</sub>开始依次读取每一个非终结符到A<sub>n</sub>，我们称作A<sub>i</sub>；</p>
<p>同时又从A<sub>1</sub>开始读取非终结符号到A<sub>i-1</sub>，我们称作A<sub>j</sub> 。如果存在形如<script type="math/tex">A_{i} \rightarrow A_{j}\gamma</script> 那我们就将其替换为产生式组：</p>
<script type="math/tex; mode=display">
A_{i} \rightarrow \sigma _{1} \gamma\ |\ \sigma _{2} \gamma\ |\ ...\ |\ \sigma _{k} \gamma \\
A_{j} \rightarrow \sigma _{1} \ |\ \sigma _{2} \ |\ ...\ |\ \sigma _{k} \\</script><p>这样我们就可以尽最大的可能构造立即左递归了。</p>
</li>
<li><p>3）、如果此时存在立即左递归，则使用上面提到的消除立即左递归的方式来消除；</p>
</li>
</ul>
<p>下面我用C++写了一个简单地消除左递归的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">struct GrammerProduction &#123;</div><div class="line">	string header;</div><div class="line">    vector&lt;string&gt; bodies   ;</div><div class="line">    GrammerProduction() &#123;&#125;</div><div class="line">    //GrammerProduction(const GrammerProduction&amp; lhs) &#123;&#125;</div><div class="line">    //GrammerProduction&amp; operator=(const GrammerProduction&amp; lhs) &#123;&#125;</div><div class="line">    GrammerProduction(string hdr)&#123;</div><div class="line">        header = hdr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool isEmpty() &#123;</div><div class="line">        return bodies.empty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void add_body(string bdy) &#123;</div><div class="line">        bodies.push_back(bdy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private:</div><div class="line">    string recursive_nonterminal; /// 发生立即左递归时，需要引入的非终结符</div><div class="line">    public:</div><div class="line">    void set_recursive_nonterminal(string nt) &#123;</div><div class="line">        recursive_nonterminal = nt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void replace_body(GrammerProduction* prd) &#123;</div><div class="line">        if (prd==nullptr) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        vector&lt;string&gt; new_bodies;</div><div class="line">        for (vector&lt;string&gt;::iterator itr_body = bodies.begin(); itr_body != bodies.end(); itr_body++) &#123; /// 遍历当前所有的产生式</div><div class="line">            if (itr_body-&gt;empty()) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            string char_body(1,(*itr_body)[0]);</div><div class="line">            string prd_header = prd-&gt;header;</div><div class="line">            if (char_body != prd_header) &#123; </div><div class="line">                new_bodies.push_back(*itr_body);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            /// 如果当前产生式最左边是非终结符，并且该非终结符和Aj相等。即Ai -&gt; Aj γ</div><div class="line">            for (vector&lt;string&gt;::iterator pitr_body = prd-&gt;bodies.begin(); pitr_body != prd-&gt;bodies.end(); ++pitr_body) &#123;</div><div class="line">                string tmp_body = *itr_body;</div><div class="line">                tmp_body = tmp_body.replace(0,1,*pitr_body);</div><div class="line">                new_bodies.push_back(tmp_body);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        bodies = new_bodies;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    GrammerProduction* remove_immediately_left_recursive() &#123;</div><div class="line">        vector&lt;string&gt; new_bodies;</div><div class="line">        GrammerProduction* new_production = new GrammerProduction(recursive_nonterminal);</div><div class="line">        if (!new_production) &#123;</div><div class="line">            return nullptr;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (vector&lt;string&gt;::iterator itr_body = bodies.begin(); itr_body != bodies.end(); ++itr_body) &#123; /// 遍历当前所有的产生式</div><div class="line">            string tmp_body = *itr_body;</div><div class="line">            string first_char_body(1,(*itr_body)[0]);</div><div class="line">            if (first_char_body == header) &#123; /// 立即左递归</div><div class="line">                tmp_body = tmp_body.erase(0,1);</div><div class="line">                tmp_body = tmp_body+recursive_nonterminal;</div><div class="line">                new_production-&gt;add_body(tmp_body);</div><div class="line">            &#125;else&#123;</div><div class="line">                tmp_body = tmp_body+recursive_nonterminal;</div><div class="line">                new_bodies.push_back(tmp_body);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (new_production-&gt;isEmpty()) &#123;</div><div class="line">            return nullptr;</div><div class="line">        &#125;</div><div class="line">        new_production-&gt;add_body(&quot;#&quot;);</div><div class="line">        bodies = new_bodies;</div><div class="line">        return new_production;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct Grammer &#123;</div><div class="line">    vector&lt;GrammerProduction*&gt; productions;</div><div class="line">    Grammer() = default;</div><div class="line">    void printProductions()&#123;</div><div class="line">        cout&lt;&lt;&quot;-------------------------------------&quot;&lt;&lt;endl;</div><div class="line">        for (vector&lt;GrammerProduction*&gt;::iterator itr = productions.begin(); itr != productions.end(); ++itr) &#123; /// 外层循环从第一个开始符号开始 姑且叫作Ai</div><div class="line">            GrammerProduction* p = *itr; /// 获取Ai所有的产生式体</div><div class="line">            cout&lt;&lt;p-&gt;header&lt;&lt;endl;</div><div class="line">            for (vector&lt;string&gt;::iterator body_itr = p-&gt;bodies.begin(); body_itr != p-&gt;bodies.end(); ++body_itr) &#123;</div><div class="line">                cout&lt;&lt;&quot;          &quot;&lt;&lt;*body_itr&lt;&lt;endl;</div><div class="line">            &#125;</div><div class="line">            cout&lt;&lt;&quot;-------------------------------------&quot;&lt;&lt;endl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    void add_prodction(GrammerProduction* pro) &#123;</div><div class="line">        if (pro==nullptr) return;</div><div class="line">        this-&gt;productions.push_back(pro);</div><div class="line">    &#125;</div><div class="line">    void remove_left_recursive() &#123;</div><div class="line">        vector&lt;GrammerProduction*&gt; new_productions;</div><div class="line">        for (vector&lt;GrammerProduction*&gt;::iterator itr = productions.begin(); itr != productions.end(); ++itr) &#123; /// 外层循环从第一个开始符号开始 姑且叫作Ai</div><div class="line">            GrammerProduction* p = *itr; /// 获取Ai所有的产生式体</div><div class="line">            for (vector&lt;GrammerProduction*&gt;::iterator itr_j = productions.begin(); itr_j != itr; ++itr_j) &#123; /// 内层循环获取当前非终结符之前的其他非终结符，姑且叫作Aj    </div><div class="line">                GrammerProduction* jp = *itr_j; /// 获取Aj所有的产生式体</div><div class="line">                p-&gt;replace_body(jp);</div><div class="line">            &#125;</div><div class="line">            GrammerProduction *ptr = p-&gt;remove_immediately_left_recursive(); /// 消除可能存在的立即左递归</div><div class="line">            if (ptr==nullptr) continue;</div><div class="line">            new_productions.push_back(ptr);</div><div class="line">        &#125;</div><div class="line">        if (new_productions.size() &lt;= 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        productions.insert(productions.end(),new_productions.begin(),new_productions.end());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如我们有带左递归的产生式集合：</p>
<script type="math/tex; mode=display">
S \rightarrow Aa\ |\ b\\
A \rightarrow Ac\ |\ Sd\ |\ ϵ</script><p>现在我们可以使用上诉的C++代码来帮我们消除左递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    GrammerProduction *s_productions = new GrammerProduction(&quot;S&quot;); /// S -&gt; Aa | b</div><div class="line">    s_productions-&gt;set_recursive_nonterminal(&quot;T&quot;);</div><div class="line">    s_productions-&gt;add_body(&quot;Aa&quot;);</div><div class="line">    s_productions-&gt;add_body(&quot;b&quot;);</div><div class="line"></div><div class="line">    GrammerProduction *a_productions = new GrammerProduction(&quot;A&quot;); /// A -&gt; Ac | Sd | ε</div><div class="line">    a_productions-&gt;set_recursive_nonterminal(&quot;B&quot;);</div><div class="line">    a_productions-&gt;add_body(&quot;Ac&quot;);</div><div class="line">    a_productions-&gt;add_body(&quot;Sd&quot;);</div><div class="line">    a_productions-&gt;add_body(&quot;#&quot;);</div><div class="line"></div><div class="line">    Grammer grammer;</div><div class="line">    grammer.add_prodction(s_productions);</div><div class="line">    grammer.add_prodction(a_productions);</div><div class="line">    cout&lt;&lt;&quot;带有左递归的产生式：&quot;&lt;&lt;endl;</div><div class="line">    grammer.printProductions();</div><div class="line">    grammer.remove_left_recursive();</div><div class="line">    cout&lt;&lt;&quot;消除左递归之后的产生式：&quot;&lt;&lt;endl;</div><div class="line">    grammer.printProductions();</div><div class="line"></div><div class="line">    cout&lt;&lt;&quot;Done&quot;&lt;&lt;endl;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">带有左递归的产生式：</div><div class="line">-------------------------------------</div><div class="line">S</div><div class="line">          Aa</div><div class="line">          b</div><div class="line">-------------------------------------</div><div class="line">A</div><div class="line">          Ac</div><div class="line">          Sd</div><div class="line">          #</div><div class="line">-------------------------------------</div><div class="line">消除左递归之后的产生式：</div><div class="line">-------------------------------------</div><div class="line">S</div><div class="line">          Aa</div><div class="line">          b</div><div class="line">-------------------------------------</div><div class="line">A</div><div class="line">          bdB</div><div class="line">          #B</div><div class="line">-------------------------------------</div><div class="line">B</div><div class="line">          cB</div><div class="line">          adB</div><div class="line">          #</div><div class="line">-------------------------------------</div><div class="line">Done</div></pre></td></tr></table></figure>
<p>解释一下，这里的非终结符号B是A的产生式出现左递归之后，引入的非终结符。</p>
<hr>
<h3 id="2、提取左公因子"><a href="#2、提取左公因子" class="headerlink" title="2、提取左公因子"></a>2、提取左公因子</h3><p>提取左公因子可以适用于预测分析技术或自顶向下分析技术的文法。当我们不清楚应该在两个产生中如何选择的时候，我们可以通过改写产生式来推后这个决定，当我们有足够的信息时再做出正确地决定。</p>
<p>比如有产生式 <script type="math/tex">A \rightarrow \alpha \beta_{1}\ |\ \alpha \beta_{2}</script>，是A的两个产生式，并且产生式体开头都是从 α 推导得到的一个非空串。那么这时候我们就不清楚是产生式 <script type="math/tex">A \rightarrow \alpha \beta_{1}</script> 还是以产生式 <script type="math/tex">A \rightarrow \alpha \beta_{2}</script> 进行展开。</p>
<p>然后我们可以将A展开为 <script type="math/tex">\alpha A^{'}</script>，从而延迟要做出决定的时刻，原来的产生式就变为了：</p>
<script type="math/tex; mode=display">
A \rightarrow \alpha A^{'}\\
A^{'} \rightarrow \beta_{1}\ |\ \beta_{2}</script><p>总结一下上面提到的内容：对于每个非终结符号A，找出他的两个或多个选项之间的最长公共前缀 α。如果 α 不为空，即存在一个非平凡的公共前缀，那么将所有A的产生式</p>
<script type="math/tex; mode=display">A \rightarrow \alpha\beta_{1}\ |\ \alpha\beta_{2}\ |\ ...\ |\ \alpha\beta_{n}\ |\ \gamma</script><p>替换为</p>
<script type="math/tex; mode=display">
A \rightarrow \alpha A^{'}\ |\ \gamma\\
A^{'} \rightarrow \beta_{1}\ |\ \beta_{2}\ |\ ...\ |\ \beta_{n}</script><p>其中 γ 表示所有不以 α 开头的产生式； <script type="math/tex">A^{'}</script> 是一个新的非终结符号。不断地应用这个转换，直到每个非终结符号的任意两个产生式体都没有公共前缀为止。</p>
<hr>
<h3 id="3、非上下文无关语言的构造"><a href="#3、非上下文无关语言的构造" class="headerlink" title="3、非上下文无关语言的构造"></a>3、非上下文无关语言的构造</h3><p>在常见的程序设计语言中，存在少量无法文法描述的语法构造。在C或者Java的文法不区分由不同字符串组成的标识符。所有的标识符在文法中都被表示为像 <strong>id</strong> 这样的词法单元。在这些语言的编译器中，<strong>标识符是否先声明后使用是在语义分析阶段检查的</strong> 。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在本篇文章中，介绍了一大堆的概念。比如上下文无关文法里面的产生式、终结符、非终结符，还有开始符号等等；然后我们接触到了推导的概念，推导又分为最左推导和最右推导。我们根据这两种推导，我们可以构造出对应语法分析树；语法分析树的所有叶子结点从左到右拼起来之后，得到的就是对应产生式文法的句子。而中间过程中出现的则成为句型；</p>
<p>而且，我们也了解到如何通过正则表达式来构造对应的上下文无关文法。大致的过程是根据正则表达式，我们可以根据词法分析一章的知识来构造一个NFA（根据连接、并、闭包运算对应的状态转换图）。我们根据NFA的状态数对应非终结符号，具体转换规则都已经详细列在了上面；</p>
<p>在构造文法的过程中，我们遇到左递归的情况。因此我们需要知道如何去消除立即左递归，和左递归。详细的消除方法在上面用C++语法已列出；最后我们还了解了提取左公因子的方法，当我们不清楚应该如何选择产生式，推迟这个时机，待我们有足够信息做出正确选择之前。</p>
<p>下一篇文章，我们将会去看看自顶向下的语法分析技术。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/11/two_three_four_red_black_tree/" class="prev">上一篇</a><a href="/2019/10/28/compiler_regular2dfa/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/10/28/SyntaxParser_context_free_grammar/';
var disqus_title = '语法分析——文法的基础概念';
var disqus_url = 'http://yoursite.com/2019/10/28/SyntaxParser_context_free_grammar/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2021 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>