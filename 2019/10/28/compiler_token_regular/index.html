<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 词法分析——词法单元和正则表达式 · 凌云壮志幾多愁</title><meta name="description" content="词法分析——词法单元和正则表达式 - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://legacy.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">词法分析——词法单元和正则表达式</h1><div class="post-info">Oct 28, 2019</div><div class="post-content"><p>本系列文章是《编译原理》的读书笔记，并加入了一些个人的理解。本系列的主要内容顺序如下：<br>1）、首先解释什么是词法单元；<br>2）、如何手动识别词法单元；<br>3）、最后是词法分析器如何自动机自动识别词法单元；<br>本文主要是看一下词分析器的词法单元部分。包括一些基本概念，以及词法单元的识别。</p>
<p>首先我们先大体上看一下词法分析器的作用。它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元的序列。每个词法单元对应一个词素。</p>
<p>这里我们有提到几个专业名词：词素、词法单元。它们的定义马上就会说到，我们可以先看看下面这幅图：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/5156ab1334b7f33858c6233c6a88fcd8.png" alt=""></p>
<p>从图中我们可以看出来词法分析器还在和符号表进行交互，其主要作用是从符号表中读取有关标识符种类信息，以确定需要向语法分析器传送的词法单元。</p>
<h2 id="一、词法单元"><a href="#一、词法单元" class="headerlink" title="一、词法单元"></a>一、词法单元</h2><p>现在我们就先来看看前面提到的一些专业名词：</p>
<ul>
<li><strong>词法单元</strong>：由一个 <strong>词法单元名和一个可选的属性</strong> 构成。<br>比如一个特定的关键字，或者代表一个标识符的输入字符序列。</li>
</ul>
<blockquote>
<p>词法单元是语法分析器处理的输入符号。</p>
</blockquote>
<ul>
<li><p><strong>词素</strong>：源程序中的一个字符序列，它和某个词法单元的模式匹配。它被词法分析器识别为该词法单元的一个实例；</p>
</li>
<li><p><strong>模式</strong>：它描述了一个词法单元的词素可能具有的形式；</p>
</li>
</ul>
<p>这儿我大致地解释一下这三个概念之间的关系：词法单元指定的是某一类型的事物，用面向对象来说就是，词法单元类（class）；词素就是指的是该类的具体实例；而模式就是该类的一个属性，它描述了词素所具有的具体特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Tokens&#123;</div><div class="line">  string pattern;</div><div class="line">&#125;;</div><div class="line">Tokens lexeme;</div></pre></td></tr></table></figure>
<p>并不是说实际就是这个代码，我只是为了便于理解，而进行的类比。下表给出了一些常见的词法单元：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">非正式描述</th>
<th style="text-align:left">词素实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>if(关键字)</strong></td>
<td style="text-align:left">字符i,f</td>
<td style="text-align:left">if</td>
</tr>
<tr>
<td style="text-align:left"><strong>else(关键字)</strong></td>
<td style="text-align:left">字符e,l,s,e</td>
<td style="text-align:left">else</td>
</tr>
<tr>
<td style="text-align:left"><strong>comparison(比较运算符)</strong></td>
<td style="text-align:left">&lt;,&gt;,&lt;=,&gt;=,==…</td>
<td style="text-align:left">&lt;=, !=</td>
</tr>
<tr>
<td style="text-align:left"><strong>id(标识符)</strong></td>
<td style="text-align:left">字母开头的字母/数字串</td>
<td style="text-align:left">pi, printf</td>
</tr>
<tr>
<td style="text-align:left"><strong>number(数字)</strong></td>
<td style="text-align:left">数字常量</td>
<td style="text-align:left">3.1415</td>
</tr>
<tr>
<td style="text-align:left"><strong>literal(字符/串)</strong></td>
<td style="text-align:left">两双引号之间的任何字符</td>
<td style="text-align:left">“hello, world”</td>
</tr>
</tbody>
</table>
</div>
<h4 id="词法单元的大致分类"><a href="#词法单元的大致分类" class="headerlink" title="词法单元的大致分类"></a>词法单元的大致分类</h4><p>1）、<strong>关键字</strong>：每个关键字有一个词法单元；<br>2）、<strong>标识符</strong>：一个表示所有标识符的词法单元；<br>3）、<strong>常量</strong>：常量词法单元包含的数字和字符串；<br>4）、<strong>运算符</strong>：运算法也是一个词法单元，可以是比较运算符，也可以是算术运算符；<br>5）、<strong>标点符号</strong>：每一个标点符号有一个词法单元。比如括号等等；</p>
<h4 id="词法单元的属性值"><a href="#词法单元的属性值" class="headerlink" title="词法单元的属性值"></a>词法单元的属性值</h4><p>从这里我们可以看出来词法单元表示了一类事物，但是我们如何去区分具体的词素？ <strong>词法分析器不仅向语法分析器返回一个词法单元的名字，还会返回一个描述该词法单元的词素属性值</strong>。</p>
<p>比如我们声明的一个变量、或者函数时，它作为标识符一类的词法单元。它们更加详细的信息（词素、类型、第一次在源代码中出现的位置）都会保存在符号表中。<br>因此：</p>
<blockquote>
<p><strong>一个标识符的属性值是一个指向符号表中该标识符对应项的指针</strong>。</p>
</blockquote>
<p>注意，词法单元的属性值是指向符号表项的指针。</p>
<h2 id="二、正则表达式"><a href="#二、正则表达式" class="headerlink" title="二、正则表达式"></a>二、正则表达式</h2><p>这一节主要是在讲正则表达式，如果已经熟悉了正则表达式，可以直接跳过阅读词法单元的识别。而且这一节会增加很多概念，也是比较枯燥的。<br>从前面我们可以感性（直观）知道哪些词素是某一类型的词法单元。为了能够明确地划分不同词素对应的词法单元，我们需要引入正则表达式。<br>正则表达式是一种用来描述词素模式的重要表示方法。因此正则表达式就描述了特定词素对应的模式。</p>
<p>在词法分析中，最重要的语言上的运算是：<strong>并、连接和闭包</strong> 运算：</p>
<ul>
<li>并（L|M）：得到的串s可能属于L也可能属于M。但只能是其中之一；</li>
<li>连接(LM)：得到的串s即属于L，也属于M；</li>
<li>闭包：闭包分Kleene闭包和正闭包。Kleene闭包是指某一集合的符号重复 0～∞ 多次，可能是空串。正必报不包含重复0次，即不包含空串；</li>
</ul>
<p><code>letter_ (letter_ | digit_) *</code>这是一个c语言中标识符的正则表达式。其中用letter_来表示任一字母或者下划线，用digit_表示数位。c语言中标识符必须是必须是以字符开头，包含数字、字符来表示。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>正则表达式中，括号的优先级最高，优先级依次降低：<br>1）、一元运算符 <code>*</code>；<br>2）、连接（左结合）；<br>3）、并运算符优先级最低（左结合）；</p>
<p>比如正则表达式 <code>(a|b)*</code>，可以表示多个串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">空集;//闭包次数为0;　</div><div class="line">a;//闭包次数为1,取并的左边;</div><div class="line">aa;//闭包次数为2,一直取并的左边;</div><div class="line">aa...a;//闭包次数为n,一直取并的左边;</div><div class="line">b;//闭包次数为1,取并的右边;</div><div class="line">bb;//闭包次数为2,取并的右边;</div><div class="line">bb...b;//闭包次数为n,取并的右边;</div><div class="line">ab;//闭包次数为2,先取左边再取右边;</div><div class="line">ba;//闭包次数为2,先取右边再取左边;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如上, 可以用一个正则表达式定义的语言叫做<strong>正则集合</strong>。如果两个正则表达式r和s表示相同的语言，则称 r 和 s 等价<code>r=s</code> 。</p>
<h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p>c语言中的标识符是由字母、数字和下划线组成的串，下面是c标识符对应语言的正则定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">letter_ -&gt; A | B | C | ... | Z | a | b | c | ... | z | _ </div><div class="line">digit  -&gt; 0 | 1 | ... | 9 </div><div class="line">id -&gt; letter_ (letter_ | digit  ) *</div></pre></td></tr></table></figure>
<h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p>无符号数是形如5280、0.01234、6.336E4或者1.89E-4的串。下面的正则定义给出了这类符号串的精确定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">digit -&gt; 0 | 1 | ...| 9</div><div class="line">digits -&gt; digit  digit* </div><div class="line">optionalFraction -&gt; . digits | 空集</div><div class="line">optionalExponent -&gt; (E (+|-|空) digits) | 空</div><div class="line">number -&gt; digits optionalFraction optionalExponent</div></pre></td></tr></table></figure>
<h4 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h4><ul>
<li><strong>单目后缀运算符+</strong>：指的正闭包；</li>
<li><strong>单目后缀运算符?</strong>：表示出现0个，或者一个；</li>
<li><strong>字符类</strong>：正则表达式a<sub>1</sub> | a<sub>2</sub> | a<sub>3</sub> |…|a<sub>n</sub>可以缩写为 <strong>[a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>]</strong>。当a1到an形成一个逻辑上连续的序列时，可以写作 <strong>[a1 - a<sub>n</sub>]</strong>;</li>
</ul>
<h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p>我们可以使用正则表达式的扩展，来把例一的正则表达式进行改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">letter_ -&gt; [A-Za-z_]</div><div class="line">digit  -&gt; [0-9]</div><div class="line">id -&gt; letter_ (letter_ | digit  ) *</div></pre></td></tr></table></figure>
<p>现在通过正则表达式，我们可以写出对应词法单元对应的模式来。因此下一步要做的就是读取源代码里面的字符流，搭配对应的词法单元的模式，生成对应的词法单元。</p>
<h2 id="三、输入缓冲"><a href="#三、输入缓冲" class="headerlink" title="三、输入缓冲"></a>三、输入缓冲</h2><p>很多情况下，我们需要至少向前看一个字符。比如在c语言中，像-、=或者&lt; 这样单字符运算符也有可能是 -&gt; 、== 或者&lt;= 这样的双字符。<br>在编译原理中会引入一个哨兵标记的双缓冲区方案来处理向前看运算符的问题。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/1d850c00280d8de9ea211898983c3e50.png" alt=""><br>上图中出现的lexemeBegin和forward指针作用分别是：<br>1）、<code>lexemeBegin</code>：该指针指向当前词素的开始处。当前我们正在匹配某一正则表达式对应模式的词素；<br>2）、<code>forward</code>：该指针一直向前扫描，直到发现某个模式被匹配为止。</p>
<ul>
<li><p>第一步、读取内容到缓冲区中：每次读取缓冲区长度的字符到缓冲区中；<br>每个输入缓冲区的容量通常是一个磁盘块的大小，比如4096字节。我们在读取的时候就是一次性读取一个缓冲区长度的字符到缓冲区中，以避免频繁的使用读取函数。<br>当输入文件中的剩余字符不足缓冲区长度的时候，文件的默认会有一个eof（end of file）来表示文件结束。</p>
</li>
<li><p>第二步、lexemeBegin和forward指针的移动：使用lexemeBegin指针和forward指针读取指定模式的词素。<br>一旦确定了下一个词素（下图中的左括号）forward指针将指向该词素 <strong>结尾的字符</strong> 。词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来（在前面我们提过的词法单元分为词法单元名和可选的属性）。<br>然后lexemeBegin指针移动到 <strong>刚刚找到词素之后的第一个字符</strong> 。如下图所示：</p>
</li>
</ul>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/f38cb361abc1acc4d90fe24357c9d88e.png" alt=""></p>
<ul>
<li>第三步、缓冲区的替换：我们在移动forward指针前需要判断当前是否已经到达某个缓冲区的末尾。<br>如果是，我们需要将新字符读入到另外一个缓冲区中（前面提到的双缓冲区），且将forward指针指向新缓冲区的头部。</li>
</ul>
<h4 id="哨兵标记"><a href="#哨兵标记" class="headerlink" title="哨兵标记"></a>哨兵标记</h4><p>如前面所说，我们在每次移动forward指针时，我们都需要检查是否到达了缓冲区的末尾。如果是的话，我们就需要加载另一个缓冲区。因此在这里我们需要做两次测试：<br>1）、检查是否到达缓冲区的末尾；<br>2）、确定读入的字符是什么；<br>解决这两个问题，我们可以在缓冲区的末尾增加一个“哨兵”，比如<code>eof</code>：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/632ec991b874e291d70cecf5039ebc90.png" alt=""></p>
<p>从这儿我们可以知道，对于编译器而言在进行词法分析的时候，需要通过lexemeBegin和forward来扫描缓冲区。如果匹配某一个词素时，比如很长的字符串（比如将一片短篇小说作为常量字符串放到一个变量中）时，那就会出现缓冲区长度不足的情况，因此在日常编码中将长字符串拆分成多个短的字符串。</p>
<p>这其实也算是学习编译原理，有助于提供编程效率的一个例子了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前面我们用正则表达式来表示一个模式，现在我们需要通过制定模式来识别对应的词法单元。下面是大部分词法单元，以及对应的模式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">词法单元</th>
<th style="text-align:left">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>digit</strong></td>
<td style="text-align:left">[0-9]</td>
</tr>
<tr>
<td style="text-align:left"><strong>digits</strong></td>
<td style="text-align:left">digit+</td>
</tr>
<tr>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">digits(.digits)?(E[+-]?digits)?</td>
</tr>
<tr>
<td style="text-align:left"><strong>letter</strong></td>
<td style="text-align:left">[A-Za-z]</td>
</tr>
<tr>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">letter(letter,digit)*</td>
</tr>
<tr>
<td style="text-align:left"><strong>if</strong></td>
<td style="text-align:left">if</td>
</tr>
<tr>
<td style="text-align:left"><strong>then</strong></td>
<td style="text-align:left">then</td>
</tr>
<tr>
<td style="text-align:left"><strong>else</strong></td>
<td style="text-align:left">else</td>
</tr>
<tr>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">&lt;,&gt;,&lt;=,&gt;=,==,!=</td>
</tr>
<tr>
<td style="text-align:left"><strong>ws</strong>(空白符)</td>
<td style="text-align:left">(blank,tab,newline)+</td>
</tr>
</tbody>
</table>
</div>
<p>由于这块儿markdown解析的问题（加了转义字符之后依然显示有点问题），我将”|”替换为”,”。在理解的时候只需要将”,”更改为”|”即可。</p>
<p>上表中的词法单元<code>ws</code>和其他词法单元不同。当我们识别到ws时，</p>
<blockquote>
<p><strong>我们并不将它返回给语法分析器，而是从这个空白符之后的字符开始继续进行词法分析。返回给语法分析器的是下一个词法单元</strong> 。</p>
</blockquote>
<p>我们从前面的知识了解到，词法分析器通过对应模式识别到词法单元之后，会将词法单元名返回给语法分析器（空白符除外），以及对应词法单元的属性来确定某一特定实例。下表展示了对应词法单元，和对应属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">词素</th>
<th style="text-align:left">词法单元名字</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">任何空白符</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left"><strong>if</strong></td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">else</td>
<td style="text-align:left"><strong>else</strong></td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">指向符号表条目的指针</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left"><strong>number</strong></td>
<td style="text-align:left">指向符号表条目的指针</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">LT</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">GT</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left"><strong>…</strong></td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left"><strong>relop</strong></td>
<td style="text-align:left">NE</td>
</tr>
</tbody>
</table>
</div>
<p>表格里面的relop词法单元，区分其具体实例是通过对应词法单元属性值进行。</p>
<p>这一节主要是了解了词法单元相关知识其中，包括有词法单元、词素和模式。为了能够了解模式，我们又学习了一下正则表达式。下一节则主要是讲解词法单元的识别。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/28/compiler_stateGraph_kmp/" class="prev">PREV</a><a href="/2019/02/17/a_malloc_tutorial/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/10/28/compiler_token_regular/';
var disqus_title = '词法分析——词法单元和正则表达式';
var disqus_url = 'http://yoursite.com/2019/10/28/compiler_token_regular/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2020 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>