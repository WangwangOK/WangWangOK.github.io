<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS中Native的方式集成Vuforia、其源码解读以及自定义模型 · 凌云壮志幾多愁</title><meta name="description" content="iOS中Native的方式集成Vuforia、其源码解读以及自定义模型 - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://legacy.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS中Native的方式集成Vuforia、其源码解读以及自定义模型</h1><div class="post-info">Sep 13, 2017</div><div class="post-content"><p><img src="http://upload-images.jianshu.io/upload_images/619906-e5bbef9f60e5ee49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt=""><br>  随着前有Apple在iOS11中提供了ARKit，后有Google推出的ARCore，显然掀起了一股AR热潮（都是一堆废话，说白了就是公司要求做）。<br>  <a id="more"></a><br>  由于Vuforia已经存在较长时间了，相对于EasyAR或者百度AR更为成熟一点儿，所以它成了第一个技术选择。EasyAR和百度的AR——DuMix AR后面再依次去学习。好吧，先开始来学习Vuforia吧！<br>该文章同步发布在<a href="https://wangwangok.github.io" target="_blank" rel="external">我的博客</a>.</p>
<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><p>由于这些步骤相对来说比较基础，我就直接罗列出来。</p>
<ul>
<li><p>1、开发者官网<a href="https://developer.vuforia.com；" target="_blank" rel="external">https://developer.vuforia.com；</a></p>
</li>
<li><p>2、下载ios-sdk和ios-sample，并按照官方文档要求将ios-sample放入到ios-sdk的sample文件夹下</p>
</li>
<li><p>3、在vuforia的开发者官网上的License Manager和Target Manager，添加License-key和database<br><img src="http://upload-images.jianshu.io/upload_images/619906-8b73f5d04a424fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="License-Key"></p>
</li>
<li><p>4、将上一步添加的License-key，放在ios-sample中的代码文件<strong>SampleApplicationSession.mm</strong>中的方法<code>Vuforia::setInitParameters(mVuforiaInitFlags,&quot;&quot;);</code>中。具体步骤见<a href="https://library.vuforia.com/articles/Solution/How-To-add-a-License-Key-to-your-Vuforia-App" target="_blank" rel="external">官网</a>。</p>
  <pre>
Vuforia::setInitParameters(mVuforiaInitFlags,"AT16FIX/////AAAAGVieZ/kg1UkghTnYAz5zXWs8+y5JjeF/NJRcjgVDoCSvsrSt+lWzFMcIVBbQ2YSFRF+6J0GceHoaz8NctXib3cndJEacXmR+1FyO5FhalO7sC4hE9d1/x72qTNDhkPs4rF04JulMYT876Grsnmg9C61oyaDVwBfSpzNZ7gx3NADkkV5q4NQs4ghZwVCdMhj6LVt1YTJcwiuULtDTEgpFZZeW/nC8yiC53hpUFOVxhH++ILx1T65jpY8yDn6ct++3mgVeVotg/5tWXYb5FYqBtJiwU/LJJxhJYqUWyy4pd9dHUJBQojuAE8FoW1DmjokrpDWgjOMMp3am4GjNT04hCg+o0Z3SByYx6VIqfSR9fsXw");
</pre> 
</li>
<li><p>5、将第3步中Target Manager创建的database，传入相关的图片文件。也可以不传，这步可选；<a href="https://library.vuforia.com/articles/Solution/How-To-Work-with-Device-Databases.html" target="_blank" rel="external">怎样使用设备数据</a>。我们在<a href="https://developer.vuforia.com/targetmanager/project/checkDeviceProjectsCreated?dataRequestedForUserId=" target="_blank" rel="external">官方Developer</a>创建，下载对应的Database，在添加图片时，对应的星星数越高表明识别度越高<br><img src="http://upload-images.jianshu.io/upload_images/619906-9a71472177725481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="Target-Manager"><br>解压并将其引入到工程中：<br><img src="http://upload-images.jianshu.io/upload_images/619906-d8ea91265da85cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引入工程"><br>这一步可以不做，因为这只是在给后面打基础而已，如果只是运行demo的话是不需要做这一步的。如果做了这一步，在扫描你对应的图片的时候是没有任何效果的，具体的操作后面。</p>
</li>
<li><p>6、编译运行，由于需要使用到传感器，所以必须使用真机来运行。关于真机运行的相关事项查看apple developer</p>
</li>
</ul>
<h2 id="源码阅读顺序"><a href="#源码阅读顺序" class="headerlink" title="源码阅读顺序"></a>源码阅读顺序</h2><blockquote>
<p>源码说明：<br>Voforia SDK版本：<code>vuforia-sdk-ios-6-5-19</code><br>iOS Samples版本：<code>vuforia-samples-core-ios-6-5-20</code></p>
<p>如果不想看源码相关可直接跳过这部分，直接跟着“收尾”做自定义的tracker和模型（替换Teapot茶壶模型为自己的）</p>
</blockquote>
<p>为何要阅读源码？因为在<strong>Voforia</strong>的官方文档中我没有找到我自己想要的信息。所以我们需要通过阅读源码，来找到怎样才能去修改贴在目标图像中虚拟模型。以sample中<code>ImageTargetsViewController</code>为例来解读！<br>首先查看<code>ImageTargetsViewController.h</code>文件，我们先不看成员变量。先来看属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">属性类型</th>
<th style="text-align:left">初步作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>eaglView</strong></td>
<td style="text-align:left"><code>ImageTargetsEAGLView*</code></td>
<td style="text-align:left">初步认定为一个展示视图</td>
</tr>
<tr>
<td style="text-align:left"><strong>tapGestureRecognizer</strong></td>
<td style="text-align:left"><code>UITapGestureRecognizer*</code></td>
<td style="text-align:left">一个点击手势</td>
</tr>
<tr>
<td style="text-align:left"><strong>vapp</strong></td>
<td style="text-align:left"><code>SampleApplicationSession*</code></td>
<td style="text-align:left">初步认定为一个会话层（类似于ISO网络七层模型中，在TCP可以归于应用层，也就是说想偷懒可以直接将其代码放入控制器中。个人理解）</td>
</tr>
<tr>
<td style="text-align:left"><strong>showingMenu</strong></td>
<td style="text-align:left"><code>BOOL</code></td>
<td style="text-align:left">一个flag</td>
</tr>
</tbody>
</table>
<p>从上表中出现的属性，我们先来分析一下属性<code>eaglView</code>和<code>vapp</code>。</p>
<h4 id="SampleApplicationSession类"><a href="#SampleApplicationSession类" class="headerlink" title="SampleApplicationSession类"></a>SampleApplicationSession类</h4><p>在<code>ImageTargetsViewController</code>控制器类中，和下面会讲到的<code>ImageTargetsEAGLView</code>都有<code>SampleApplicationSession</code>类型的属性，所以我们有必要先来看看该类。同样的先看头文件，因为头文件能够让我们对于该类有大体的认识，而不拘于类具体的实现细节。<br>  粗略来看，提供了一个初始化方法；一个初始化AR的方法；四个对AR的操作方法（它们不是我们需要的重点，等到需要的时候再来仔细阅读）；以及一个对Camera的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)initWithDelegate:(id&lt;SampleApplicationControl&gt;) delegate;</div><div class="line">- (void) initAR:(int) VuforiaInitFlags orientation:(UIInterfaceOrientation) ARViewOrientation;</div><div class="line">- (bool) startAR:(Vuforia::CameraDevice::CAMERA_DIRECTION) camera error:(NSError **)error;</div><div class="line">- (bool) pauseAR:(NSError **)error;</div><div class="line">- (bool) resumeAR:(NSError **)error;</div><div class="line">- (bool) stopAR:(NSError **)error;</div><div class="line">- (bool) stopCamera:(NSError **)error;</div></pre></td></tr></table></figure></p>
<p>上述的initAR方法是通过异步实现的，当其AR初始化完成之后会调用方法下面会提到的代理方法<code>onInitARDone</code>。顺藤摸瓜，我们来看看该代理，那么该代理所需要处理的事务有哪些呢？这里先将<code>SampleApplicationControl</code>的所有方法先列出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@required</div><div class="line">- (void) onInitARDone:(NSError *)error;</div><div class="line">- (bool) doInitTrackers;</div><div class="line">- (bool) doLoadTrackersData;</div><div class="line">- (bool) doStartTrackers;</div><div class="line">- (bool) doStopTrackers;</div><div class="line">- (bool) doUnloadTrackersData;</div><div class="line">- (bool) doDeinitTrackers;</div><div class="line">- (void)configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;</div><div class="line"></div><div class="line">@optional</div><div class="line">- (void) onVuforiaUpdate: (Vuforia::State *) state;</div></pre></td></tr></table></figure></p>
<p>该代理方法中大多是涉及到的是tracker。通过从初始化方法开始查看方法调用，得出了一个程序执行流程图，<br><img src="http://upload-images.jianshu.io/upload_images/619906-ae15fadf72afc1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-1"><br>我们主动调用<code>initAR</code>方法，其结果会由回调方法<code>onInitARDone</code>反应给开发者。开发者可以用通过调用<code>doInitTrackers</code>来控制是否需要去加载tracker数据，如果可以加载数据则通过调用回调方法<code>doLoadTrackersData</code>来获取数据。关于该类中其他几个方法<code>startAR , pauseAR, resumeAR, stopAR</code>由调用人员主动调用，调用这些方法会触发对应的方法回调。<br>现在我们需要把目光转向<code>ImageTargetsEAGLView</code>类，并去具体的看一下里面的相关细节。</p>
<h4 id="SampleAppRenderer类"><a href="#SampleAppRenderer类" class="headerlink" title="SampleAppRenderer类"></a>SampleAppRenderer类</h4><p>这个类主要是做渲染相关的工作，其源码大多数为OpenGL。所以对于该类我只做具体的作用分析，而不去解释具体的源代码（因为我也不懂），如有需要的话，自行深究吧，哈哈哈😄。这里先将各个方法的作用罗列出来：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">initWithSampleAppRendererControl</td>
<td style="text-align:left">类初始化方法</td>
</tr>
<tr>
<td style="text-align:left">initRendering</td>
<td style="text-align:left">渲染相关的初始化</td>
</tr>
<tr>
<td style="text-align:left">setNearPlane:farPlane:</td>
<td style="text-align:left">配置投影矩阵数据</td>
</tr>
<tr>
<td style="text-align:left">renderFrameVuforia</td>
<td style="text-align:left">由Vuforia调用，渲染数据帧到屏幕</td>
</tr>
<tr>
<td style="text-align:left">renderVideoBackground</td>
<td style="text-align:left">后台渲染视频</td>
</tr>
<tr>
<td style="text-align:left">configureVideoBackgroundWithViewWidth:andHeight:</td>
<td style="text-align:left">视频相关的配置</td>
</tr>
<tr>
<td style="text-align:left">updateRenderingPrimitives</td>
<td style="text-align:left">更新渲染数据</td>
</tr>
</tbody>
</table>
<p>下面具体分析：老规矩，同样先看头文件，我们根据头文件暴露出来的方法一层一层往里剥。该类存在一个协议<code>SampleAppRendererControl</code>，和一个初始化方法<code>initWithSampleAppRendererControl</code>。使用这个方法需要传入一个遵守<code>SampleAppRendererControl</code>协议的类实例，第二个参数来决定<strong>VR/AR</strong>的模式，以及三个用于决定投影矩阵的参数。除了在初始化方法设置投影矩阵的参数，该类提供了一个public方法<code>setNearPlane:farPlane:</code>。进入到.mm文件中查看该初始化方法可以看出，只是对类内部私有属性进行相关的赋值操作以及对硬件设备进行相关的设置吧。<br>  现在来看看方法<code>initRendering</code>，这个方法里面主要是做了一些OpenGLES的东西，我们只需要知道里面做了一些和具体业务逻辑无关的东西就行了。<br>  接下来看<code>renderFrameVuforia</code>的作用是什么？源代码中说的很清楚：使用OpenGL绘制当前帧，<strong>当需要将当前帧渲染到屏幕上时</strong>，Vuforia会定期的在后台线程调用该方法。同样和业务逻辑无关，源码不细看。同样方法<code>renderVideoBackground</code>也是使用OpenGL来做，我们只需要从该方法的名字得知其用途（后台渲染视频）即可。<br>  <code>configureVideoBackgroundWithViewWidth:andHeight:</code>方法从名字就可以知道其作用。<code>updateRenderingPrimitives</code>方法的作用是：当屏幕尺寸发生改变或者是设备朝向改变之后，调用该方法来更新渲染原始数据。<br>  最后需要介绍一下该类很重要的的一个协议方法：<code>renderFrameWithState</code>，该方法被用于获取渲染相关的数据。通过对.mm文件可知，每渲染一次都会调用该方法一次。</p>
<h4 id="ImageTargetsEAGLView类"><a href="#ImageTargetsEAGLView类" class="headerlink" title="ImageTargetsEAGLView类"></a>ImageTargetsEAGLView类</h4><p>该类的头文件所暴露出来的初始化方法<code>- (id)initWithFrame:(CGRect)frame appSession:(SampleApplicationSession *) app</code>，我们以该方法入手来分析。第一个参数为当前视图的大小设置，第二个参数为前面我们讲到过的一个类实例。头文件中余下的方法还有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)finishOpenGLESCommands;</div><div class="line">- (void)freeOpenGLESResources;</div><div class="line"></div><div class="line">- (void) setOffTargetTrackingMode:(BOOL) enabled;</div><div class="line">- (void) configureVideoBackgroundWithViewWidth:(float)viewWidth andHeight:(float)viewHeight;</div><div class="line">- (void) updateRenderingPrimitives;</div></pre></td></tr></table></figure></p>
<p>方法<code>finishOpenGLESCommands , freeOpenGLESResources</code>分别对应着结束OpenGL和释放OpenGL的资源。configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives和类SampleAppRenderer公开的方法名一样，这里我猜测它们作用是一样的。<code>setOffTargetTrackingMode:</code>方法作用目前还不是很清晰，需要去.mm文件中详查。<br>  现在进入实现文件中，源码中提到了关于OpenGL线程安全的问题。iOS上的OpenGL ES是线程不安全的，在程序中Vuforia使用下面的方法来保证线程（OpenGL 上下文）安全：</p>
<ul>
<li>a、在主线程中创建OpenGL ES上下文。</li>
<li>b、Vuforia相机开始时，将其位于我们自己EAGLView视图上，并开启renderer线程。</li>
<li>c、Vuforia会在renderer线程上，定期调用我们的renderFrameVuforia（SampleAppRenderer类提到）方法。当第一次调用该方法的时候，<code>defaultFramebuffer</code>并不存在，调用createFramebuffer方法来创建它。createFramebuffer由主线程调用，而与此同时renderer线程会被阻塞。因此确保OpenGL ES上下文不会被并行使用</li>
</ul>
<p>在initWithFrame:appSession:的实现方法中会进行session，OpenGL的context和Renderer的赋值，初始化和绑定工作。而方法configureVideoBackgroundWithViewWidth:andHeight: , updateRenderingPrimitives在其实现方法中的确只是简单的调用了一下SampleAppRenderer 类的实例方法。<br>  现在主要来看看方法<code>setOffTargetTrackingMode :</code>，它的实现很简单只是对其私有成员变量NO。但是却在协议方法<code>renderFrameWithState</code>中大量的使用。该方法大部分是OpenGL相关的工作，我没有深究下去，只整理出来一个工作流程图：<br><img src="http://upload-images.jianshu.io/upload_images/619906-cfd6bcc49e13644a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-2"><br>目前来看ImageTargetsEAGLView类的主要作用在于保证OpenGL在iOS中达到线程安全，创建buffer和对buffer的管理，提供了对OpenGL的控制，而实际的渲染则由SampleAppRenderer来实现。</p>
<h4 id="ImageTargetsViewController类"><a href="#ImageTargetsViewController类" class="headerlink" title="ImageTargetsViewController类"></a>ImageTargetsViewController类</h4><p>现在将目光回到<code>ImageTargetsViewController</code>类上面来。由于是一个控制器类，所以我直接从.mm文件中着手。根据ViewController的加载顺序来看具体的逻辑，首先查找<code>loadView</code>方法，如果没有则查找<code>viewDidLoad</code>。源码中，loadView方法主要创建了vapp，eaglView以及对vapp初始化了AR相关的事务（其他视图和手势等先忽略，只关心属性vapp,eaglView相关的逻辑），将ViewController的View设置为eaglView。<br>  在loadView中将vapp的代理设置为控制器自身，此时通过上面介绍<strong> SampleApplicationSession</strong>时对应的程序执行流程，将目光放在对应的部分协议方法上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocol SampleApplicationControl</div><div class="line">- (void) onInitARDone:(NSError *)error;</div><div class="line">- (bool) doInitTrackers;</div><div class="line">- (bool) doLoadTrackersData;</div><div class="line">- (bool) doStartTrackers;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>从图-1可以看出是由<code>doInitTrackers</code>的返回值来判断是否需要去加载tracker数据(doLoadTrachersData)，最后在onInitARDone方法流程结束。通过这个就确定了我们的源码查看顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/// doInitTrackers --&gt; doLoadTrackersData --&gt; onInitARDone</div></pre></td></tr></table></figure></p>
<p>那么在ImageTargetsViewController类中，其流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-aadd870b1aae0265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图-3"><br>自此我们的源码阅读就告一段落，最后我们将要去实现开始提到的目的！</p>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>读到这里，自定义的数据集的切入点在方法<strong><code>doLoadTrackersData</code></strong>方法中，并且要doInitTrackers方法返回YES。如果没有执行“安装步骤”中的第5步的话，现在可以去做了！做完之后添加如下代码到工程中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">///ImageTargetsViewController.mm -&gt; doLoadTrackersData</div><div class="line">dataSetCustom = [self loadObjectTrackerDataSet:@&quot;WillDB_Device.xml&quot;];/// 这个dataset为你自己的名字</div><div class="line">if (dataSetCustom == NULL) &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line">if (! [self activateDataSet:dataSetCustom]) &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，扫描对应的图片发现是能够成功扫描对应的图片的。但是系统的图片能出来一个“茶壶”，而我们自己的图片上面什么也没有呢？<br>在这里我不想又去使用这个烦人的“茶壶”OpenGL模型了，我选择的是一个皮卡丘的原型（在文末我会将改造过的demo传到Github可以去那里下载这个原型）。</p>
<h4 id="模型obj到opengl数据的转换"><a href="#模型obj到opengl数据的转换" class="headerlink" title="模型obj到opengl数据的转换"></a>模型obj到opengl数据的转换</h4><p>就目前我知道的来说，在Xcode中无法使用<strong>.obj</strong>的模型数据的。我在网上找到了一个工具<strong><a href="https://github.com/HBehrens/obj2opengl" target="_blank" rel="external">obj2opengl</a></strong>，具体的使用方法见<a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">这里</a>，我还是大体来说一下使用步骤：<br>将下载好的文件放到特定的文件夹中，然后把对应的obj文件和它放在一起，使用终端进入<strong>obj2opengl.pl</strong>文件所在文件夹之后，输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./obj2opengl.pl yourobjfilename</div></pre></td></tr></table></figure></p>
<p>成功后，它会生成一个头文件，这就是通过obj文件生成的纹理坐标代码，在该头文件中有3个数组，这三个数组分别对应着<strong>xxxVerts [], xxxNormals [], xxxTexCoords []</strong>，和一个xxxxNumVerts（xxx为你的obj文件名字），<a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">具体使用说明</a>。</p>
<h4 id="模型替换"><a href="#模型替换" class="headerlink" title="模型替换"></a>模型替换</h4><p>通过前面的源码阅读，我们知道ImageTargetsViewController类是用来加载tracker数据的，SampleAppRenderer类是做渲染相关的数据，SampleApplicationSession类是使用tracker数据并控制AR，最后只剩下一个ImageTargetsEAGLView类。在该类中会做如下操作：</p>
<ul>
<li>1、在textureFilenames数组中，添加一个新的<a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/" target="_blank" rel="external">纹理</a>。这个自己选择一个纹理图片，我是随便选的，所以看起来会很丑。</li>
<li><p>2、在ImageTargetsEAGLView类的头文件中添加一个私有成员变量<strong>pikachuModel</strong>。用它来代替例子中的buildingModel。并在SampleApplication3DModel.h文件中添加方法<code>pikachu_ReWrite</code>，并在SampleApplication3DModel.m文件中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)pikachu_ReWrite&#123;</div><div class="line">#if kUse3DModel == 1</div><div class="line">  _numVertices = XY_PikachuMNumVerts;</div><div class="line">  _vertices = XY_PikachuMVerts;</div><div class="line">  _normals = XY_PikachuMNormals;</div><div class="line">  _texCoords = XY_PikachuMTexCoords;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>3、在ImageTargetsEAGLView.mm的方法<code>loadBuildingsModel</code>中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pikachuModel = [[SampleApplication3DModel alloc] init];</div><div class="line">[pikachuModel pikachu_ReWrite];</div></pre></td></tr></table></figure>
</li>
<li><p>4、将ImageTargetsEAGLView.mm文件中所有的buildingModel替换为<strong>pikachuModel</strong>，最后调节一下变量<strong>kObjectScaleOffTargetTracking</strong>的值，这个值调节由自己决定。</p>
</li>
</ul>
<p>上述的修改灵感大多是来自头文件<strong>Teapot.h</strong>，但是我们使用obj2opengl时生成的文件中并没有Teapot.h中<strong>teapotIndices</strong>对应的数组。相反多了一个无符号的整形变量<code>xxxNumVerts</code>，所以除了上诉的方法以外还有另外一种方法，具体的代码修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// ImageTargetsEAGLView.mm -&gt; renderFrameWithState方法中</div><div class="line">glVertexPointer(3, GL_FLOAT, 0, XY_PikachuMVerts);</div><div class="line">glNormalPointer(GL_FLOAT, 0, XY_PikachuMNormals);</div><div class="line">glTexCoordPointer(2, GL_FLOAT, 0, XY_PikachuMTexCoords);</div><div class="line"></div><div class="line">glDrawArrays(GL_TRIANGLES, 0, XY_PikachuMNumVerts);</div></pre></td></tr></table></figure></p>
<p>在使用这个方法时其（用obj2opengl生成的头文件的数组中的）数值比例是需要修改的，而且还需要对模型进行翻转。这个方法具体见<a href="https://developer.vuforia.com/forum/faq/android-how-do-i-replace-teapot" target="_blank" rel="external">How do I replace the Teapot</a>和<a href="https://library.vuforia.com/articles/Solution/Working-with-Vuforia-and-OpenGL-ES" target="_blank" rel="external">Replace the teapot model</a>。<br>在修改源码时主要就是在修改方法<code>renderFrameWithState</code>，它在介绍ImageTargetsEAGLView类时在文件的最开头就有提到，它是在每捕捉到一次tracker之后就会运行一次。<br>到这里一个很基本的Vuforia集成，源码的解读以及自定义tracker和模型就算完成了，最后附上Demo<a href="https://github.com/wangwangok/VuforiaSampleOBJC" target="_blank" rel="external">地址</a>。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://heikobehrens.net/2009/08/27/obj2opengl/" target="_blank" rel="external">obj2opengl</a></li>
<li><a href="https://github.com/HBehrens/obj2opengl" target="_blank" rel="external">obj2opengl Github</a></li>
<li><a href="http://www.songho.ca/opengl/gl_transform.html" target="_blank" rel="external">OpenGL Transformation</a></li>
<li><a href="https://developer.vuforia.com/forum/faq/android-how-do-i-replace-teapot" target="_blank" rel="external">How do I replace the Teapot</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/16/talk_about_thread/" class="prev">PREV</a><a href="/2017/08/01/oc_bridge_c_memory/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/09/13/ios_nativa_vuforia/';
var disqus_title = 'iOS中Native的方式集成Vuforia、其源码解读以及自定义模型';
var disqus_url = 'http://yoursite.com/2017/09/13/ios_nativa_vuforia/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2018 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>