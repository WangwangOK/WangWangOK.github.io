<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从头认识GCD——相关函数的使用 · 凌云壮志幾多愁</title><meta name="description" content="从头认识GCD——相关函数的使用 - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从头认识GCD——相关函数的使用</h1><div class="post-info">Jul 29, 2017</div><div class="post-content"><p><img src="http://upload-images.jianshu.io/upload_images/619906-d284587e19456111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  在上一篇文章中，我们对GCD有了基本的认知，知道其中一些简单的类型，和一些简单函数。这本篇文章中，我们将继续学习GCD中我们在日常开发中使用较多的函数，及其使用方法。在本篇会介绍<strong>dispatch_after、dispatch_apply、dispatch_group_t、dispatch_semaphore_t和dispatch_barrier</strong>等相关函数。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a><a id="more"></a> </h2><h3 id="dispatch-after／dispatch-time-t"><a href="#dispatch-after／dispatch-time-t" class="headerlink" title="dispatch_after／dispatch_time_t"></a>dispatch_after／dispatch_time_t</h3><p>我先来说说<code>dispatch_after</code>，从某种意义上来说，它属于任务提交的一种方式。在刚刚接触iOS开发的时候，我一直在想“ 对于<code>dispatch_after</code>它是同步提交代码块还是异步提交的代码块的呢？ ”。后来看到Apple的文档中说到”This function waits until the specified time and then asynchronously adds block to the specified queue”，也就是说它的延迟执行，并不是马上就将代码块就提交到指定的队列中，而是<strong>等到指定的时间通过异步的方式将提其提交到指定的队列中去</strong>。因此从这段话中也可以看出它仅仅是<code>dispatch_async</code>的一种。该函数的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>到这里就需要来系统地说一说<code>dispatch_after</code>函数的第一个参数，一个<code>dispatch_time_t</code>类型的变量。<code>dispatch_time_t</code>实际是<code>uint64_t</code>类型。系统为该类型定义了两个特殊值，分别是<strong>DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER</strong>，其中<code>DISPATCH_TIME_NOW</code>表示值为0，而<code>DISPATCH_TIME_FOREVER</code>表示为无穷大（infinity）。除了这两个特殊值之外，我们可以使用函数<code>dispatch_time()</code>来创建相对于默认时钟的时间；或者使用<code>dispatch_walltime()</code>函数获取绝对时间。<br>对于<code>dispatch_time()</code>函数，第一个参数我们传入DISPATCH_TIME_NOW或者DISPATCH_TIME_FOREVER值。</p>
<blockquote>
<p><code>dispatch_time()</code>函数第二个参数接受的是<strong> 基于纳秒级别的数值 </strong>。</p>
</blockquote>
<p>这时候就需要将具体的数字乘以一个常数，在<a href="https://developer.apple.com/documentation/dispatch/dispatch_time_multiplier_constants?language=objc" target="_blank" rel="external">官方文档</a>中列出了相关的常数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">常数</th>
<th style="text-align:left">意义</th>
<th style="text-align:left">具体数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NSEC_PER_SEC</td>
<td style="text-align:left">表示一秒能转换成多少纳秒</td>
<td style="text-align:left"><code>1000000000ull</code></td>
</tr>
<tr>
<td style="text-align:left">USEC_PER_SEC</td>
<td style="text-align:left">表示一秒能转换成多少微秒</td>
<td style="text-align:left"><code>1000000ull</code></td>
</tr>
<tr>
<td style="text-align:left">NSEC_PER_USEC</td>
<td style="text-align:left">表示一微秒转换成多少纳秒</td>
<td style="text-align:left"><code>1000ull</code></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// 使用相对时间，相对于现在延迟五秒</div><div class="line">dispatch_time_t time_t = dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time_t, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Run&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果我们想要该代码块延迟到某一指定时刻去执行，我们只需要去修改<code>dispatch_after</code>中的<code>dispatch_time_t</code>类型中值，在这里我们使用函数<code>dispatch_walltime</code>来获取绝对的时间戳值。<code>dispatch_walltime()</code>函数的一个参数是<code>struct timespec</code>类型的一个变量，它是一个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_STRUCT_TIMESPEC</div><div class="line">&#123;</div><div class="line">	__darwin_time_t  tv_sec;</div><div class="line">	long  tv_nsec;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>分别为秒和纳秒。<strong>timespec是基于纳秒级别的数值</strong>，关于<code>dispatch_walltime</code>具体是方式之一如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/// 延迟到某一绝对时刻执行</div><div class="line">struct timespec __tp;</div><div class="line">double sec, n_sec;</div><div class="line">n_sec = modf(1500794750.797543543, &amp;sec);</div><div class="line">__tp.tv_sec = sec;</div><div class="line">__tp.tv_nsec = n_sec;</div><div class="line">dispatch_after(dispatch_walltime(&amp;__tp, 0), dispatch_get_main_queue(), ^&#123;</div><div class="line">        ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上诉代码要等到时间戳为<code>1500794750</code>时才会将代码块提交到指定的事件队列中。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p><strong><em>dispatch_apply</em></strong>是<code>dispatch_sync</code>函数配合不同的的<code>dispatch_queue_t</code>队列，来循环执行任务。</p>
<blockquote>
<p>如果在<code>dispatch_apply</code>函数中传入的是一个并发队列，那么block中的任务就可以被并发的调用！相对于一般的for循环来说要高效许多。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, apply_queue, ^(size_t index) &#123;</div><div class="line">        NSLog(@&quot;%zd&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;End&quot;);</div></pre></td></tr></table></figure>
<p>结果如下<code>0, 2, 3, 1, 4, End</code>。但是我们将上面的并发队列改成串行队列之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t apply_queue = dispatch_queue_create(&quot;com.example.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, apply_queue, ^(size_t index) &#123;</div><div class="line">        NSLog(@&quot;%zd&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;End&quot;);</div></pre></td></tr></table></figure>
<p>返回的结果<code>0, 1, 2, 3, 4, End</code>和正常的for循环没有什么差距。但是不管是在并发的队列还是在串行的队列中，<code>End</code>总是最后才打印的。</p>
<h3 id="dispatch-group-t相关函数"><a href="#dispatch-group-t相关函数" class="headerlink" title="dispatch_group_t相关函数"></a>dispatch_group_t相关函数</h3><p>使用dispatch_group可以把许多操作进行合并。在将多个任务block提交之后，我们可以在dispatch_group中获取到这些操作全部完成的时间（不管是串行执行还是并行执行）。<br>现在我们有一个场景：第一步，我们需要将多个本地资源传递给服务器。我们用<code>dispatch_group</code>相关的技术来实现这个需求。创建一个<code>dispatch_group_t</code>类型的变量实现非常简单，不像其他GCD函数需要一些其他的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div></pre></td></tr></table></figure>
<p>当创建好了dispatch_group之后，我们需要将这些任务进行提交，这里我使用上一节的<code>dispatch_apply</code>来将多个任务放在并发的队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;</div><div class="line">  /// 模拟网络请求</div><div class="line">    NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在大部分的应用中的上传请求，都有一个上传完成的标志。第二步，那么在这个场景中我们如何知道所有图片已经上传成功呢？我们使用同步的方式，用户的交互不起作用，静静地等待上传完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_wait(upload_group, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;Upload Complete&quot;);</div></pre></td></tr></table></figure>
<p><code>dispatch_group</code>的管理是基于计数来做的。<code>dispatch_group_enter</code>会增加该Group内部的任务计数，<code>dispatch_group_leave</code>会减少该Group中未完成的计数，它们两个函数必须配对使用。<br><code>dispatch_group_wait</code>函数和我们在上一篇文中讲到的<code>dispatch_block_wait</code>函数功能类似，只不过<code>dispatch_group_wait</code>是针对多个block的<strong>同步方法</strong>，它会等到Group中所有的任务执行完毕之后才会去继续执行后面的内容。<br>  既然上面提到了<code>dispatch_group_wait</code>函数对应<code>dispatch_block_wait</code>函数，那么很明显应该存在<code>dispatch_block_notify</code>函数对应的Group函数。我们将上面的函数进行稍加改动，将同步的方式改为异步的方式，让用户能够做其他的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;/// 模拟网络请求</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Upload Complete&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  其实相对于使用繁琐的<code>dispatch_group_enter、dispatch_group_leave</code>，Apple给我们提供了更为简单的函数<code>dispatch_group_async</code>。我这样做的目的是为了在一开始就能让我们清楚，在Group内部是什么在决定着<code>dispatch_group_wait 、dispatch_group_notify</code>的触发时机，我们还是对上面的例子进行稍加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.upload.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_async(upload_group, upload_queue, ^&#123;</div><div class="line">            NSLog(@&quot;Upload %zd&quot;,index);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;Upload Complete&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>很明显对于使用<code>dispatch_group_async</code>给我们带来便利的同时，在灵活性上也就出现缺失，再者就是在用Group做同步的时候使用<code>dispatch_group_enter、dispatch_group_leave</code>是更好的选择！</p>
<h3 id="dispatch-semaphore-t相关函数"><a href="#dispatch-semaphore-t相关函数" class="headerlink" title="dispatch_semaphore_t相关函数"></a>dispatch_semaphore_t相关函数</h3><p>在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来（来自<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99" target="_blank" rel="external">维基百科</a>）。通俗一点儿讲就是说在进程内部有一原子递增和递减的计数器（也就是该数据变量<strong>具有原子性</strong>）。<br>如果触发了某个操作使得信号量小于等于0，那么该操作将会被阻塞，直到其信号量大于0。上面提到过，信号量是基于进程的。所以：</p>
<blockquote>
<p>信号量不依赖于任何队列，它可以在任何线程中使用。</p>
</blockquote>
<p>在GCD中，函数<code>dispatch_semaphore_signal</code>增加信号量计数，如果之前信号量计数小于等于0，该函数会唤醒当前正在等待的线程。相反，函数<code>dispatch_semaphore_wait</code>会减少信号量计数，如果当该信号量计数小于或者等于0之后，会阻塞当前线程，等待其他操作来增加信号量计数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)downloadSync&#123;</div><div class="line">    NSMutableArray *contents = [NSMutableArray array];</div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line">    </div><div class="line">    dispatch_group_t upload_group = dispatch_group_create();</div><div class="line">    dispatch_queue_t upload_queue = dispatch_queue_create(&quot;com.example.download.gcd&quot;, dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0));</div><div class="line">    dispatch_apply(5, dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^(size_t index) &#123;</div><div class="line">        dispatch_group_enter(upload_group);</div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), upload_queue, ^&#123;</div><div class="line">            NSString *cts = [NSString stringWithFormat:@&quot;%zd&quot;,index];</div><div class="line">            NSLog(@&quot;~ %@ ~&quot;,cts);</div><div class="line">            [contents addObject:cts];</div><div class="line">            dispatch_group_leave(upload_group);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(upload_group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    return contents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在来看看上面这个方法可以正常的返回吗？除了<code>dispatch_semaphore_t</code>相关的代码，我都是直接从上面拷贝下来，没有做任何修改。当我跑起来之后，始终方法<code>downloadSync</code>不会返回，这里很明显的是造成了死锁的问题！由于<code>dispatch_semaphore_wait</code>函数会阻塞当前线程（它此时是处于主线程中），<code>dispatch_group_notify</code>函数的任务线程即为主线程对应的主任务队列。<code>dispatch_semaphore_wait</code>需要等到函数<code>dispatch_semaphore_signal</code>来增加信号量计数之后才会继续执行主线程，而<code>dispatch_group_notify</code>又要在主线程中执行（由于主线程被阻塞）之后才能去调用<code>dispatch_semaphore_signal</code>函数，因此就造成了死锁，程序永远不会继续执行！。<br>解决办法也很简单，将<code>dispatch_semaphore_signal</code>放在一个并行的任务队列中进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_group_notify(upload_group, dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0), ^&#123;</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面使用信号量的相关函数，实现了异步转同步的需求。</p>
<h3 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier"></a>dispatch_barrier</h3><p><code>dispatch_barrier</code>的作用是在并发队列中实现同步操作。在并发队列中，任务的提交顺序会影响到执行顺序，当异步提交的任务在<code>dispatch_barrier</code>之后，该任务需要等到<code>dispatch_barrier</code>提交的任务执行完成之后才会开始执行。<br>把上面的话用下面的图通俗的来解释一下：<br><img src="http://upload-images.jianshu.io/upload_images/619906-c458370900934975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用下面的伪代码来实现一下上图中的相关任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_async(task_queue, task_1);</div><div class="line">dispatch_async(task_queue, task_2);</div><div class="line">dispatch_async(task_queue, task_3);</div><div class="line">dispatch_barrier_async(task_queue, task_4);</div><div class="line">dispatch_async(task_queue, task_5);</div></pre></td></tr></table></figure>
<p><strong>函数<code>dispatch_barrier_async</code>中block参数，会被目标队列复制并持有，直到任务完成时被释放</strong>。官方文档中提到：</p>
<blockquote>
<p>目标队列必须是用户手动创建的并发队列，如果传入的是串行队列或者是全局并发队列，那么这个函数就和<code>dispatch_async</code>类似。</p>
</blockquote>
<p><code>dispatch_barrier_sync</code>在做同步操作时和<code>dispatch_barrier_async</code>效果类似，但是它必须得等到block任务完成之后才会返回！而且<code>dispatch_barrier_sync</code>函数的目标线程不会复制和持有block。</p>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>在这篇文章的最后以<code>dispatch_once</code>来做一个结尾，对于<code>dispatch_once</code>我们iOS开发者用的太多了。<strong>该函数在多线程环境下同样也是安全的</strong>，如果是在多线程中进行调用，它会同步地等待block任务执行完成！官方文档中提出：对于<code>dispatch_once</code>函数的</p>
<blockquote>
<p>第一个参数必须是存储在全局区或者静态区的变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t predicate;</div><div class="line">dispatch_once(&amp;predicate, ^&#123;</div><div class="line">  ...        </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>关于dispatch_once更多的文章见<a href="https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html" target="_blank" rel="external">dispatch_once</a>，以及对应的源码<a href="https://github.com/apple/swift-corelibs-libdispatch/blob/master/src/once.c" target="_blank" rel="external">once.c</a>。第三篇文章会在后面放出来，我准备写关于<code>dispatch_source</code>和<code>dispatch_data</code>以及<code>dispatch_io</code>等相关知识。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>根据文中出现顺序</p>
<ul>
<li><a href="https://apple.github.io/swift-corelibs-libdispatch/" target="_blank" rel="external">Apple Dispatch Github</a></li>
<li><a href="https://developer.apple.com/documentation/dispatch/dispatch_time_multiplier_constants?language=objc" target="_blank" rel="external">Dispatch Time Multiplier Constants</a></li>
<li><a href="http://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="external">Elapsed Time</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99" target="_blank" rel="external">信号量</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/01/oc_bridge_c_memory/" class="prev">上一篇</a><a href="/2017/07/29/gcd_basic/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/07/29/gcd_func/';
var disqus_title = '从头认识GCD——相关函数的使用';
var disqus_url = 'http://yoursite.com/2017/07/29/gcd_func/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2017 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>