<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 语法分析——自底向上语法分析中的规范LR和LALR · 凌云壮志幾多愁</title><meta name="description" content="语法分析——自底向上语法分析中的规范LR和LALR - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://legacy.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">语法分析——自底向上语法分析中的规范LR和LALR</h1><div class="post-info">May 5, 2020</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这篇文章中主要看两种LR语法分析技术，相对于上一篇中SLR，本篇文章的两种LR技术对它进行了扩展，<strong>在输入中向前看一个符号</strong>。这两种技术分别是：</p>
<ul>
<li>“规范LR”：也可以直接叫做”LR”方法，这个方法会使用很大的一个项集，称为LR(1)项集；</li>
<li>“向前看LR”：也可以直接叫做”LALR”方法，它基于LR(0)项集（比LR(1)项集状态要少很多）。<strong>很多情况下LALR是最合适的选择</strong>；</li>
</ul>
<h2 id="一、规范LR-1"><a href="#一、规范LR-1" class="headerlink" title="一、规范LR(1)"></a>一、规范LR(1)</h2><p>我们来看个情况，在SLR方法中，如果项集 <script type="math/tex">I_{i}</script> 包含项 <script type="math/tex">[A\rightarrow \alpha\ \ \cdot\ ]</script>，如果当前输入符号 a 存在于FOLLOW(A)中。如果基于SLR来说，那么我们肯定会将 α 归约为A。然而在某些情况下，当状态 i 出现在栈顶时，栈中的可行前缀是 βα ，并且最右句型中 a 都不可能跟在 βA 之后，也就是说我们肯定不能简单就将 α 归约为 A 。</p>
<p>因此我们可以在项中新增一个分量，这个分量为一个终结符号。比如现在项可以表示为 <script type="math/tex">[A\rightarrow\alpha\cdot \beta,\ a]</script>，其中 <script type="math/tex">A\rightarrow\alpha\beta</script> 是一个产生式，而a是一个终结符号或者右端结束标记$。我们称这样的项为 <strong>LR(1)项</strong> 。其中的1指的是第二个分量的长度。</p>
<p>第二个分量称为 <strong>向前看符号</strong> 。</p>
<p>正式的说，LR(1)项<script type="math/tex">[A\rightarrow\alpha \cdot \beta,\ a]</script>对于可行前缀 γ 有效的条件是存在推导<script type="math/tex">S\rightarrow xAw\rightarrow x\alpha\beta w</script>，其中：</p>
<ul>
<li>可行前缀为 xα；</li>
<li>要么 a 是 w 的第一个符号，要么w为空串且a对于结束符；</li>
</ul>
<h4 id="构造LR-1-项集"><a href="#构造LR-1-项集" class="headerlink" title="构造LR(1)项集"></a>构造LR(1)项集</h4><p>LR(1)项集构造方法：一个增广文法G‘，在原来SLR的基础上对CLOSURE函数和GOTO函数进行改造。大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SetOfItems CLOSURE(I) &#123;</div><div class="line">    repeat</div><div class="line">        for(I中的每个项[A -&gt; α·Bβ, a]) &#123;</div><div class="line">            for(G&apos;中每个产生式B -&gt; γ) &#123; </div><div class="line"></div><div class="line">/// 解释一下，G’表示增广文法（它包含了文法的所有产生式）；B -&gt; γ 表示在增广文法中当存在产生式头部为当前项点号右边的非终结符号时，进行下面的操作</div><div class="line"></div><div class="line">                for(FIRST(βa)中每个终结符号b) &#123;</div><div class="line">                    将[B -&gt; γ, b]项添加到集合I中；</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    until 不能向I中加入更多的项；</div><div class="line">    return I;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SetOfItems GOTO(I,X) &#123;</div><div class="line">    将J初始化为空集；</div><div class="line">    for (I中的每个项 [A -&gt; α·Xβ, a])</div><div class="line">/// 这里我解释一下，循环I中的每一个项，直到出现点号右边的符号和传入的参数符号X相同时进行后续操作</div><div class="line">        将项[A -&gt; αX·β, a]加入到集合J中; </div><div class="line">    return CLOSURE(J);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void items(G&apos;) &#123;</div><div class="line">    将C初始化为&#123;CLOSURE&#125;(&#123;[S&apos; -&gt; ·S, $]&#125;);</div><div class="line">    repeat </div><div class="line">        for(C中每个项集I) &#123;</div><div class="line">            for(每个文法符号X) &#123;</div><div class="line">                if (GOTO(I,X)非空且不在C中)</div><div class="line">                    将GOTO(I,X)加入C中；</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    until 不再有新的项集加入到C中</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码是我对上面的表示翻译了一下，看下面代码时可以对照上面的内容对应着看。而且对Item进行了更新，因为在LR(1)项集中Item需要一个向前看运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">struct Item &#123;</div><div class="line">int position; /// 点号所处位置</div><div class="line">int id; /// 当前项在产生式集合中的编号</div><div class="line">Symbol *forwardSymbol; /// 向前看符号</div><div class="line">Item()&#123;</div><div class="line">    position = 0;</div><div class="line">    id = 0;</div><div class="line">    forwardSymbol = nullptr;</div><div class="line">&#125;</div><div class="line">Item(int pos, int idt, Symbol *ptr):position(pos),id(idt),forwardSymbol(ptr)&#123;&#125;</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"></div><div class="line">SetOfItems&lt;Item&gt; LR_1::LRCollection::closure(SetOfItems&lt;Item&gt;&amp; set) </div><div class="line">&#123;</div><div class="line">    for (SetOfItems&lt;Item&gt;::iterator itr = set.begin(); itr != set.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        Item item = *itr;</div><div class="line">        vector&lt;Production&gt; productions = grammer.productions;</div><div class="line">        Production prod = productions[item.id];</div><div class="line">        Symbol *dst_sym = prod.bodies[item.position];</div><div class="line">        for (vector&lt;Production&gt;::iterator p_itr = productions.begin(); p_itr != productions.end(); ++p_itr)</div><div class="line">        &#123;</div><div class="line">            int index = p_itr - productions.begin();</div><div class="line">            if((p_itr-&gt;header).identifier() != dst_sym-&gt;identifier())</div><div class="line">            &#123;</div><div class="line">                continue;</div><div class="line">            &#125; </div><div class="line">            Symbol *beta = prod.bodies[item.position + 1];</div><div class="line">            vector&lt;Symbol *&gt;first = grammer.FIRST(beta);</div><div class="line">            if (first.size() &lt;= 0)</div><div class="line">            &#123;</div><div class="line">                first = grammer.FIRST(item.forwardSymbol);</div><div class="line">            &#125;</div><div class="line">            for (vector&lt;Symbol *&gt;::iterator s_itr = first.begin(); s_itr != first.end(); ++s_itr)</div><div class="line">            &#123;</div><div class="line">                Item itm(0,index, *s_itr);</div><div class="line">                set.push_back(itm); /// &lt;------------------------ 自增长</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return set;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SetOfItems&lt;Item&gt; LR_1::LRCollection::lr_goto(SetOfItems&lt;Item&gt;&amp; set, Symbol *symbol, int *offset)</div><div class="line">&#123;</div><div class="line">    SetOfItems&lt;Item&gt; temp;</div><div class="line">    for (SetOfItems&lt;Item&gt;::iterator itr = set.begin(); itr != set.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        Item item = *itr;</div><div class="line">        Production prod = grammer.productions[item.id];</div><div class="line">        Symbol *sym = prod.bodies[item.position];</div><div class="line">        if (sym-&gt;identifier() != symbol-&gt;identifier())</div><div class="line">        &#123; /// 目标符号不符合</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        int position = item.position + 1;</div><div class="line">        if (position &gt;= prod.bodies.size())</div><div class="line">        &#123; /// 异常</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Item result(item.id, item.position + 1, item.forwardSymbol);</div><div class="line">        temp.push_back(result);</div><div class="line">    &#125;</div><div class="line">    return closure(temp);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void LR_1::LRCollection::items()</div><div class="line">&#123;</div><div class="line">    /// 1、将[S&apos; -&gt; .S, $]作为初始化加入到集合中</div><div class="line">    SetOfItems&lt;Item&gt; set;</div><div class="line">    Item it(0,0,const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr())); /// 产生式集合中第0个为增广表达式</div><div class="line">    set.push_back(it);</div><div class="line">    vector&lt;SetOfItems&lt;Item&gt; &gt; collection(1, set);</div><div class="line">    using vector_type=vector&lt;SetOfItems&lt;Item&gt;&gt;;</div><div class="line">    for(vector_type::iterator itr = collection.begin(); itr != collection.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        vector &lt;Symbol *&gt; symbols = grammer.symbols;</div><div class="line">        for (vector&lt;Symbol *&gt;::iterator s_itr = symbols.begin(); s_itr != symbols.end(); ++s_itr)</div><div class="line">        &#123;</div><div class="line">            int offset = 0;</div><div class="line">            SetOfItems&lt;Item&gt; items = lr_goto(*itr, *s_itr, &amp;offset);</div><div class="line">            int result = contain_set(items);</div><div class="line">            if (result == -1)</div><div class="line">            &#123;</div><div class="line">                collection.push_back(items);</div><div class="line">                Item item = items[0];</div><div class="line">                std::string key  = format(&quot;%d_%d_%d&quot;,item.id,item.position, item.forwardSymbol-&gt;identifier());</div><div class="line">                item_map.insert(make_pair(key, offset));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们来看一个增广文法，我们使用上面的知识可以对这个增广文法构造出它对应的项集：</p>
<script type="math/tex; mode=display">
S' \rightarrow S\\
S \rightarrow CC\\
C \rightarrow cC\ |\ d</script><p>下图是对应的项集族：</p>
<p><img src="/uploads/bottom2top_syntax_parser/7.png" alt=""></p>
<p>这个项集中的和上一篇文章中看到的项是不仅仅有了点号位置区分，还有向前看运算符的区分。</p>
<p>下面我们来看一下规范LR中ACTION函数的具体行为：</p>
<ul>
<li>1）、如果 <script type="math/tex">[A\rightarrow \alpha \cdot a \beta, b]</script> 在 <script type="math/tex">I_{i}</script> 中，并且 <script type="math/tex">GOTO[I_{i}, a] = I_{j}</script>，那么将 <code>ACTION[i, a]</code> 设置为“移入j”。这里 a 必须是一个终结符号；</li>
<li>2）、如果 <script type="math/tex">[A\rightarrow \alpha \cdot, a]</script> 在 <script type="math/tex">I_{i}</script> 中且 <script type="math/tex">A \neq S'</script> （即当前产生式头部的非终结符，不是产生式集合中的增广文法的开始符号），那么将 <code>ACTION[i, a]</code> 设置为“归约A -&gt; α”；</li>
<li>3）、如果 <script type="math/tex">[S' \rightarrow S \cdot , \$]</script> 在 <script type="math/tex">I_{i}</script> 中，那么将 <code>ACTION[i, a]</code> 设置为“接受”；</li>
<li>4）、不满足上诉规则的，都设置为“报错”；</li>
</ul>
<p>现在我们根据上面的四个规则，写出规范LR对应的ACTION函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">LR_Action* LR_1::LRCollection::action(SetOfItems&lt;Item&gt;&amp; set, Symbol *symbol) </div><div class="line">&#123;</div><div class="line">    if (symbol-&gt;isTerminal() == false)</div><div class="line">    &#123;</div><div class="line">        return nullptr;</div><div class="line">    &#125;</div><div class="line">    LR_Action *action = set.actionForSymbol(symbol-&gt;identifier());</div><div class="line">    if (action != nullptr)</div><div class="line">    &#123;</div><div class="line">        return action;</div><div class="line">    &#125;</div><div class="line">    vector&lt;GrammarParser::Production&gt; productions = grammer.productions;</div><div class="line">    for (SetOfItems&lt;Item&gt;::iterator itr = set.begin; itr != set.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        Item item = *itr;</div><div class="line">        GrammarParser::Production prod = productions[item.id];</div><div class="line">        if (item.position == prod.bodies.size()) /// 当前项的点号在最右边</div><div class="line">        &#123;</div><div class="line">            if (item.id == 0 &amp;&amp; symbol == GrammarParser::Symbol::EndedSymbolPtr())</div><div class="line">            &#123; /// 接受状态</div><div class="line">                AcceptAction *action = new AcceptAction();</div><div class="line">                return action;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (item.forwardSymbol-&gt;identifier() == symbol-&gt;identifier)</div><div class="line">            &#123; /// 归约</div><div class="line">                ReduceAction *redue = new ReduceAction(&amp;prod);</div><div class="line">                set.setActionForSymbol(symbol-&gt;identifier(), redue);</div><div class="line">                return redue;</div><div class="line">            &#125;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        int offset = -1;</div><div class="line">        SetOfItems result = lr_goto(set,symbol, &amp;offset);</div><div class="line">        if (result != set) /// 不同的两个状态，说明goto函数有效，此时应该做移入操作</div><div class="line">        &#123;</div><div class="line">            action = new ShiftAction(offset);</div><div class="line">            set.setActionForSymbol(symbol-&gt;identifier(), action);</div><div class="line">            return action;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ErrorAction *aciton = new ErrorAction();</div><div class="line">    return action;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个SLR(1)文法都是LR(1)文法。但是对于一个SLR(1)文法而言，规范LR(1)语法分析器的状态要比一个文法对应的SLR语法分析器的状态多。</p>
<blockquote>
<p>普遍而言，同一个文法的规范LR语法分析器状态要比SLR语法分析器状态多；</p>
</blockquote>
<h2 id="二、LALR"><a href="#二、LALR" class="headerlink" title="二、LALR"></a>二、LALR</h2><p>现在来看最后一个语法分析器LALR语法分析器。在实践中，用这种方法得到的分析表比规范LR分析表 <strong>小很多</strong>，而且大部分常见的程序设计语言构造都可以方便地使用一个LALR文法表示。</p>
<p>现在我们再来看看下面这张图：</p>
<p><img src="/uploads/bottom2top_syntax_parser/7.png" alt=""></p>
<p>图中 <script type="math/tex">I_{4} 和 I_{7}</script> 中项的第一个分量是相同，不同的是向前看符号不同。现在我们将 <script type="math/tex">I_{4}和I_{7}</script> 替换为 <script type="math/tex">I_{47}</script> （即<script type="math/tex">I_{4} 和 I_{7}</script>的并集），这个项集中的元素为：<script type="math/tex">[C \rightarrow d\ \cdot \ ,\ c/d/\$ ]</script>。</p>
<p>原来在从<script type="math/tex">I_{0}, I_{2}, I_{3}</script>经过b到达<script type="math/tex">I_{4}, I_{7}</script>的转换，都转向为 <script type="math/tex">I_{47}</script> 。这个经过修改之后的语法分析器行为在本质上和原分析器一样。</p>
<p>在这里：</p>
<blockquote>
<p>我们将项第一个分量称为 <strong>核心</strong> 。</p>
</blockquote>
<p>因此上诉的步骤就是在寻找具有相同核心的LR(1)项集，并将这些 “项的集合” 合并为一个项集。关于项、项集、项集族的关系在上一篇文章中有进行说明。</p>
<p>比如<script type="math/tex">T_{3}和I_{6}</script>就具有相同的核心 <script type="math/tex">[C\rightarrow c \cdot C,\ C\rightarrow \cdot cC,\ C\rightarrow \cdot d\ ]</script>。</p>
<p>一般而言，一个核心就是当前正在处理文法的 <strong>LR(0)</strong> 项集，一个LR(1)文法可能产生多个具有相同核心的项集。</p>
<blockquote>
<p>合并具有相同核心的状态不会产生出原有状态中没有出现的移入\归约冲突。因为移入动作仅有核心决定，不考虑向前看运算符。</p>
</blockquote>
<p>其中提到的“移入动作仅有核心决定，不考虑向前看运算符”，我们可以看上一节ACTION函数具体行为的第一点。</p>
<h4 id="简单地构造LALR分析器"><a href="#简单地构造LALR分析器" class="headerlink" title="简单地构造LALR分析器"></a>简单地构造LALR分析器</h4><p>构造语法分析器主要是从三个方面入手，分别是：确定项集，确定GOTO函数和确定ACTION函数。</p>
<ul>
<li>1）、我们从上面看出，我们可以先构造一个规范LR项集族，然后寻找具有相同核心的项集进行合并；</li>
<li><p>2）、然后根据核心来确定GOTO函数的关系。如果J是一个或多个LR(1)项集的并集，即 <script type="math/tex">J = I_{1} \bigcup I_{2} \bigcup\ ...\ \bigcup I_{n}</script>，它们能组成并集也就侧面反映了它们具有相同的核心。</p>
<p>  由于它们有相同的核心，那么<script type="math/tex">GOTO(I_{1},X),\ ...,\ GOTO(I_{n},X)</script>的核心也是相同的。令K是所有和 <script type="math/tex">GOTO(I_{1},X)</script> 具有相同核心项集的并集，那么 <strong>GOTO(J,X) = K</strong> 。</p>
</li>
<li>3）、关于ACTION函数的逻辑和实现规范LR的类似的（移入、归约、接受）；</li>
</ul>
<p>显然，这并不是高效的构造LALR语法分析器的方法。就比如在学习正则表达式转换为确定的有穷自动机（DFA）时，我们最初使用的正则表达式转换为NFA，然后通过子集构造法得到DFA。经过探索之后可以直接使用nullable、firstpos、lastpos以及followpos将正则表达式转换为DFA。</p>
<p>同样的，我们也可以用更加高效的方法来构造LALR语法分析表。</p>
<h4 id="⚠️⚠️⚠️-高效构造LALR语法分析表"><a href="#⚠️⚠️⚠️-高效构造LALR语法分析表" class="headerlink" title="⚠️⚠️⚠️ 高效构造LALR语法分析表"></a>⚠️⚠️⚠️ 高效构造LALR语法分析表</h4><p>我们可以对上面的方法进行修改，使得我们在创建LALR(1)语法分析表的过程中不需要构造出完整的规范LR(1)项集族。</p>
<p>在介绍具体的思想之前，我先解释一下“内核项”。它在上一篇文章中提到，总体来说就是 <strong>点号不在最左边，但是增广文法的第一个产生式除外</strong> 。下面是构造高效LALR语法分析表的大致思路：</p>
<ul>
<li>1）、首先，我们可以只使用内核项来表示任意的LR(0)和LR(1)项集；</li>
<li><p>2）、使用“传播和自生成”的过程来生成向前看符号，根据对应的LR(0)项内核生成LR(1)项内核。</p>
<p>  这里我稍微多说一句，“传播和自生成”都是针对向前看符号而言的，“传播”是指我们从上一个项集对应的向前看符号传到下一个项集，作为对应项的向前看运算符。“自生成”则是指的根据GOTO函数和CLOSURE函数生成的向前看符号，具体的生成规则会在下面讲解；</p>
</li>
<li>3）、当有了内核之后，就可以使用CLOSURE函数对各个内核求其余项，最后生成语法分析表；</li>
</ul>
<p>现在我们需要给LR(0)内核加上正确地向前看符号，创建出正确地LALR(1)内核。现在来看一个内核项 <script type="math/tex">A \rightarrow \alpha \cdot B \beta,\ a</script>，以及存在对应产生式 <script type="math/tex">B\rightarrow \gamma  \theta</script> ，我们先来看CLOSURE和GOTO：</p>
<p>其CLOSURE函数结果为： <script type="math/tex">[A \rightarrow \alpha \cdot B \beta,\ a], [B\rightarrow \cdot\gamma\theta,\ FIRST(\beta a)]</script></p>
<p>其中GOTO函数的结果为：GOTO(I, B) = <script type="math/tex">A \rightarrow \alpha B\cdot \beta,\ a</script> ; <script type="math/tex">GOTO(I, \theta) = B\rightarrow \gamma \cdot \theta,\ FIRST(\beta a)</script></p>
<p>这儿我为什么要求这两个函数的值呢？因为它们和“传播和自生成”关系密切，对于GOTO函数之后得到的项集而言：</p>
<ul>
<li>如果<strong>FIRST(βa) == a</strong> 也就是说明FISRT(β)为空，也就是说我们不能在GOTO(I, θ)中自己生成一个向前看符号，因此我们将原来内核项的向前看符号 <strong>传播</strong> 到新的内核项；</li>
<li>如果<strong>FIRST(βa) != a</strong> 也就是说明FISRT(β)不为空，那么我们就可以通过FISRT(β) <strong>自生成</strong> 一个向前看符号；</li>
</ul>
<p>有了上面的基础之后，我相信下面这段话应该就可以看懂了：</p>
<p>令#为一个不在当前文法中的符号，令 <script type="math/tex">A\rightarrow \alpha \cdot \beta</script> 为内核LR(0)项。对于每个 X(文法符号) 计算 <script type="math/tex">J = GOTO(CLOSURE(\{[A\rightarrow \alpha \cdot \beta, \#]\}),\ X)</script> 。 对于J中的每个内核项，我们检查它的向前看符号集合：</p>
<p>1、如果#是它的向前看符号，那么向前看符号就是从 <script type="math/tex">A\rightarrow\alpha\cdot\beta</script> 传播到这个项的；</p>
<p>2、除此之外其他的向前看符号都是自发生成的；</p>
<blockquote>
<p>向前看符号 $ (结束符号) 对于初始项集中的项 <script type="math/tex">S'\rightarrow \cdot S</script> 而言是自发生成的</p>
</blockquote>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (K中的每个项 A -&gt; α·β)</div><div class="line">&#123;</div><div class="line">    J = CLOSURE(&#123;[A -&gt; α·β, #]&#125;);</div><div class="line">    if ([B -&gt; γ·Xδ, a]在J中，并且a不等于#)</div><div class="line">    &#123;</div><div class="line">        那么GOTO(I,X)中的项B -&gt; γX·δ向前看符号a是自生成的；</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([B -&gt; γ·Xδ, a]在J中)</div><div class="line">    &#123;</div><div class="line">        那么向前看符号从I中的项A -&gt; α·β传播到了B -&gt; γX·δ上；</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么到这儿应该就在想，这个传播的最初源头在哪儿呢？很明显这个源头就是增广文法的初始项集<script type="math/tex">[S'\rightarrow \cdot S, \$]</script>。</p>
<p>这块儿主要是理解传播和自生成向前看运算符。</p>
<p>到这儿我们也把规范LR和LALR大致了解了一下，在实际的运用中主要还是使用LALR的语法分析。其原因是它可以通过向前看一个符号来解决移入归约冲突，还有就是可以减少语法分析过程中出现的状态数量。</p>
<p>题外话，后面一段时间我可能不会更新编译原理相关的文章了，回归时间待定了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/09/07/opengl_ projection_matrix/" class="prev">PREV</a><a href="/2020/04/28/bottom2top_syntax_parser_basic/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/05/05/bottom2top_syntax_parser_lalr/';
var disqus_title = '语法分析——自底向上语法分析中的规范LR和LALR';
var disqus_url = 'http://yoursite.com/2020/05/05/bottom2top_syntax_parser_lalr/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2020 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>