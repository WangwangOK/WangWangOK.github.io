<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 语法分析——自顶向下语法分析 · 凌云壮志幾多愁</title><meta name="description" content="语法分析——自顶向下语法分析 - 王望"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/uploads/avatar/heart.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="凌云壮志幾多愁"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/uploads/avatar/pencil.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wwloading" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangwangok" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://legacy.gitbook.com/@wangwangok" target="_blank" class="nav-list-link">GITBOOK</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/11188e5bb304" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">语法分析——自顶向下语法分析</h1><div class="post-info">Apr 20, 2020</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自顶向下语法分析可以被看作是为输入串构造语法分析树的问题，它从语法分析的根节点开始，按照深度优先的规则创建这棵语法分析树的各个结点，自顶向下语法分析也可以被看作寻找输入串最左推导的过程。</p>
<p>本文的行文以下面的顺序展开：</p>
<p>1）、首先是以一个自顶向下语法分析的例子，为自顶向下语法分析有个大致的认识；</p>
<p>2）、其次我们就需要深入地了解自顶向下语法分析中使用到的“ <strong>递归下降语法分析</strong>”；</p>
<p>3）、但递归下降的语法分析存在一个很大的弊端就是有回溯的可能性，为了减少回溯的次数，因此我们需要向前看多个字符。 <strong>LL(k)</strong> ，其中k表示向前看的字符数；</p>
<p>4）、为了能够更加准确地知道向前看字符，我们需要构造“ <strong>预测分析表</strong> ”，而 <code>FIRST</code> 和 <code>FOLLOW</code> 集合是构造预测分析表必不可少的部分；</p>
<p>好吧，那我们先来看一个自顶向下的语法分析例子。</p>
<h2 id="一、自顶向下语法分析示例"><a href="#一、自顶向下语法分析示例" class="headerlink" title="一、自顶向下语法分析示例"></a>一、自顶向下语法分析示例</h2><p>我们消除了左递归之后的文法（关于消除左递归可在上一篇文章中查看）：</p>
<script type="math/tex; mode=display">
E \rightarrow TE^{'} \\ 
E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ 
T \rightarrow FT^{'}\\ 
T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ 
F \rightarrow (E)\ |\ \mathbf{id}</script><p>对于输入串 <code>id + id*id</code> 语法分析树推导序列如下图所示：</p>
<p><img src="/uploads/top2bottom_syntax_parser/1.png" alt=""></p>
<p>这里使用的最左推导，每次都是寻找当前语法分析树中最左边的非终结符进行推导操作。在自顶向下的分析过程中，对于同一非终结符号的选择指定产生式成为了关键问题，比如对于非终结符F来说，它存在两个产生式 <script type="math/tex">F \rightarrow (E)</script> 和 <script type="math/tex">F \rightarrow \mathbf{id}</script> ，如果我们选择错误之后，则难免需要进行回溯，并替换为另一个正确地产生式。这种分析方式就是我们首先要学习的 <strong>递归下降语法分析</strong> 。</p>
<p>但我们可以使用预测分析技术来避免回溯的发生，它通过向前看固定多个符号来选择正确地产生式。比如我们向前看 k 个符号，那么这类文法为 <strong>LL(k)</strong> 文法。而我们后续要学习的LL(1)文法，就是该文法的特例。即我们向前看1个符号。</p>
<h2 id="递归下降的语法分析"><a href="#递归下降的语法分析" class="headerlink" title="递归下降的语法分析"></a>递归下降的语法分析</h2><p>一个递归下降语法分析程序由一组过程（也可以理解为C语言里面的函数）组成，每个非终结符号有一个对应的过程。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void expr() &#123;...&#125;</div><div class="line">void statement() &#123;...&#125;</div><div class="line">void S() &#123;...&#125;</div></pre></td></tr></table></figure>
<p>程序的执行从开始符号对应的过程开始，如果这个过程完整地扫描了整个输入串，它就停止执行并宣布语法分析成功完成。</p>
<p>下面是一段伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void X1() &#123;...&#125;</div><div class="line">void X2() &#123;...&#125;</div><div class="line">...</div><div class="line">void Xk() &#123;...&#125;</div><div class="line"></div><div class="line">void A() &#123;</div><div class="line">    选择一个A产生式：A -&gt; X1X2X3... Xk； /// 需要注意的是这里X1, X2, X3, ... Xk组成的一个符号串，并不是非终结符号A的多个产生式</div><div class="line">    for(i = 1 to k) &#123;</div><div class="line">        if (Xi 是一个非终结符号) &#123; 调用Xi(); &#125;</div><div class="line">        else if (Xi等于当前的输入符号a) &#123; 读取下一个输入符号; &#125;</div><div class="line">        else &#123; 发生错误; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的Xi有可能就是非终结符号<code>A</code>自身，因此可能会形成递归调用的场景。通用的递归下降分析技术可能需要回溯，也就是说我们可能需要重复扫描输入。要支持回溯的话，那我们就需要修改上面的代码：</p>
<p>1）、首先需要按照非终结符号产生式的顺序逐个尝试各个产生式；</p>
<p>2）、然后需要一个局部指针变量来保存当前进行匹配的符号；</p>
<p>3）、如果发生当前既不是非终结符号，又不等于当前的输入符号时。我们需要将输入符号回溯到局部指针变量指向的符号；</p>
<p>4）、如果再也没有当前非终结符号产生式可尝试时，我们才认为发生了错误；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void X1() &#123;...&#125;</div><div class="line">void X2() &#123;...&#125;</div><div class="line">...</div><div class="line">void Xk() &#123;...&#125;</div><div class="line"></div><div class="line">char *input_char; /// 输入字符</div><div class="line"></div><div class="line">void A() &#123;</div><div class="line">    非终结符号A的产生式集合：&#123;</div><div class="line">        A-&gt;X1X2X3... Xk,</div><div class="line">        A-&gt;Y1Y2Y3... Yk,</div><div class="line">        A-&gt;Z1Z2Z3... Zk</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (选择一个A产生式：A -&gt; X1X2X3... Xk) &#123; /// -----&gt; 1</div><div class="line">        char *pivot = &amp;a; /// -----&gt; 2</div><div class="line">        for(i = 1 to k) &#123;</div><div class="line">            if (Xi 是一个非终结符号) &#123; 调用Xi(); &#125;</div><div class="line">            else if (Xi等于当前的输入符号*input_char) &#123; </div><div class="line">                读取下一个输入符号; </div><div class="line">                input_char++;</div><div class="line">            &#125; else &#123; </div><div class="line">                input_char = pivot; /// -----&gt; 3</div><div class="line">                break; </div><div class="line">            &#125; /// 继续读取下一个产生式</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (*input_char == *pivot) &#123;</div><div class="line">        发生了错误; /// -----&gt; 4</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Ⅰ、具体实例"><a href="#Ⅰ、具体实例" class="headerlink" title="Ⅰ、具体实例"></a>Ⅰ、具体实例</h3><p>下面我们来看一个具体的例子，对于文法：</p>
<script type="math/tex; mode=display">
S \rightarrow c A d \\
A \rightarrow ab\ |\ a</script><p>对于输入串 <code>w = cad</code>，其递归下降的语法分析过程为：</p>
<ul>
<li>1、对于开始符号<script type="math/tex">S \rightarrow c A d</script> ，并且此时的输入指针为 <code>c</code>，此时我们展开开始符号S</li>
</ul>
<p><img src="/uploads/top2bottom_syntax_parser/2.png" alt=""></p>
<ul>
<li>2、从输入指针指向的输入符号 <code>c</code> 和当前开始符号S展开的语法分析树最左边的叶子结点c相匹配，此时我们将指针移动到 <code>a</code>，并且考虑当前语法分析树的非终结符号A（从左到右扫描符号）。</li>
</ul>
<p><img src="/uploads/top2bottom_syntax_parser/3.png" alt=""></p>
<ul>
<li>3、我们使用产生式 <script type="math/tex">A \rightarrow ab</script> 进行展开。很明显第二个输入符号 <code>a</code> 匹配成功。</li>
</ul>
<p><img src="/uploads/top2bottom_syntax_parser/4.png" alt=""></p>
<ul>
<li>4、现在我们将输入指针移动到 <code>d</code> ，并且把语法分析树的当前结点移动到结点 <code>b</code> 。很明显可以看出来 d 和 b 并不匹配。</li>
</ul>
<p><img src="/uploads/top2bottom_syntax_parser/5.png" alt=""></p>
<ul>
<li>5、此时我们需要查看对于非终结符号A，是否存在尚未尝试过的产生式。在回到A时，我们需要将输入指针回退到上一个位置处，并且使用产生式 <script type="math/tex">A \rightarrow a</script> 进行推导：</li>
</ul>
<p><img src="/uploads/top2bottom_syntax_parser/6.png" alt=""></p>
<p>叶子结点 <code>a</code> 和当前输入指针指向的输入符号成功匹配。同样的移动输入指针到 <code>d</code> ，并且将目光移向语法分析树最右边的叶子结点处，它们同样是匹配的。因此上图中的语法分析树就是通过递归下降得到的结果。</p>
<blockquote>
<p>一个左递归的文法会使得它的递归下降语法分析器进入一个无限循环。</p>
</blockquote>
<p>由于回溯不是很高效，我们可以使用动态规划算法，构造基于表格的的方法。我会在单独的一篇文章来介绍一下动态规划。</p>
<h2 id="二、🍺🍺🍺-FIRST和FOLLOW集合（终结符号）"><a href="#二、🍺🍺🍺-FIRST和FOLLOW集合（终结符号）" class="headerlink" title="二、🍺🍺🍺 FIRST和FOLLOW集合（终结符号）"></a>二、🍺🍺🍺 FIRST和FOLLOW集合（终结符号）</h2><p>关于FIRST集合和FOLLOW集合一定要弄懂，因为这是在后续进行预测分析时必备的技能。在自顶向下的语法分析过程中，FIRST和FOLLOW使得我们可以根据下一个输入符号来选择应用哪个产生式。</p>
<h3 id="Ⅰ、FIRST"><a href="#Ⅰ、FIRST" class="headerlink" title="Ⅰ、FIRST"></a>Ⅰ、FIRST</h3><p><code>FIRST(α)</code> ：从 α 可以推导出一个串集合，而FIRST为这些串首个符号组成的集合；</p>
<p>如果 <script type="math/tex">\alpha \overset{*}{\rightarrow} \epsilon</script> (箭头上方的星号 * 表示 α 可以通过多个步骤之后得到 ε )，那么 ε 就在 FIRST(α) 中。又或者存在推导 </p>
<script type="math/tex; mode=display">
\alpha \overset{*}{\rightarrow} c\gamma</script><p>那么终结符号 c 也在 FIRST(α) 中。</p>
<p>计算文法符号X的FIRST(X)时，不断应用下面的规则，直到再没有新的 <strong>终结符号或者ε</strong> 可以被加入到任何FIRST集合中为止：</p>
<ul>
<li>1）、如果X是终结符号，那么FIRST(X) = X；</li>
<li><p>2）、如果X是一个非终结符号，且存在产生式 <script type="math/tex">X \rightarrow Y_{1}Y_{2}...Y_{k}</script> （其中k&gt;1）：</p>
<p>  如果终结符号 a 在 <script type="math/tex">FIRST(Y_{i})</script> 中的必要条件是 <script type="math/tex">FIRST(Y_{1})、FIRST(Y_{2})、...、FIRST(Y_{i-1})</script> 中包含有 ε 符号；</p>
<p>  比如 <script type="math/tex">FIRST(Y_{1})</script> 中所有符号一定都在 <script type="math/tex">FIRST(X)</script> 中，如果 <script type="math/tex">Y_{1}</script> 不能推导出 ε，那么我们就没有必要再向 <script type="math/tex">FIRST(X)</script> 加入任何符号。但是如果 <script type="math/tex">Y_{1}</script> 能推导出 ε，那么我们就需要查看其后非终结符号的推导情况了。</p>
<p>  简单来说就是，对于文法中非终结符号的产生式而言，观察其产生式体能够推导出终结符号的集合。</p>
</li>
<li>3）、如果 <script type="math/tex">X \rightarrow ε</script> 是一个产生式，那么 ε 加入到 FIRST(X) 中；</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>对于FIRST(α)我们看产生式头可以推导得到的产生式体中的首个符号集合</strong>，即计算FIRST时非终结符号处于产生式的头部。</p>
</blockquote>
<p>下面是FIRST集合求解的代码（靠着自己理解编写，难免存在问题，如有问题麻烦指出）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">vector&lt;Symbol *&gt; GrammarParser::ContextFreeGrammar::FIRST(Symbol *sym) &#123;</div><div class="line">    /// 视角总是把当前符号当做产生式的头部</div><div class="line">    vector&lt;Symbol *&gt;firsts;</div><div class="line">    /// 1、如果是一个终结符号，那么FIRST返回它自身</div><div class="line">    if (sym-&gt;isTerminal())</div><div class="line">    &#123;</div><div class="line">        firsts.push_back(sym);</div><div class="line">        return firsts;</div><div class="line">    &#125;</div><div class="line">    /// 2、如果是一个非终结符号，并且是一个产生式</div><div class="line">    for (vector&lt;Production&gt;::iterator itr = this-&gt;productions.begin(); itr != this-&gt;productions.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        Nonterminal header = itr-&gt;header; /// &lt;--------- 产生式头部</div><div class="line">        if (header.identifier() != sym-&gt;identifier())</div><div class="line">        &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        vector&lt;Symbol *&gt;bodies = itr-&gt;bodies;</div><div class="line">        for (vector&lt;Symbol *&gt;::iterator s_itr = bodies.begin(); s_itr != bodies.end(); ++s_itr)</div><div class="line">        &#123;</div><div class="line">            if (*s_itr == Symbol::EmptySymbolPtr())</div><div class="line">            &#123; /// 3、如果是一个推出空串的产生式</div><div class="line">                firsts.push_back(*s_itr);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            vector&lt;Symbol *&gt;temp = FIRST(*s_itr);</div><div class="line">            firsts.insert(firsts.end(),temp.begin(),temp.end()); /// 递归查看当前符号的FIRST集合情况</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return firsts;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Ⅱ、FOLLOW"><a href="#Ⅱ、FOLLOW" class="headerlink" title="Ⅱ、FOLLOW"></a>Ⅱ、FOLLOW</h3><p><code>FOLLOW(A)</code>：定义为在某些句型中，紧跟在非终结符号A右边的终结符号集合。</p>
<p>比如对于句型 <script type="math/tex">S \overset{*}{\rightarrow} \alpha A a \beta</script> ，终结符号 a 就在 FOLLOW(A) 中。如果非终结符号A是某些句型的最右符号，那么特殊的 “结束标记” <strong>$</strong> 也在FOLLOW(A)中。</p>
<p>和FIRST集合类似，计算所有非终结符号A的FOLLOW(A)集合时，不断应用下面的规则，直到再没有 <strong>新的终结符号</strong> 可以被加入到任意FOLLOW集合中为止：</p>
<ul>
<li>1）、将 $ 放到FOLLOW(S)中，其中S是开始符号，而 $ 是输入右端的结束标记；</li>
<li>2）、如果存在一个产生式 <script type="math/tex">A\rightarrow\alpha B \beta</script> ，那么FIRST(β)中除了ε之外的所有符号都在FOLLOW(B)中。即这块儿需要查看符号串β的推导；</li>
<li>3）、如果存在一个产生式 <script type="math/tex">A\rightarrow\alpha B</script>，那么FOLLOW(A)中所有的符号同时也都在FOLLOW(B)中；</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p>计算FOLLOW时非终结符号位于产生式体中，查看当前产生式体中（或者叫句型的右边部分）非终结符号紧挨着的 <strong>终结符号</strong> 集合。</p>
</blockquote>
<p>下面是FOLLOW集合的请求代码（和上面相同，同样可能存在问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">vector&lt;Symbol *&gt; GrammarParser::ContextFreeGrammar::FOLLOW(Symbol *sym) &#123;</div><div class="line">    /// 视角总是将当前符号放在产生式体中</div><div class="line">    vector &lt;Symbol *&gt; follows;</div><div class="line">    /// 1、如果当前符号时开始符号，那么将结束标记加入到follows中</div><div class="line">    if (sym-&gt;identifier() == productions[0].header.identifier())</div><div class="line">    &#123;</div><div class="line">        Symbol *end = const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr());</div><div class="line">        follows.push_back(end);</div><div class="line">        return follows;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (sym-&gt;isTerminal())</div><div class="line">    &#123;</div><div class="line">        return follows;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// 判断当前迭代器是否是body中的最后一个符号，</div><div class="line">    auto expr_last = [&amp;follows,this](vector&lt;Symbol *&gt;::iterator current, vector&lt;Symbol *&gt;::iterator begin, size_t count, Symbol *header_ptr) -&gt; bool &#123;</div><div class="line">        size_t idx = current - begin;</div><div class="line">        bool result = false;</div><div class="line">        if (idx == count - 1) /// 当前符号处于产生式体的末尾</div><div class="line">        &#123;</div><div class="line">            /// 如果存在一个产生式 A --&gt; aB，那么FOLOOW(A)中所有符号都在FOLLOW(B)中</div><div class="line">            vector&lt;Symbol *&gt; temp = FOLLOW(header_ptr);    </div><div class="line">            follows.insert(follows.end(), temp.begin(), temp.end());</div><div class="line">            result = true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /// 2、如果存在一个产生式 A --&gt; aBb，那么FIRST(b)中除了空串以外，所有符号都在FOLLOW(B)中</div><div class="line">    for (vector&lt;Production&gt;::iterator itr = this-&gt;productions.begin(); itr != this-&gt;productions.end(); ++itr)</div><div class="line">    &#123;</div><div class="line">        Nonterminal header = itr-&gt;header;</div><div class="line">        Symbol *header_ptr = &amp;header;</div><div class="line">        vector&lt;Symbol *&gt;bodies = itr-&gt;bodies;</div><div class="line">        size_t count = bodies.size();</div><div class="line">        vector&lt;Symbol *&gt;::iterator sym_itr = bodies.end(); /// 求解当前FOLLOW集合的符号指针；</div><div class="line">        for (vector&lt;Symbol *&gt;::iterator s_itr = bodies.begin(); s_itr != bodies.end(); ++s_itr)</div><div class="line">        &#123;</div><div class="line">            if (sym_itr != bodies.end())</div><div class="line">            &#123; /// 第2种情况求解</div><div class="line">                size_t first_index = s_itr - sym_itr;</div><div class="line">                if (first_index &lt;= 0) </div><div class="line">                &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                vector&lt;Symbol *&gt; firsts = FIRST(*s_itr);</div><div class="line">                for (vector&lt;Symbol *&gt;::iterator first_itr = firsts.begin(); first_itr != firsts.end(); ++first_itr)</div><div class="line">                &#123;</div><div class="line">                    if (*first_itr == Symbol::EmptySymbolPtr())</div><div class="line">                    &#123;</div><div class="line">                        /// 3、如果存在一个产生式 A --&gt; aB，或者产生式 A --&gt;aBb（FIRST(b)包含空串），那么FOLOOW(A)中所有符号都在FOLLOW(B)中</div><div class="line">                        bool result = expr_last(s_itr, bodies.begin(), count, header_ptr);</div><div class="line">                        size_t idx = s_itr - bodies.begin();</div><div class="line">                        if (result)</div><div class="line">                        &#123;</div><div class="line">                            sym_itr = bodies.end();</div><div class="line">                        &#125;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    follows.push_back(*first_itr);</div><div class="line">                    sym_itr = bodies.end();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (sym-&gt;identifier() != (*s_itr)-&gt;identifier())</div><div class="line">            &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            /// 3、如果存在一个产生式 A --&gt; aB，或者产生式 A --&gt;aBb（FIRST(b)包含空串），那么FOLOOW(A)中所有符号都在FOLLOW(B)中</div><div class="line">            bool result = expr_last(s_itr, bodies.begin(), count, header_ptr);</div><div class="line">            if (result)</div><div class="line">            &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            sym_itr = s_itr;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return follows;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Ⅲ、示例"><a href="#Ⅲ、示例" class="headerlink" title="Ⅲ、示例"></a>Ⅲ、示例</h3><p>我们对下面文法来求解FIRST和FOLLOW集合：</p>
<script type="math/tex; mode=display">
E \rightarrow TE^{'} \\ 
E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ 
T \rightarrow FT^{'}\\ 
T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ 
F \rightarrow (E)\ |\ \mathbf{id}</script><p>首先我们以非终结符号出现的顺序，将它们按照顺序排列起来（有点像消除左递归时，我们创建的非终结符号集合）： <script type="math/tex">E,\ T,\ E^{'},\ F,\ T^{'}</script></p>
<p>1）、 <strong>非终结符号E</strong> ：</p>
<p>FIRST(E) = { ( , <strong>id</strong> }，其推导过程为： <script type="math/tex">E \Rightarrow TE^{'} \Rightarrow FT^{'}E^{'} \Rightarrow (E)T^{'}E^{'}\ |\ \mathbf{id}</script>；</p>
<p>FOLLOW(E) = { ), $ }。从产生式 <script type="math/tex">F \rightarrow (E)</script> 我们可以得到一个终结符号。而且从求FOLLOW的第一点可知，对于开始符号，我们需要将$添加进去。</p>
<p>2）、 <strong>非终结符号E’</strong>：</p>
<p>FIRST(E’) = { +, ε }，其推导过程为：<script type="math/tex">E^{'} \rightarrow +TE^{'}\ |\ \epsilon</script>。</p>
<p>FOLLOW(E’) = { ), $ }，这是因为产生式 <script type="math/tex">E \rightarrow TE^{'}</script> 可知，FOLLOW(E)和FOLLOW(E’)是完全等价的。</p>
<p>3）、 <strong>非终结符号T</strong>：<br>FIRST(T) = { ( , <strong>id</strong> }，其推导过程为： <script type="math/tex">T \Rightarrow FT^{'} \Rightarrow (E)T^{'}E^{'}\ |\ \mathbf{id}</script></p>
<p>FOLLOW(T)的计算从上述的文法中可以看出，非终结符号T出现在产生式体中的有 <script type="math/tex">TE^{'},\ +TE^{'}</script> ，也就是在其后面的均为非终结符号E’。因此FOLLOW(T)包含FIRST(E’)；</p>
<p>由于E’可以推导出空串ε，而且根据产生式 <script type="math/tex">E \rightarrow TE^{'}</script> 。我们可以知道FOLLOW(T)同样等于FOLLOW(E)。因此求出上面两个的并集为：</p>
<p>FOLLOW(T) = { +, ), $ }。</p>
<p>4）、 <strong>非终结符号T‘</strong>：<br>FIRST(T’) = { <em>, $ }，其推导过程为：<script type="math/tex">T’\rightarrow FT’</script> ；</p>
<p>FOLLOW(T’) = { +, ), $ }。这是因为根据产生式 <script type="math/tex">T \rightarrow FT^{'}</script> 可知，FOLLOW(T’)和FOLLOW(T)是相同的；</p>
<p>5）、 <strong>非终结符号F</strong>：<br>FIRST(F) = { (, <strong>id</strong> }，其推导过程为 <script type="math/tex">F \rightarrow (E)\ |\ \mathbf{id}</script> ；</p>
<p>FOLLOW(F)的计算和非终结符号T是类似的，首先我们根据产生式 <script type="math/tex">T \rightarrow FT^{'},\ T^{'} \rightarrow *FT^{'}</script>可知，非终结符号F其后紧跟着非终结符号T’，因此FOLLOW(F)则包含了FIRST(T’)；</p>
<p>而且我们从产生式 <script type="math/tex">T \rightarrow FT^{'},\ T^{'} \rightarrow *FT^{'}\ |\ \epsilon</script> 可知，T’可以推导出空串ε，因此FOLLOW(F)也包含有FOLLOW(T)；</p>
<p>因此最终的结论为：FOLLOW(F) = { *, +, ), $ }</p>
<p>如果这块儿存在无法理解的部分，可以对照例子，返回查看FIRST和FOLLOW的计算方式。</p>
<h2 id="三、🍭🍭🍭LL-1-文法"><a href="#三、🍭🍭🍭LL-1-文法" class="headerlink" title="三、🍭🍭🍭LL(1)文法"></a>三、🍭🍭🍭LL(1)文法</h2><p>LL(1)中的第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，而“1”则表示在每一步中只需要向前看一个输入符号来决定语法分析动作。我们利用LL(1)的文法，可以构造出不需要回溯的递归下降语法分析器（即预测分析器）。</p>
<blockquote>
<p>左递归文法和二义性文法都不可能是LL(1)的</p>
</blockquote>
<p>对于任意两个不同的产生式：<script type="math/tex">A\rightarrow\alpha\ |\ \beta</script>，只有满足下面条件时，它们才是LL(1)文法：</p>
<p>1）、不存在终结符号a，使得 α 和 β 都能够推导出以 a 开头的串；</p>
<p>意思也就是说，FIRST(α) 和 FIRST(β) 是不相交的集合。</p>
<p>2）、 <strong>α和β中最多只有一个可以推导出空串</strong>；</p>
<p>当然这里一样的，FIRST(α) 和 FIRST(β) 是不相交的集合。如果出现了相交的集合，那么交集就是 ε 集。</p>
<p>3）、如果 <script type="math/tex">\beta \overset{*}{\rightarrow} \epsilon</script>，那么 α 不能推导出任何以 FOLLOW(A) 中某个终结符号开头的串。类似的，对于 α 也一样；</p>
<p>这里我仔细的说一下，如果要推导出以FOLLOW(A)中某个终结符号开头的串，那也就是说 FIRST(α) 和 FOLLOW(A) 要存在交集。对于推导 <script type="math/tex">\beta \overset{*}{\rightarrow} \epsilon</script> 而言，我们从第二点可以知道，那么此时 α 不能推导出 ε。这样看来要 FIRST(α) 和 FOLLOW(A) 存在交集，那是不可能发生的。</p>
<h3 id="👏👏👏构建预测分析表"><a href="#👏👏👏构建预测分析表" class="headerlink" title="👏👏👏构建预测分析表"></a>👏👏👏构建预测分析表</h3><p>我们构造一个预测分析表 M 。该表是一个二维数组，其中第一列为文法中出现的各个非终结符号；其中第一行为文法中出现的终结符号。</p>
<p>NT：非终结符号<br>t：终结符号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:left">+</th>
<th style="text-align:left">*</th>
<th style="text-align:left">(</th>
<th style="text-align:left">)</th>
<th style="text-align:left">id</th>
<th style="text-align:left">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:left">.</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">E’</td>
<td style="text-align:left"></td>
<td style="text-align:left">.</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">.</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">T’</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">.</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">.</td>
</tr>
</tbody>
</table>
</div>
<p>对于文法G的每个产生式 <script type="math/tex">A\rightarrow\alpha</script>，处理如下：</p>
<ul>
<li><p>1、对于FIRST(α)中每个终结符号a，将 <script type="math/tex">A\rightarrow\alpha</script> 加入到 <code>M[A,a]</code> 中。首先查看该产生式的FIRST集合，找到该集合中存在的所有终结符号a、b、c…</p>
<p>  如果FIRST(α)不存在ε空串，那么对应非终结符号构造结束，寻找下一个产生式。</p>
</li>
<li><p>2、如果FIRST(α)中存在ε空串：</p>
<p>  1）、对于FOLLOW(A)中每个终结符号b，将 <script type="math/tex">A\rightarrow\alpha</script> 加入到 <code>M[A,b]</code> 中；</p>
<p>  2）、如果$在FOLLOW(A)中，将 <script type="math/tex">A\rightarrow\alpha</script> 加入到 <code>M[A,$]</code>中；</p>
</li>
</ul>
<blockquote>
<p>通俗一点来说就是，先看FIRST集合，如果FIRST集合里面包含了空串，然后再看对应的FOLLOW集合</p>
</blockquote>
<p>简单一点来说就是，先查看对应产生式的FIRST集合，如果FIRST集无法推导出空串ε，那么该产生式结束，寻找下一个产生式；如果当前产生式FIRST可以推导出空串，那么求该非终结符号对应的FOLLOW集合和结束标记$。</p>
<p>同样的，我们还是以文法</p>
<script type="math/tex; mode=display">
E \rightarrow TE^{'} \\ 
E^{'} \rightarrow +TE^{'}\ |\ \epsilon\\ 
T \rightarrow FT^{'}\\ 
T^{'} \rightarrow *FT^{'}\ |\ \epsilon \\ 
F \rightarrow (E)\ |\ \mathbf{id}</script><p>举例：</p>
<p>下面使用的到FIRST集合FOLLOW集合的结果，是上一节里面求得的各个非终结符号的结果。具体可以对照上面内容一起看。</p>
<p>1）、对于非终结符号E而言，FIRST(E) = { ( , <strong>id</strong> }，因此我们将产生式 <script type="math/tex">E \rightarrow TE^{'}</script> 填入到对应的格子里面：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E \rightarrow TE^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E \rightarrow TE^{'}</script></td>
</tr>
</tbody>
</table>
</div>
<p>2）、对于非终结符号E’而言，FIRST(E’) = { +, ε }。由可知FIRST(E’)可以推导出空串ε，因此我们需要获取FOLLOW(E’)，得到 FOLLOW(E’) = { ), $ }。填写对应的格子如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E’</td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow +TE^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow \epsilon</script></td>
</tr>
</tbody>
</table>
</div>
<p>3）、对于非终结符号T而言，FIRST(T) = { ( , <strong>id</strong> }，可知其不能推导出空串。因此我们只需要填写FIRST集合里面对应表格即可：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow FT^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow FT^{'}</script></td>
</tr>
</tbody>
</table>
</div>
<p>4）、对于非终结符号T’而言，它和E‘有点相似之处。即我们从FIRST(T’) = { *, $ } 可知，其可以推导出空串。同样的我们需要查看 FOLLOW(T’) = { +, ), $ }</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T’</td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow *FT^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
</tr>
</tbody>
</table>
</div>
<p>5）、对于非终结符号F而言，其FIRST(F) = { ( , <strong>id</strong> }</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow (E)</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow \mathbf{id}</script></td>
</tr>
</tbody>
</table>
</div>
<p>将上面的表格汇总之后就得到了我们最终的预测分析表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NT\t</th>
<th style="text-align:center">+</th>
<th style="text-align:center">*</th>
<th style="text-align:center">(</th>
<th style="text-align:center">)</th>
<th style="text-align:center">id</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E \rightarrow TE^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E \rightarrow TE^{'}</script></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">E’</td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow +TE^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">E^{'} \rightarrow \epsilon</script></td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow FT^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow FT^{'}</script></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T’</td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow *FT^{'}</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">T^{'} \rightarrow \epsilon</script></td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow (E)</script></td>
<td style="text-align:center"></td>
<td style="text-align:center"><script type="math/tex">F \rightarrow \mathbf{id}</script></td>
</tr>
</tbody>
</table>
</div>
<p>下面的代码是对LL(1)文法的语法预测分析表的一个伪代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">class ll_prediction_analysis_table &#123;</div><div class="line">private:</div><div class="line">    ContextFreeGrammar grammar;</div><div class="line">    map&lt;int,int&gt; row_map; /// key: symbol id, value: table row index</div><div class="line">    map&lt;int,int&gt; col_map; /// key: symbol id, value: table col index</div><div class="line">    vector &lt; vector&lt;int&gt; &gt; table;</div><div class="line">private:</div><div class="line">    void extract_symbol() &#123; /// 从文法的各个产生式中分离出终结符和非终结符</div><div class="line">        int terminal_index = 0;</div><div class="line">        for (vector&lt;Production&gt;::iterator itr = grammar.productions.begin(); itr != grammar.productions.end(); ++itr)</div><div class="line">        &#123;</div><div class="line">            int index = itr - grammar.productions.begin();</div><div class="line">            vector&lt;Symbol *&gt; bodies = itr-&gt;bodies;</div><div class="line">            for (vector&lt;Symbol *&gt;::iterator body_itr = bodies.begin(); body_itr != bodies.end(); ++body_itr)</div><div class="line">            &#123;</div><div class="line">                if ((*body_itr)-&gt;isTerminal())</div><div class="line">                &#123;</div><div class="line">                    col_map.insert((*body_itr)-&gt;identifier(), terminal_index);</div><div class="line">                    ++terminal_index;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            row_map.insert((itr-&gt;header).identifier(),index);</div><div class="line">        &#125;</div><div class="line">        /// 添加结束符</div><div class="line">        int ended_key = (const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr()))-&gt;identifier();</div><div class="line">        col_map.insert(ended_key,terminal_index);        </div><div class="line"></div><div class="line">        vector &lt;int&gt; inner(col_map.size(),-1);</div><div class="line">        vector &lt;vector&lt;int&gt; &gt;tb(row_map.size(), inner);</div><div class="line">        table = tb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void create_table() &#123;</div><div class="line">        /// 这里我默认是对应产生式有对应的LL(1)文法，也就是说表内每一项只包含一个产生式，不会包含多重定义的项。</div><div class="line">        auto map_itr = row_map.cbegin();</div><div class="line">        while (map_itr != row_map.cend())</div><div class="line">        &#123;</div><div class="line">            int table_row_index = map_itr-&gt;second;</div><div class="line">            int key = map_itr-&gt;first;</div><div class="line">        &#125;</div><div class="line">        for (vector&lt;Production&gt;::iterator itr = grammar.productions.begin(); itr != grammar.productions.end(); ++itr)</div><div class="line">        &#123;</div><div class="line">            int index = itr-grammar.productions.begin();</div><div class="line">            Nonterminal header = itr-&gt;header;</div><div class="line">            int row_index = col_map[header.identifier()];</div><div class="line">            /// 1.对于FIRST中每个终结符号a，将产生式 A --&gt; α 加入到 table[A][a] 中</div><div class="line">            vector&lt;Symbol *&gt; first = grammar.FIRST(&amp;header);</div><div class="line">            if (first.size() &lt;= 0)</div><div class="line">            &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            bool empty = false;</div><div class="line">            for (vector&lt;Symbol *&gt;::iterator f_itr = first.begin(); f_itr != first.end(); ++f_itr)</div><div class="line">            &#123;</div><div class="line">                if (*f_itr == Symbol::EmptySymbolPtr())</div><div class="line">                &#123;</div><div class="line">                    empty = true;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                int f_key = (*f_itr)-&gt;identifier();</div><div class="line">                int col_index = col_map[f_key];</div><div class="line">                table[row_index][col_index] = index;</div><div class="line">            &#125;</div><div class="line">            /// 2. 如果FIRST中包含有空串时,FOLLOW(A)中每个终结符号b，将产生式 A --&gt; α 加入到 table[A][b] 中</div><div class="line">            /// 3. 如果结束符号$在FOLLOW(A)中，将产生式 A --&gt; α 加入到 table[A][$] 中</div><div class="line">            if (!empty)</div><div class="line">            &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            vector&lt;Symbol *&gt;follows = grammar.FOLLOW(&amp;header);</div><div class="line">            for (vector&lt;Symbol *&gt;::iterator f_itr = follows.begin(); f_itr != follows.end(); ++f_itr)</div><div class="line">            &#123;</div><div class="line">                int f_key = (*f_itr)-&gt;identifier();</div><div class="line">                int col_index = col_map[f_key];</div><div class="line">                table[row_index][col_index] = index;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">public:</div><div class="line">    ll_prediction_analysis_table(ContextFreeGrammar&amp; grammar) &#123;</div><div class="line">        this-&gt;grammar = grammar;</div><div class="line">        extract_symbol();</div><div class="line">        create_table();</div><div class="line">    &#125;</div><div class="line">    Production&amp; objectForPair(pair&lt;Symbol*, Symbol*&gt; row_col);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="四、非递归的预测分析"><a href="#四、非递归的预测分析" class="headerlink" title="四、非递归的预测分析"></a>四、非递归的预测分析</h2><p>我们可以显式地维护一个栈结构，来构造出一个非递归的预测分析器。如下图所示：</p>
<p><img src="/uploads/top2bottom_syntax_parser/7.png" alt=""></p>
<p>上图中的语法分析器有一个输入缓冲区，一个包含了文法符号序列的栈，一个上一节我们学习到的语法分析表，以及一个输出流。其中输入缓冲区中包含要进行语法分析的串。</p>
<p>其大致的执行过程如下：</p>
<p>1）、考虑栈顶符号X和当前输入符号a；</p>
<p>2）、如果X是一个非终结符号，该分析器查询预测分析表M中的条目<code>M[X,a]</code>来选择一个产生式；</p>
<p>3）、如果X不是一个非终结符号，那么检查终结符号X和当前的输入符号a是否匹配；</p>
<p>下面是表驱动的预测分析方法伪代码，其中输入为待匹配的字符串，和一个预测分析表；上图中栈第一个元素值为文法的开始符号，栈底存在一个哨兵，用于判断当前栈是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">bool ll_syntax::syntax() &#123;</div><div class="line">    Symbol *ended = const_cast&lt;Symbol *&gt;(Symbol::EndedSymbolPtr());</div><div class="line">    char* ip = &amp;input_string[0];</div><div class="line">    </div><div class="line">    for (Symbol *sym = stack.back(); sym-&gt;identifier() != ended-&gt;identifier(); sym = stack.back())</div><div class="line">    &#123;</div><div class="line">            if (sym-&gt;identifier() == *ip)</div><div class="line">        &#123;</div><div class="line">            stack.pop_back();</div><div class="line">            ip++;  </div><div class="line">            continue;  </div><div class="line">        &#125;</div><div class="line">        if (sym-&gt;isTerminal())</div><div class="line">        &#123;</div><div class="line">            return false; /// 语法错误</div><div class="line">        &#125;</div><div class="line">        Terminal ip_sym(*ip);</div><div class="line">        int status = 0;</div><div class="line">        Production prodction = table.objectForPair(make_pair(sym, &amp;ip_sym), &amp;status);</div><div class="line">        if (status != 0)</div><div class="line">        &#123;</div><div class="line">            return false; /// 语法错误</div><div class="line">        &#125;</div><div class="line">        /// 移除栈顶元素，然后将产生式体加入到栈中</div><div class="line">        stack.pop_back();</div><div class="line">        vector&lt;Symbol *&gt; bodies = prodction.bodies;</div><div class="line">        for (vector&lt;Symbol *&gt;::const_reverse_iterator itr = bodies.rbegin; itr != bodies.rend(); ++itr)</div><div class="line">        &#123;</div><div class="line">            stack.push_back(*itr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这儿我用代码简单地实现了一下，到这儿我们基本上把LL语法分析初步学习完了。 本篇文章中最主要部分还是对产生式求解FIRST集合和FOLLOW集合，这个是务必要掌握的，切记切记！！！</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/11/two_three_four_red_black_tree/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/04/20/top2bottom_syntax_parser/';
var disqus_title = '语法分析——自顶向下语法分析';
var disqus_url = 'http://yoursite.com/2020/04/20/top2bottom_syntax_parser/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>关注微博<a href="http://weibo.com/wwloading" target="_blank">@凌云壮志幾多愁</a>，让我们有更多的联系。</p><p>© 2016 - 2020 <a href="http://yoursite.com">王望</a>, Powered By <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>